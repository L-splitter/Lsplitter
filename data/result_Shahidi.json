[
    {
        "file": "dataset/1_original.java",
        "method": "getDefaultNamedXContents",
        "new_method_name": "get_entries",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81
        ],
        "extracted_lines": [
            "public static List<NamedXContentRegistry.Entry> getDefaultNamedXContents() {",
            "Map<String, ContextParser<Object, ? extends Aggregation>> map = new HashMap<>();",
            "map.put(CardinalityAggregationBuilder.NAME, (p, c) -> ParsedCardinality.fromXContent(p, (String) c));",
            "map.put(InternalHDRPercentiles.NAME, (p, c) -> ParsedHDRPercentiles.fromXContent(p, (String) c));",
            "map.put(InternalHDRPercentileRanks.NAME, (p, c) -> ParsedHDRPercentileRanks.fromXContent(p, (String) c));",
            "map.put(InternalTDigestPercentiles.NAME, (p, c) -> ParsedTDigestPercentiles.fromXContent(p, (String) c));",
            "map.put(InternalTDigestPercentileRanks.NAME, (p, c) -> ParsedTDigestPercentileRanks.fromXContent(p, (String) c));",
            "map.put(PercentilesBucketPipelineAggregationBuilder.NAME, (p, c) -> ParsedPercentilesBucket.fromXContent(p, (String) c));",
            "map.put(MedianAbsoluteDeviationAggregationBuilder.NAME, (p, c) -> ParsedMedianAbsoluteDeviation.fromXContent(p, (String) c));",
            "map.put(MinAggregationBuilder.NAME, (p, c) -> ParsedMin.fromXContent(p, (String) c));",
            "map.put(MaxAggregationBuilder.NAME, (p, c) -> ParsedMax.fromXContent(p, (String) c));",
            "map.put(SumAggregationBuilder.NAME, (p, c) -> ParsedSum.fromXContent(p, (String) c));",
            "map.put(AvgAggregationBuilder.NAME, (p, c) -> ParsedAvg.fromXContent(p, (String) c));",
            "map.put(WeightedAvgAggregationBuilder.NAME, (p, c) -> ParsedWeightedAvg.fromXContent(p, (String) c));",
            "map.put(ValueCountAggregationBuilder.NAME, (p, c) -> ParsedValueCount.fromXContent(p, (String) c));",
            "map.put(InternalSimpleValue.NAME, (p, c) -> ParsedSimpleValue.fromXContent(p, (String) c));",
            "map.put(DerivativePipelineAggregationBuilder.NAME, (p, c) -> ParsedDerivative.fromXContent(p, (String) c));",
            "map.put(InternalBucketMetricValue.NAME, (p, c) -> ParsedBucketMetricValue.fromXContent(p, (String) c));",
            "map.put(StatsAggregationBuilder.NAME, (p, c) -> ParsedStats.fromXContent(p, (String) c));",
            "map.put(StatsBucketPipelineAggregationBuilder.NAME, (p, c) -> ParsedStatsBucket.fromXContent(p, (String) c));",
            "map.put(ExtendedStatsAggregationBuilder.NAME, (p, c) -> ParsedExtendedStats.fromXContent(p, (String) c));",
            "map.put(ExtendedStatsBucketPipelineAggregationBuilder.NAME, (p, c) -> ParsedExtendedStatsBucket.fromXContent(p, (String) c));",
            "map.put(GeoBoundsAggregationBuilder.NAME, (p, c) -> ParsedGeoBounds.fromXContent(p, (String) c));",
            "map.put(GeoCentroidAggregationBuilder.NAME, (p, c) -> ParsedGeoCentroid.fromXContent(p, (String) c));",
            "map.put(HistogramAggregationBuilder.NAME, (p, c) -> ParsedHistogram.fromXContent(p, (String) c));",
            "map.put(DateHistogramAggregationBuilder.NAME, (p, c) -> ParsedDateHistogram.fromXContent(p, (String) c));",
            "map.put(AutoDateHistogramAggregationBuilder.NAME, (p, c) -> ParsedAutoDateHistogram.fromXContent(p, (String) c));",
            "map.put(VariableWidthHistogramAggregationBuilder.NAME, (p, c) -> ParsedVariableWidthHistogram.fromXContent(p, (String) c));",
            "map.put(StringTerms.NAME, (p, c) -> ParsedStringTerms.fromXContent(p, (String) c));",
            "map.put(LongTerms.NAME, (p, c) -> ParsedLongTerms.fromXContent(p, (String) c));",
            "map.put(DoubleTerms.NAME, (p, c) -> ParsedDoubleTerms.fromXContent(p, (String) c));",
            "map.put(LongRareTerms.NAME, (p, c) -> ParsedLongRareTerms.fromXContent(p, (String) c));",
            "map.put(StringRareTerms.NAME, (p, c) -> ParsedStringRareTerms.fromXContent(p, (String) c));",
            "map.put(MissingAggregationBuilder.NAME, (p, c) -> ParsedMissing.fromXContent(p, (String) c));",
            "map.put(NestedAggregationBuilder.NAME, (p, c) -> ParsedNested.fromXContent(p, (String) c));",
            "map.put(ReverseNestedAggregationBuilder.NAME, (p, c) -> ParsedReverseNested.fromXContent(p, (String) c));",
            "map.put(GlobalAggregationBuilder.NAME, (p, c) -> ParsedGlobal.fromXContent(p, (String) c));",
            "map.put(FilterAggregationBuilder.NAME, (p, c) -> ParsedFilter.fromXContent(p, (String) c));",
            "map.put(InternalSampler.PARSER_NAME, (p, c) -> ParsedSampler.fromXContent(p, (String) c));",
            "map.put(GeoHashGridAggregationBuilder.NAME, (p, c) -> ParsedGeoHashGrid.fromXContent(p, (String) c));",
            "map.put(GeoTileGridAggregationBuilder.NAME, (p, c) -> ParsedGeoTileGrid.fromXContent(p, (String) c));",
            "map.put(RangeAggregationBuilder.NAME, (p, c) -> ParsedRange.fromXContent(p, (String) c));",
            "map.put(DateRangeAggregationBuilder.NAME, (p, c) -> ParsedDateRange.fromXContent(p, (String) c));",
            "map.put(GeoDistanceAggregationBuilder.NAME, (p, c) -> ParsedGeoDistance.fromXContent(p, (String) c));",
            "map.put(FiltersAggregationBuilder.NAME, (p, c) -> ParsedFilters.fromXContent(p, (String) c));",
            "map.put(AdjacencyMatrixAggregationBuilder.NAME, (p, c) -> ParsedAdjacencyMatrix.fromXContent(p, (String) c));",
            "map.put(SignificantLongTerms.NAME, (p, c) -> ParsedSignificantLongTerms.fromXContent(p, (String) c));",
            "map.put(SignificantStringTerms.NAME, (p, c) -> ParsedSignificantStringTerms.fromXContent(p, (String) c));",
            "map.put(ScriptedMetricAggregationBuilder.NAME, (p, c) -> ParsedScriptedMetric.fromXContent(p, (String) c));",
            "map.put(IpRangeAggregationBuilder.NAME, (p, c) -> ParsedBinaryRange.fromXContent(p, (String) c));",
            "map.put(TopHitsAggregationBuilder.NAME, (p, c) -> ParsedTopHits.fromXContent(p, (String) c));",
            "map.put(CompositeAggregationBuilder.NAME, (p, c) -> ParsedComposite.fromXContent(p, (String) c));",
            "map.put(StringStatsAggregationBuilder.NAME, (p, c) -> ParsedStringStats.PARSER.parse(p, (String) c));",
            "map.put(TopMetricsAggregationBuilder.NAME, (p, c) -> ParsedTopMetrics.PARSER.parse(p, (String) c));",
            "map.put(TimeSeriesAggregationBuilder.NAME, (p, c) -> ParsedTimeSeries.fromXContent(p, (String) (c)));",
            "List<NamedXContentRegistry.Entry> entries = map.entrySet()",
            ".stream()",
            ".map(entry -> new NamedXContentRegistry.Entry(Aggregation.class, new ParseField(entry.getKey()), entry.getValue()))",
            ".collect(Collectors.toList());",
            "entries.add(",
            "new NamedXContentRegistry.Entry(",
            "Suggest.Suggestion.class,",
            "new ParseField(TermSuggestionBuilder.SUGGESTION_NAME),",
            "(parser, context) -> TermSuggestion.fromXContent(parser, (String) context)",
            ")",
            ");",
            "entries.add(",
            "new NamedXContentRegistry.Entry(",
            "Suggest.Suggestion.class,",
            "new ParseField(PhraseSuggestionBuilder.SUGGESTION_NAME),",
            "(parser, context) -> PhraseSuggestion.fromXContent(parser, (String) context)",
            ")",
            ");",
            "entries.add(",
            "new NamedXContentRegistry.Entry(",
            "Suggest.Suggestion.class,",
            "new ParseField(CompletionSuggestionBuilder.SUGGESTION_NAME),",
            "(parser, context) -> CompletionSuggestion.fromXContent(parser, (String) context)",
            ")",
            ");",
            "return entries;",
            "}"
        ],
        "max_rank": -0.48795180722908515
    },
    {
        "file": "dataset/2_original.java",
        "method": "testExecuteFailedActionTransform",
        "new_method_name": "handle_Watch",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67
        ],
        "extracted_lines": [
            "public void testExecuteFailedActionTransform() throws Exception {",
            "Watch watch = mock(Watch.class);",
            "when(watch.id()).thenReturn(\"_id\");",
            "GetResponse getResponse = mock(GetResponse.class);",
            "when(getResponse.isExists()).thenReturn(true);",
            "mockGetWatchResponse(client, \"_id\", getResponse);",
            "when(parser.parseWithSecrets(eq(watch.id()), eq(true), any(), any(), any(), anyLong(), anyLong())).thenReturn(watch);",
            "ZonedDateTime now = clock.instant().atZone(ZoneOffset.UTC);",
            "ScheduleTriggerEvent event = new ScheduleTriggerEvent(\"_id\", now, now);",
            "TriggeredExecutionContext context = new TriggeredExecutionContext(watch.id(), now, event, timeValueSeconds(5));",
            "Condition.Result conditionResult = InternalAlwaysCondition.RESULT_INSTANCE;",
            "ExecutableCondition condition = mock(ExecutableCondition.class);",
            "when(condition.execute(any(WatchExecutionContext.class))).thenReturn(conditionResult);",
            "// watch level transform",
            "Transform.Result watchTransformResult = mock(Transform.Result.class);",
            "when(watchTransformResult.status()).thenReturn(Transform.Result.Status.SUCCESS);",
            "when(watchTransformResult.payload()).thenReturn(payload);",
            "ExecutableTransform watchTransform = mock(ExecutableTransform.class);",
            "when(watchTransform.execute(context, payload)).thenReturn(watchTransformResult);",
            "// action throttler",
            "Throttler.Result throttleResult = mock(Throttler.Result.class);",
            "when(throttleResult.throttle()).thenReturn(false);",
            "ActionThrottler throttler = mock(ActionThrottler.class);",
            "when(throttler.throttle(\"_action\", context)).thenReturn(throttleResult);",
            "// action level condition",
            "ExecutableCondition actionCondition = null;",
            "Condition.Result actionConditionResult = null;",
            "if (randomBoolean()) {",
            "Tuple<ExecutableCondition, Condition.Result> pair = whenCondition(context);",
            "actionCondition = pair.v1();",
            "actionConditionResult = pair.v2();",
            "}",
            "// action level transform",
            "Transform.Result actionTransformResult = mock(Transform.Result.class);",
            "when(actionTransformResult.status()).thenReturn(Transform.Result.Status.FAILURE);",
            "when(actionTransformResult.reason()).thenReturn(\"_reason\");",
            "ExecutableTransform actionTransform = mock(ExecutableTransform.class);",
            "when(actionTransform.execute(context, payload)).thenReturn(actionTransformResult);",
            "// the action",
            "Action.Result actionResult = mock(Action.Result.class);",
            "when(actionResult.type()).thenReturn(\"_action_type\");",
            "when(actionResult.status()).thenReturn(Action.Result.Status.SUCCESS);",
            "ExecutableAction action = mock(ExecutableAction.class);",
            "when(action.logger()).thenReturn(logger);",
            "when(action.execute(\"_action\", context, payload)).thenReturn(actionResult);",
            "ActionWrapper actionWrapper = new ActionWrapper(\"_action\", throttler, actionCondition, actionTransform, action, null, null);",
            "WatchStatus watchStatus = new WatchStatus(now, singletonMap(\"_action\", new ActionStatus(now)));",
            "when(watch.input()).thenReturn(input);",
            "when(watch.condition()).thenReturn(condition);",
            "when(watch.transform()).thenReturn(watchTransform);",
            "when(watch.actions()).thenReturn(Arrays.asList(actionWrapper));",
            "when(watch.status()).thenReturn(watchStatus);",
            "WatchRecord watchRecord = executionService.execute(context);",
            "assertThat(watchRecord.result().inputResult(), is(inputResult));",
            "assertThat(watchRecord.result().conditionResult(), is(conditionResult));",
            "assertThat(watchRecord.result().transformResult(), is(watchTransformResult));",
            "assertThat(watchRecord.result().actionsResults(), notNullValue());",
            "assertThat(watchRecord.result().actionsResults().size(), is(1));",
            "assertThat(watchRecord.result().actionsResults().get(\"_action\").condition(), is(actionConditionResult));",
            "assertThat(watchRecord.result().actionsResults().get(\"_action\").transform(), is(actionTransformResult));",
            "assertThat(watchRecord.result().actionsResults().get(\"_action\").action().status(), is(Action.Result.Status.FAILURE));",
            "verify(historyStore, times(1)).put(watchRecord);",
            "verify(input, times(1)).execute(context, null);",
            "verify(condition, times(1)).execute(context);",
            "verify(watchTransform, times(1)).execute(context, payload);",
            "// the action level transform is executed before the action itself",
            "verify(action, never()).execute(\"_action\", context, payload);",
            "}"
        ],
        "max_rank": -0.4226190476190189
    },
    {
        "file": "dataset/3_original.java",
        "method": "masterOperation",
        "new_method_name": "handle_config",
        "extracted_line_numbers": [
            0,
            2,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            181,
            182,
            183,
            184,
            185,
            186,
            187,
            188,
            189,
            90
        ],
        "extracted_lines": [
            "protected void masterOperation(Task task, PutTrainedModelAction.Request request, ClusterState state, ActionListener<Response> listener) {",
            "try {",
            "config.ensureParsedDefinition(xContentRegistry);",
            "}",
            "} catch (IOException ex) {",
            "listener.onFailure(ExceptionsHelper.badRequestException(\"Failed to parse definition for [{}]\", ex, config.getModelId()));",
            "return;",
            "}",
            "// NOTE: hasModelDefinition is false if we don't parse it. But, if the fully parsed model was already provided, continue",
            "boolean hasModelDefinition = config.getModelDefinition() != null;",
            "if (hasModelDefinition) {",
            "try {",
            "config.getModelDefinition().getTrainedModel().validate();",
            "} catch (ElasticsearchException ex) {",
            "listener.onFailure(",
            "ExceptionsHelper.badRequestException(\"Definition for [{}] has validation failures.\", ex, config.getModelId())",
            ");",
            "return;",
            "}",
            "TrainedModelType trainedModelType = TrainedModelType.typeFromTrainedModel(config.getModelDefinition().getTrainedModel());",
            "if (trainedModelType == null) {",
            "listener.onFailure(",
            "ExceptionsHelper.badRequestException(",
            "\"Unknown trained model definition class [{}]\",",
            "config.getModelDefinition().getTrainedModel().getName()",
            ")",
            ");",
            "return;",
            "}",
            "if (config.getModelType() == null) {",
            "// Set the model type from the definition",
            "config = new TrainedModelConfig.Builder(config).setModelType(trainedModelType).build();",
            "} else if (trainedModelType != config.getModelType()) {",
            "listener.onFailure(",
            "ExceptionsHelper.badRequestException(",
            "\"{} [{}] does not match the model definition type [{}]\",",
            "TrainedModelConfig.MODEL_TYPE.getPreferredName(),",
            "config.getModelType(),",
            "trainedModelType",
            ")",
            ");",
            "return;",
            "}",
            "if (config.getInferenceConfig().isTargetTypeSupported(config.getModelDefinition().getTrainedModel().targetType()) == false) {",
            "listener.onFailure(",
            "ExceptionsHelper.badRequestException(",
            "\"Model [{}] inference config type [{}] does not support definition target type [{}]\",",
            "config.getModelId(),",
            "config.getInferenceConfig().getName(),",
            "config.getModelDefinition().getTrainedModel().targetType()",
            ")",
            ");",
            "return;",
            "}",
            "TransportVersion minCompatibilityVersion = config.getModelDefinition().getTrainedModel().getMinimalCompatibilityVersion();",
            "listener.onFailure(",
            "ExceptionsHelper.badRequestException(",
            "\"Cannot create model [{}] while cluster upgrade is in progress.\",",
            "config.getModelId()",
            ")",
            ");",
            "return;",
            "}",
            "}",
            "TrainedModelConfig.Builder trainedModelConfig = new TrainedModelConfig.Builder(config).setVersion(MlConfigVersion.CURRENT)",
            ".setCreateTime(Instant.now())",
            ".setCreatedBy(\"api_user\")",
            ".setLicenseLevel(License.OperationMode.PLATINUM.description());",
            "AtomicReference<ModelPackageConfig> modelPackageConfigHolder = new AtomicReference<>();",
            "if (hasModelDefinition) {",
            "trainedModelConfig.setModelSize(config.getModelDefinition().ramBytesUsed())",
            ".setEstimatedOperations(config.getModelDefinition().getTrainedModel().estimatedNumOperations());",
            "} else {",
            "// Set default location for the given model type.",
            "trainedModelConfig.setLocation(",
            "Optional.ofNullable(config.getModelType()).orElse(TrainedModelType.TREE_ENSEMBLE).getDefaultLocation(config.getModelId())",
            ");",
            "}",
            "listener.onFailure(",
            "ExceptionsHelper.badRequestException(",
            "\"requested model_id [{}] is the same as an existing model_alias. Model model_aliases and ids must be unique\",",
            "config.getModelId()",
            ")",
            ");",
            "return;",
            "}",
            "listener.onFailure(",
            "ExceptionsHelper.badRequestException(",
            "\"Cannot create model [{}] the id is the same as an current model deployment\",",
            "config.getModelId()",
            ")",
            ");",
            "return;",
            "}",
            "ActionListener<Boolean> finishedStoringListener = ActionListener.wrap(bool -> {",
            "TrainedModelConfig configToReturn = trainedModelConfig.clearDefinition().build();",
            "if (modelPackageConfigHolder.get() != null) {",
            "triggerModelFetchIfNecessary(",
            "configToReturn.getModelId(),",
            "modelPackageConfigHolder.get(),",
            "request.isWaitForCompletion(),",
            "ActionListener.wrap(",
            "downloadTriggered -> listener.onResponse(new PutTrainedModelAction.Response(configToReturn)),",
            "listener::onFailure",
            ")",
            ");",
            "} else {",
            "listener.onResponse(new PutTrainedModelAction.Response(configToReturn));",
            "}",
            "}, listener::onFailure);",
            "var isPackageModel = config.isPackagedModel();",
            "ActionListener<Void> checkStorageIndexSizeListener = ActionListener.wrap(",
            "r -> trainedModelProvider.storeTrainedModel(trainedModelConfig.build(), finishedStoringListener, isPackageModel),",
            "listener::onFailure",
            ");",
            "ActionListener<Void> tagsModelIdCheckListener = ActionListener.wrap(r -> {",
            "if (TrainedModelType.PYTORCH.equals(trainedModelConfig.getModelType())) {",
            "client.admin()",
            ".indices()",
            ".prepareStats(InferenceIndexConstants.nativeDefinitionStore())",
            ".clear()",
            ".setStore(true)",
            ".execute(ActionListener.wrap(stats -> {",
            "IndexStats indexStats = stats.getIndices().get(InferenceIndexConstants.nativeDefinitionStore());",
            "if (indexStats != null",
            "&& indexStats.getTotal().getStore().getSizeInBytes() > MAX_NATIVE_DEFINITION_INDEX_SIZE.getBytes()) {",
            "listener.onFailure(",
            "new ElasticsearchStatusException(",
            "\"Native model store has exceeded the maximum acceptable size of {}, \"",
            "+ \"please delete older unused pytorch models\",",
            "RestStatus.CONFLICT,",
            "MAX_NATIVE_DEFINITION_INDEX_SIZE.toString()",
            ")",
            ");",
            "return;",
            "}",
            "checkStorageIndexSizeListener.onResponse(null);",
            "}, e -> {",
            "if (ExceptionsHelper.unwrapCause(e) instanceof ResourceNotFoundException) {",
            "checkStorageIndexSizeListener.onResponse(null);",
            "return;",
            "}",
            "listener.onFailure(",
            "new ElasticsearchStatusException(",
            "\"Unable to calculate stats for definition storage index [{}], please try again later\",",
            "RestStatus.SERVICE_UNAVAILABLE,",
            "e,",
            "InferenceIndexConstants.nativeDefinitionStore()",
            ")",
            ");",
            "}));",
            "return;",
            "}",
            "checkStorageIndexSizeListener.onResponse(null);",
            "}, listener::onFailure);",
            "ActionListener<Void> modelIdTagCheckListener = ActionListener.wrap(",
            "r -> checkTagsAgainstModelIds(request.getTrainedModelConfig().getTags(), tagsModelIdCheckListener),",
            "listener::onFailure",
            ");",
            "ActionListener<Void> handlePackageAndTagsListener = ActionListener.wrap(r -> {",
            "if (isPackageModel) {",
            "resolvePackageConfig(trainedModelConfig.getModelId(), ActionListener.wrap(resolvedModelPackageConfig -> {",
            "try {",
            "TrainedModelValidator.validatePackage(trainedModelConfig, resolvedModelPackageConfig, state);",
            "} catch (ValidationException e) {",
            "listener.onFailure(e);",
            "return;",
            "}",
            "modelPackageConfigHolder.set(resolvedModelPackageConfig);",
            "setTrainedModelConfigFieldsFromPackagedModel(trainedModelConfig, resolvedModelPackageConfig, xContentRegistry);",
            "checkModelIdAgainstTags(trainedModelConfig.getModelId(), modelIdTagCheckListener);",
            "}, listener::onFailure));",
            "} else {",
            "checkModelIdAgainstTags(trainedModelConfig.getModelId(), modelIdTagCheckListener);",
            "}",
            "}, listener::onFailure);",
            "checkForExistingTask(",
            "client,",
            "trainedModelConfig.getModelId(),",
            "request.isWaitForCompletion(),",
            "listener,",
            "handlePackageAndTagsListener,",
            "request.timeout()",
            ");",
            "}",
            "if (TrainedModelAssignmentMetadata.fromState(state).hasDeployment(trainedModelConfig.getModelId())) {"
        ],
        "max_rank": -0.4433326345618054
    },
    {
        "file": "dataset/4_original.java",
        "method": "testValidateSearchContext",
        "new_method_name": "handle_IndicesAccessControl",
        "extracted_line_numbers": [
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135
        ],
        "extracted_lines": [
            ") {",
            "readerContext.putInContext(",
            "AuthenticationField.AUTHENTICATION_KEY,",
            "AuthenticationTestHelper.builder()",
            ".user(new User(\"test\", \"role\"))",
            ".realmRef(new RealmRef(\"realm\", \"file\", \"node\"))",
            ".build(false)",
            ");",
            "final IndicesAccessControl indicesAccessControl = mock(IndicesAccessControl.class);",
            "readerContext.putInContext(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, indicesAccessControl);",
            "MockLicenseState licenseState = mock(MockLicenseState.class);",
            "when(licenseState.isAllowed(Security.AUDITING_FEATURE)).thenReturn(true);",
            "ThreadContext threadContext = new ThreadContext(Settings.EMPTY);",
            "final SecurityContext securityContext = new SecurityContext(Settings.EMPTY, threadContext);",
            "AuditTrail auditTrail = mock(AuditTrail.class);",
            "AuditTrailService auditTrailService = new AuditTrailService(auditTrail, licenseState);",
            "SecuritySearchOperationListener listener = new SecuritySearchOperationListener(securityContext, auditTrailService);",
            "try (StoredContext ignore = threadContext.newStoredContext()) {",
            "Authentication authentication = AuthenticationTestHelper.builder()",
            ".user(new User(\"test\", \"role\"))",
            ".realmRef(new RealmRef(\"realm\", \"file\", \"node\"))",
            ".build(false);",
            "authentication.writeToContext(threadContext);",
            "listener.validateReaderContext(readerContext, Empty.INSTANCE);",
            "assertThat(threadContext.getTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY), is(indicesAccessControl));",
            "verifyNoMoreInteractions(auditTrail);",
            "}",
            "try (StoredContext ignore = threadContext.newStoredContext()) {",
            "final String nodeName = randomAlphaOfLengthBetween(1, 8);",
            "final String realmName = randomAlphaOfLengthBetween(1, 16);",
            "Authentication authentication = AuthenticationTestHelper.builder()",
            ".user(new User(\"test\", \"role\"))",
            ".realmRef(new RealmRef(realmName, \"file\", nodeName))",
            ".build(false);",
            "authentication.writeToContext(threadContext);",
            "listener.validateReaderContext(readerContext, Empty.INSTANCE);",
            "assertThat(threadContext.getTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY), is(indicesAccessControl));",
            "verifyNoMoreInteractions(auditTrail);",
            "}",
            "try (StoredContext ignore = threadContext.newStoredContext()) {",
            "final String nodeName = randomBoolean() ? \"node\" : randomAlphaOfLengthBetween(1, 8);",
            "final String realmName = randomBoolean() ? \"realm\" : randomAlphaOfLengthBetween(1, 16);",
            "final String type = randomAlphaOfLengthBetween(5, 16);",
            "Authentication authentication = AuthenticationTestHelper.builder()",
            ".user(new User(\"test\", \"role\"))",
            ".realmRef(new RealmRef(realmName, type, nodeName))",
            ".build(false);",
            "authentication.writeToContext(threadContext);",
            "threadContext.putTransient(ORIGINATING_ACTION_KEY, \"action\");",
            "threadContext.putTransient(",
            "AUTHORIZATION_INFO_KEY,",
            "(AuthorizationInfo) () -> Collections.singletonMap(",
            "PRINCIPAL_ROLES_FIELD_NAME,",
            "authentication.getEffectiveSubject().getUser().roles()",
            ")",
            ");",
            "final InternalScrollSearchRequest request = new InternalScrollSearchRequest();",
            "SearchContextMissingException expected = expectThrows(",
            "SearchContextMissingException.class,",
            "() -> listener.validateReaderContext(readerContext, request)",
            ");",
            "assertEquals(readerContext.id(), expected.contextId());",
            "assertThat(threadContext.getTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY), nullValue());",
            "verify(auditTrail).accessDenied(",
            "eq(null),",
            "eq(authentication),",
            "eq(\"action\"),",
            "eq(request),",
            "authzInfoRoles(authentication.getEffectiveSubject().getUser().roles())",
            ");",
            "}",
            "// another user running as the original user",
            "try (StoredContext ignore = threadContext.newStoredContext()) {",
            "final String nodeName = randomBoolean() ? \"node\" : randomAlphaOfLengthBetween(1, 8);",
            "final String realmName = randomBoolean() ? \"realm\" : randomAlphaOfLengthBetween(1, 16);",
            "final String type = randomAlphaOfLengthBetween(5, 16);",
            "Authentication authentication = AuthenticationTestHelper.builder()",
            ".user(new User(\"authenticated\", \"runas\"))",
            ".realmRef(new RealmRef(realmName, type, nodeName))",
            ".runAs()",
            ".user(new User(\"test\", \"role\"))",
            ".realmRef(new RealmRef(randomAlphaOfLengthBetween(1, 16), \"file\", nodeName))",
            ".build();",
            "authentication.writeToContext(threadContext);",
            "threadContext.putTransient(ORIGINATING_ACTION_KEY, \"action\");",
            "final InternalScrollSearchRequest request = new InternalScrollSearchRequest();",
            "listener.validateReaderContext(readerContext, request);",
            "assertThat(threadContext.getTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY), is(indicesAccessControl));",
            "verifyNoMoreInteractions(auditTrail);",
            "}",
            "// the user that authenticated for the run as request",
            "try (StoredContext ignore = threadContext.newStoredContext()) {",
            "final String nodeName = randomBoolean() ? \"node\" : randomAlphaOfLengthBetween(1, 8);",
            "final String realmName = randomBoolean() ? \"realm\" : randomAlphaOfLengthBetween(1, 16);",
            "final String type = randomAlphaOfLengthBetween(5, 16);",
            "Authentication authentication = AuthenticationTestHelper.builder()",
            ".user(new User(\"authenticated\", \"runas\"))",
            ".realmRef(new RealmRef(realmName, type, nodeName))",
            ".build(false);",
            "authentication.writeToContext(threadContext);",
            "threadContext.putTransient(ORIGINATING_ACTION_KEY, \"action\");",
            "threadContext.putTransient(",
            "AUTHORIZATION_INFO_KEY,",
            "(AuthorizationInfo) () -> Collections.singletonMap(",
            "PRINCIPAL_ROLES_FIELD_NAME,",
            "authentication.getEffectiveSubject().getUser().roles()",
            ")",
            ");",
            "final InternalScrollSearchRequest request = new InternalScrollSearchRequest();",
            "SearchContextMissingException expected = expectThrows(",
            "SearchContextMissingException.class,",
            "() -> listener.validateReaderContext(readerContext, request)",
            ");",
            "assertEquals(readerContext.id(), expected.contextId());",
            "assertThat(threadContext.getTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY), nullValue());",
            "verify(auditTrail).accessDenied(",
            "eq(null),",
            "eq(authentication),",
            "eq(\"action\"),",
            "eq(request),",
            "authzInfoRoles(authentication.getEffectiveSubject().getUser().roles())",
            ");",
            "}",
            "}"
        ],
        "max_rank": -0.1354567462756731
    },
    {
        "file": "dataset/5_original.java",
        "method": "testBuildTable",
        "new_method_name": "handle_randomIntBetween",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103
        ],
        "extracted_lines": [
            "public void testBuildTable() {",
            "final int numIndices = randomIntBetween(3, 20);",
            "final Map<String, Settings> indicesSettings = new LinkedHashMap<>();",
            "final Map<String, IndexStats> indicesStats = new HashMap<>();",
            "final Metadata.Builder metadata = Metadata.builder();",
            "final RoutingTable.Builder routingTable = RoutingTable.builder();",
            "for (int i = 0; i < numIndices; i++) {",
            "String indexName = \"index-\" + i;",
            "Settings indexSettings = Settings.builder()",
            ".put(IndexMetadata.SETTING_VERSION_CREATED, IndexVersion.current())",
            ".put(IndexMetadata.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())",
            ".put(IndexSettings.INDEX_SEARCH_THROTTLED.getKey(), randomBoolean())",
            ".build();",
            "indicesSettings.put(indexName, indexSettings);",
            "IndexMetadata.State indexState = randomBoolean() ? IndexMetadata.State.OPEN : IndexMetadata.State.CLOSE;",
            "if (frequently()) {",
            "ClusterHealthStatus healthStatus = randomFrom(ClusterHealthStatus.values());",
            "int numberOfShards = randomIntBetween(1, 3);",
            "int numberOfReplicas = healthStatus == ClusterHealthStatus.YELLOW ? 1 : randomInt(1);",
            "IndexMetadata indexMetadata = IndexMetadata.builder(indexName)",
            ".settings(indexSettings)",
            ".creationDate(System.currentTimeMillis())",
            ".numberOfShards(numberOfShards)",
            ".numberOfReplicas(numberOfReplicas)",
            ".state(indexState)",
            ".build();",
            "metadata.put(indexMetadata, false);",
            "if (frequently()) {",
            "Index index = indexMetadata.getIndex();",
            "IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(index);",
            "switch (randomFrom(ClusterHealthStatus.values())) {",
            "case GREEN:",
            "IntStream.range(0, numberOfShards)",
            ".mapToObj(n -> new ShardId(index, n))",
            ".map(shardId -> TestShardRouting.newShardRouting(shardId, \"nodeA\", true, ShardRoutingState.STARTED))",
            ".forEach(indexRoutingTable::addShard);",
            "if (numberOfReplicas > 0) {",
            "IntStream.range(0, numberOfShards)",
            ".mapToObj(n -> new ShardId(index, n))",
            ".map(shardId -> TestShardRouting.newShardRouting(shardId, \"nodeB\", false, ShardRoutingState.STARTED))",
            ".forEach(indexRoutingTable::addShard);",
            "}",
            "break;",
            "case YELLOW:",
            "IntStream.range(0, numberOfShards)",
            ".mapToObj(n -> new ShardId(index, n))",
            ".map(shardId -> TestShardRouting.newShardRouting(shardId, \"nodeA\", true, ShardRoutingState.STARTED))",
            ".forEach(indexRoutingTable::addShard);",
            "if (numberOfReplicas > 0) {",
            "IntStream.range(0, numberOfShards)",
            ".mapToObj(n -> new ShardId(index, n))",
            ".map(shardId -> TestShardRouting.newShardRouting(shardId, null, false, ShardRoutingState.UNASSIGNED))",
            ".forEach(indexRoutingTable::addShard);",
            "}",
            "break;",
            "case RED:",
            "break;",
            "}",
            "routingTable.add(indexRoutingTable);",
            "if (frequently()) {",
            "IndexStats indexStats = mock(IndexStats.class);",
            "when(indexStats.getPrimaries()).thenReturn(new CommonStats());",
            "when(indexStats.getTotal()).thenReturn(new CommonStats());",
            "indicesStats.put(indexName, indexStats);",
            "}",
            "}",
            "}",
            "}",
            "final ClusterState clusterState = ClusterState.builder(ClusterState.EMPTY_STATE)",
            ".metadata(metadata)",
            ".routingTable(randomBoolean() ? routingTable : RoutingTable.builder())",
            ".build();",
            "final RestIndicesAction action = new RestIndicesAction();",
            "final Table table = action.buildTable(new FakeRestRequest(), indicesSettings, clusterState, indicesStats);",
            "// now, verify the table is correct",
            "List<Table.Cell> headers = table.getHeaders();",
            "assertThat(headers.get(0).value, equalTo(\"health\"));",
            "assertThat(headers.get(1).value, equalTo(\"status\"));",
            "assertThat(headers.get(2).value, equalTo(\"index\"));",
            "assertThat(headers.get(3).value, equalTo(\"uuid\"));",
            "assertThat(headers.get(4).value, equalTo(\"pri\"));",
            "assertThat(headers.get(5).value, equalTo(\"rep\"));",
            "final List<List<Table.Cell>> rows = table.getRows();",
            "assertThat(rows.size(), equalTo(clusterState.metadata().indices().size()));",
            "final var clusterStateHealth = new ClusterStateHealth(clusterState);",
            "for (final List<Table.Cell> row : rows) {",
            "final String indexName = (String) row.get(2).value;",
            "ClusterIndexHealth indexHealth = clusterStateHealth.getIndices().get(indexName);",
            "IndexStats indexStats = indicesStats.get(indexName);",
            "IndexMetadata indexMetadata = clusterState.metadata().index(indexName);",
            "if (indexHealth != null) {",
            "assertThat(row.get(0).value, equalTo(indexHealth.getStatus().toString().toLowerCase(Locale.ROOT)));",
            "} else if (indexStats != null) {",
            "assertThat(row.get(0).value, equalTo(\"red*\"));",
            "} else {",
            "assertThat(row.get(0).value, equalTo(\"\"));",
            "}",
            "assertThat(row.get(1).value, equalTo(indexMetadata.getState().toString().toLowerCase(Locale.ROOT)));",
            "assertThat(row.get(2).value, equalTo(indexName));",
            "assertThat(row.get(3).value, equalTo(indexMetadata.getIndexUUID()));",
            "assertThat(row.get(4).value, equalTo(indexMetadata.getNumberOfShards()));",
            "assertThat(row.get(5).value, equalTo(indexMetadata.getNumberOfReplicas()));",
            "}",
            "}"
        ],
        "max_rank": -0.4760479041916067
    },
    {
        "file": "dataset/6_original.java",
        "method": "testFromXContent",
        "new_method_name": "handle_new",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158
        ],
        "extracted_lines": [
            "public void testFromXContent() throws Exception {",
            "UpdateRequest request = new UpdateRequest(\"test\", \"1\");",
            "// simple script",
            "request.fromXContent(createParser(XContentFactory.jsonBuilder().startObject().field(\"script\", \"script1\").endObject()));",
            "Script script = request.script();",
            "assertThat(script, notNullValue());",
            "assertThat(script.getIdOrCode(), equalTo(\"script1\"));",
            "assertThat(script.getType(), equalTo(ScriptType.INLINE));",
            "assertThat(script.getLang(), equalTo(Script.DEFAULT_SCRIPT_LANG));",
            "Map<String, Object> params = script.getParams();",
            "assertThat(params, equalTo(emptyMap()));",
            "// simple verbose script",
            "request.fromXContent(",
            "createParser(",
            "XContentFactory.jsonBuilder().startObject().startObject(\"script\").field(\"source\", \"script1\").endObject().endObject()",
            ")",
            ");",
            "script = request.script();",
            "assertThat(script, notNullValue());",
            "assertThat(script.getIdOrCode(), equalTo(\"script1\"));",
            "assertThat(script.getType(), equalTo(ScriptType.INLINE));",
            "assertThat(script.getLang(), equalTo(Script.DEFAULT_SCRIPT_LANG));",
            "params = script.getParams();",
            "assertThat(params, equalTo(emptyMap()));",
            "// script with params",
            "request = new UpdateRequest(\"test\", \"1\");",
            "request.fromXContent(",
            "createParser(",
            "XContentFactory.jsonBuilder()",
            ".startObject()",
            ".startObject(\"script\")",
            ".field(\"source\", \"script1\")",
            ".startObject(\"params\")",
            ".field(\"param1\", \"value1\")",
            ".endObject()",
            ".endObject()",
            ".endObject()",
            ")",
            ");",
            "script = request.script();",
            "assertThat(script, notNullValue());",
            "assertThat(script.getIdOrCode(), equalTo(\"script1\"));",
            "assertThat(script.getType(), equalTo(ScriptType.INLINE));",
            "assertThat(script.getLang(), equalTo(Script.DEFAULT_SCRIPT_LANG));",
            "params = script.getParams();",
            "assertThat(params, notNullValue());",
            "assertThat(params.size(), equalTo(1));",
            "assertThat(params.get(\"param1\").toString(), equalTo(\"value1\"));",
            "request = new UpdateRequest(\"test\", \"1\");",
            "request.fromXContent(",
            "createParser(",
            "XContentFactory.jsonBuilder()",
            ".startObject()",
            ".startObject(\"script\")",
            ".startObject(\"params\")",
            ".field(\"param1\", \"value1\")",
            ".endObject()",
            ".field(\"source\", \"script1\")",
            ".endObject()",
            ".endObject()",
            ")",
            ");",
            "script = request.script();",
            "assertThat(script, notNullValue());",
            "assertThat(script.getIdOrCode(), equalTo(\"script1\"));",
            "assertThat(script.getType(), equalTo(ScriptType.INLINE));",
            "assertThat(script.getLang(), equalTo(Script.DEFAULT_SCRIPT_LANG));",
            "params = script.getParams();",
            "assertThat(params, notNullValue());",
            "assertThat(params.size(), equalTo(1));",
            "assertThat(params.get(\"param1\").toString(), equalTo(\"value1\"));",
            "// script with params and upsert",
            "request = new UpdateRequest(\"test\", \"1\");",
            "request.fromXContent(",
            "createParser(",
            "XContentFactory.jsonBuilder()",
            ".startObject()",
            ".startObject(\"script\")",
            ".startObject(\"params\")",
            ".field(\"param1\", \"value1\")",
            ".endObject()",
            ".field(\"source\", \"script1\")",
            ".endObject()",
            ".startObject(\"upsert\")",
            ".field(\"field1\", \"value1\")",
            ".startObject(\"compound\")",
            ".field(\"field2\", \"value2\")",
            ".endObject()",
            ".endObject()",
            ".endObject()",
            ")",
            ");",
            "script = request.script();",
            "assertThat(script, notNullValue());",
            "assertThat(script.getIdOrCode(), equalTo(\"script1\"));",
            "assertThat(script.getType(), equalTo(ScriptType.INLINE));",
            "assertThat(script.getLang(), equalTo(Script.DEFAULT_SCRIPT_LANG));",
            "params = script.getParams();",
            "assertThat(params, notNullValue());",
            "assertThat(params.size(), equalTo(1));",
            "assertThat(params.get(\"param1\").toString(), equalTo(\"value1\"));",
            "Map<String, Object> upsertDoc = XContentHelper.convertToMap(",
            "request.upsertRequest().source(),",
            "true,",
            "request.upsertRequest().getContentType()",
            ").v2();",
            "assertThat(upsertDoc.get(\"field1\").toString(), equalTo(\"value1\"));",
            "assertThat(((Map<String, Object>) upsertDoc.get(\"compound\")).get(\"field2\").toString(), equalTo(\"value2\"));",
            "request = new UpdateRequest(\"test\", \"1\");",
            "request.fromXContent(",
            "createParser(",
            "XContentFactory.jsonBuilder()",
            ".startObject()",
            ".startObject(\"upsert\")",
            ".field(\"field1\", \"value1\")",
            ".startObject(\"compound\")",
            ".field(\"field2\", \"value2\")",
            ".endObject()",
            ".endObject()",
            ".startObject(\"script\")",
            ".startObject(\"params\")",
            ".field(\"param1\", \"value1\")",
            ".endObject()",
            ".field(\"source\", \"script1\")",
            ".endObject()",
            ".endObject()",
            ")",
            ");",
            "script = request.script();",
            "assertThat(script, notNullValue());",
            "assertThat(script.getIdOrCode(), equalTo(\"script1\"));",
            "assertThat(script.getType(), equalTo(ScriptType.INLINE));",
            "assertThat(script.getLang(), equalTo(Script.DEFAULT_SCRIPT_LANG));",
            "params = script.getParams();",
            "assertThat(params, notNullValue());",
            "assertThat(params.size(), equalTo(1));",
            "assertThat(params.get(\"param1\").toString(), equalTo(\"value1\"));",
            "upsertDoc = XContentHelper.convertToMap(request.upsertRequest().source(), true, request.upsertRequest().getContentType()).v2();",
            "assertThat(upsertDoc.get(\"field1\").toString(), equalTo(\"value1\"));",
            "assertThat(((Map<String, Object>) upsertDoc.get(\"compound\")).get(\"field2\").toString(), equalTo(\"value2\"));",
            "// script with doc",
            "request = new UpdateRequest(\"test\", \"1\");",
            "request.fromXContent(",
            "createParser(",
            "XContentFactory.jsonBuilder()",
            ".startObject()",
            ".startObject(\"doc\")",
            ".field(\"field1\", \"value1\")",
            ".startObject(\"compound\")",
            ".field(\"field2\", \"value2\")",
            ".endObject()",
            ".endObject()",
            ".endObject()",
            ")",
            ");",
            "Map<String, Object> doc = request.doc().sourceAsMap();",
            "assertThat(doc.get(\"field1\").toString(), equalTo(\"value1\"));",
            "assertThat(((Map<String, Object>) doc.get(\"compound\")).get(\"field2\").toString(), equalTo(\"value2\"));",
            "}"
        ],
        "max_rank": -0.4593023255810816
    },
    {
        "file": "dataset/7_original.java",
        "method": "testAllocationFilteringPreventsShardMove",
        "new_method_name": "handle_randomBoolean",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98
        ],
        "extracted_lines": [
            "public void testAllocationFilteringPreventsShardMove() throws Exception {",
            "logger.info(\"--> starting 2 nodes\");",
            "internalCluster().startNodes(2);",
            "prepareIndex(1, 0);",
            "logger.info(\"--> setting up allocation filtering to prevent allocation to both nodes\");",
            "updateIndexSettings(Settings.builder().put(\"index.routing.allocation.include._name\", \"non_existent_node\"), \"idx\");",
            "boolean includeYesDecisions = randomBoolean();",
            "boolean includeDiskInfo = randomBoolean();",
            "ClusterAllocationExplanation explanation = runExplain(true, includeYesDecisions, includeDiskInfo);",
            "ShardId shardId = explanation.getShard();",
            "boolean isPrimary = explanation.isPrimary();",
            "ShardRoutingState shardRoutingState = explanation.getShardState();",
            "DiscoveryNode currentNode = explanation.getCurrentNode();",
            "UnassignedInfo unassignedInfo = explanation.getUnassignedInfo();",
            "ClusterInfo clusterInfo = explanation.getClusterInfo();",
            "AllocateUnassignedDecision allocateDecision = explanation.getShardAllocationDecision().getAllocateDecision();",
            "MoveDecision moveDecision = explanation.getShardAllocationDecision().getMoveDecision();",
            "// verify shard info",
            "assertEquals(\"idx\", shardId.getIndexName());",
            "assertEquals(0, shardId.getId());",
            "assertTrue(isPrimary);",
            "// verify current node info",
            "assertEquals(ShardRoutingState.STARTED, shardRoutingState);",
            "assertNotNull(currentNode);",
            "// verify unassigned info",
            "assertNull(unassignedInfo);",
            "// verify cluster info",
            "verifyClusterInfo(clusterInfo, includeDiskInfo, 2);",
            "// verify decision object",
            "assertFalse(allocateDecision.isDecisionTaken());",
            "assertTrue(moveDecision.isDecisionTaken());",
            "assertEquals(AllocationDecision.NO, moveDecision.getAllocationDecision());",
            "assertEquals(Explanations.Move.NO, moveDecision.getExplanation());",
            "assertFalse(moveDecision.canRemain());",
            "assertFalse(moveDecision.forceMove());",
            "assertFalse(moveDecision.canRebalanceCluster());",
            "assertNull(moveDecision.getClusterRebalanceDecision());",
            "assertNull(moveDecision.getTargetNode());",
            "assertEquals(0, moveDecision.getCurrentNodeRanking());",
            "// verifying can remain decision object",
            "assertNotNull(moveDecision.getCanRemainDecision());",
            "assertEquals(Decision.Type.NO, moveDecision.getCanRemainDecision().type());",
            "for (Decision d : moveDecision.getCanRemainDecision().getDecisions()) {",
            "if (d.label().equals(\"filter\")) {",
            "assertEquals(Decision.Type.NO, d.type());",
            "assertEquals(",
            "\"node does not match index setting [index.routing.allocation.include] filters [_name:\\\"non_existent_node\\\"]\",",
            "d.getExplanation()",
            ");",
            "} else {",
            "assertEquals(Decision.Type.YES, d.type());",
            "assertNotNull(d.getExplanation());",
            "}",
            "}",
            "// verify node decisions",
            "assertEquals(1, moveDecision.getNodeDecisions().size());",
            "NodeAllocationResult result = moveDecision.getNodeDecisions().get(0);",
            "assertNotNull(result.getNode());",
            "assertEquals(1, result.getWeightRanking());",
            "assertEquals(AllocationDecision.NO, result.getNodeDecision());",
            "if (includeYesDecisions) {",
            "assertThat(result.getCanAllocateDecision().getDecisions().size(), greaterThan(1));",
            "} else {",
            "assertEquals(1, result.getCanAllocateDecision().getDecisions().size());",
            "}",
            "for (Decision d : result.getCanAllocateDecision().getDecisions()) {",
            "if (d.label().equals(\"filter\")) {",
            "assertEquals(Decision.Type.NO, d.type());",
            "assertEquals(",
            "\"node does not match index setting [index.routing.allocation.include] filters [_name:\\\"non_existent_node\\\"]\",",
            "d.getExplanation()",
            ");",
            "} else {",
            "assertEquals(Decision.Type.YES, d.type());",
            "assertNotNull(d.getExplanation());",
            "}",
            "}",
            "// verify JSON output",
            "try (XContentParser parser = getParser(explanation)) {",
            "verifyShardInfo(parser, true, includeDiskInfo, ShardRoutingState.STARTED);",
            "parser.nextToken();",
            "assertEquals(\"can_remain_on_current_node\", parser.currentName());",
            "parser.nextToken();",
            "assertEquals(AllocationDecision.NO.toString(), parser.text());",
            "parser.nextToken();",
            "assertEquals(\"can_remain_decisions\", parser.currentName());",
            "verifyDeciders(parser, AllocationDecision.NO);",
            "parser.nextToken();",
            "assertEquals(\"can_move_to_other_node\", parser.currentName());",
            "parser.nextToken();",
            "assertEquals(AllocationDecision.NO.toString(), parser.text());",
            "parser.nextToken();",
            "assertEquals(\"move_explanation\", parser.currentName());",
            "parser.nextToken();",
            "assertEquals(Explanations.Move.NO, parser.text());",
            "verifyNodeDecisions(parser, allNodeDecisions(AllocationDecision.NO, true), includeYesDecisions, false);",
            "assertEquals(Token.END_OBJECT, parser.nextToken());",
            "}",
            "}"
        ],
        "max_rank": -0.46531791907508263
    },
    {
        "file": "dataset/8_original.java",
        "method": "testAutoscalingCapacity",
        "new_method_name": "handle_ByteSizeValue",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            181,
            182,
            183,
            184,
            185,
            186,
            187,
            188,
            189,
            190,
            191,
            192,
            193,
            194,
            195,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            210,
            211,
            212,
            213,
            214,
            215,
            216,
            217,
            218,
            219,
            220,
            221,
            222,
            223,
            224,
            225,
            226,
            227,
            228,
            229,
            230,
            231,
            232,
            233,
            234,
            235,
            236,
            237,
            238,
            239,
            240,
            241,
            242,
            243,
            244,
            245,
            246,
            247,
            248,
            249,
            250,
            251,
            252,
            253,
            254,
            255,
            256,
            257,
            258,
            259,
            260,
            261,
            262,
            263,
            264,
            265,
            266,
            267,
            268,
            269,
            270,
            271,
            272,
            273,
            274,
            275,
            276,
            277,
            278,
            279,
            280,
            281,
            282,
            283,
            284,
            285,
            286,
            287,
            288,
            289,
            290,
            291,
            292,
            293,
            294,
            295,
            296,
            297,
            298,
            299,
            300,
            301,
            302,
            303,
            304,
            305,
            306,
            307,
            308,
            309,
            310,
            311,
            312,
            313,
            314,
            315,
            316,
            317,
            318,
            319,
            320,
            321,
            322,
            323,
            324,
            325,
            326,
            327,
            328,
            329,
            330,
            331,
            332,
            333,
            334,
            335,
            336,
            337,
            338,
            339,
            340,
            341,
            342,
            343,
            344,
            345,
            346,
            347,
            348,
            349,
            350,
            351,
            352,
            353,
            354,
            355,
            356,
            357,
            358,
            359,
            360,
            361,
            362,
            363,
            364,
            365,
            366,
            367,
            368,
            369,
            370,
            371,
            372,
            373,
            374,
            375,
            376,
            377,
            378,
            379,
            380,
            381,
            382,
            383,
            384,
            385,
            386,
            387,
            388,
            389,
            390,
            391,
            392,
            393,
            394,
            395,
            396,
            397,
            398,
            399,
            400,
            401,
            402,
            403,
            404,
            405,
            406,
            407,
            408,
            409,
            410,
            411,
            412,
            413,
            414,
            415,
            416,
            417,
            418,
            419,
            420,
            421,
            422,
            423,
            424,
            425,
            426,
            427,
            428,
            429,
            430,
            431,
            432,
            433,
            434,
            435,
            436,
            437,
            438,
            439,
            440,
            441,
            442,
            443,
            444,
            445,
            446,
            447
        ],
        "extracted_lines": [
            "public void testAutoscalingCapacity() {",
            "final long BYTES_IN_64GB = ByteSizeValue.ofGb(64).getBytes();",
            "final long AUTO_ML_MEMORY_FOR_64GB_NODE = NativeMemoryCalculator.allowedBytesForMl(BYTES_IN_64GB, randomIntBetween(5, 90), true);",
            "NativeMemoryCapacity capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(4).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(1).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofMb(50).getBytes()",
            ");",
            "// auto is false (which should not be when autoscaling is used as intended)",
            "{",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "25,",
            "false,",
            "NativeMemoryCalculator.allowedBytesForMl(BYTES_IN_64GB, 25, false),",
            "1",
            ").build();",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(ByteSizeValue.ofGb(1).getBytes() * 4L));",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(ByteSizeValue.ofGb(4).getBytes() * 4L));",
            "}",
            "// auto is true (so configured max memory percent should be ignored)",
            "{",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "1",
            ").build();",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(1335885824L));",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(4557111296L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement below JVM size knot point, 1 AZ (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(4).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(1).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "1",
            ").build();",
            "// 2134900736 bytes = 2036MB",
            "// 2036MB node => 812MB JVM heap (40% of 2036MB rounded down to a multiple of 4MB)",
            "// 2036MB - 812MB - 200MB = 1024MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(2134900736L));",
            "// 7503609856 bytes = 7156MB",
            "// 7156MB node => 2860MB JVM heap (40% of 7156MB rounded down to a multiple of 4MB)",
            "// 7156MB - 2860MB - 200MB = 4096MB which is what we asked for for the tier",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(7503609856L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement below JVM size knot point, 2 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(4).getBytes() - 2 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(1).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "2",
            ").build();",
            "// 2134900736 bytes = 2036MB",
            "// 2036MB node => 812MB JVM heap (40% of 2036MB rounded down to a multiple of 4MB)",
            "// 2036MB - 812MB - 200MB = 1024MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(2134900736L));",
            "// 7851737088 bytes = 7488MB",
            "// We expect to be given 2 nodes as there are 2 AZs, so each will be 3744MB",
            "// 3744MB node => 1496MB JVM heap (40% of 3744MB rounded down to a multiple of 4MB)",
            "// 3744MB - 1496MB - 200MB = 2048MB which is half of what we asked for for the tier",
            "// So with 2 nodes of this size we'll have the requested amount",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(7851737088L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement below JVM size knot point, 3 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(4).getBytes() - 3 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(1).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "3",
            ").build();",
            "// 2134900736 bytes = 2036MB",
            "// 2036MB node => 812MB JVM heap (40% of 2036MB rounded down to a multiple of 4MB)",
            "// 2036MB - 812MB - 200MB = 1024MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(2134900736L));",
            "// 8195670018 bytes = 7816MB + 2 bytes",
            "// We expect to be given 3 nodes as there are 3 AZs, so each will be 2605 1/3MB",
            "// 2605 1/3MB node => 1040MB JVM heap (40% of 2605 1/3MB rounded down to a multiple of 4MB)",
            "// 2605 1/3MB - 1040MB - 200MB = 1365 1/3MB which is one third of what we asked for for the tier",
            "// So with 3 nodes of this size we'll have the requested amount",
            "// (The 2 byte discrepancy comes from the fact there are 3 nodes and 3 didn't divide exactly into the amount",
            "// of memory we needed, so each node gets a fraction of a byte extra to take it up to a whole number size)",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(8195670018L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement below JVM size knot point, 1 AZ (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(4).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(3).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "1",
            ").build();",
            "// 5712642048 bytes = 5448MB",
            "// 5448MB node => 2176MB JVM heap (40% of 5448MB rounded down to a multiple of 4MB)",
            "// 5448MB - 2176MB - 200MB = 3072MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(5712642048L));",
            "// 7503609856 bytes = 7156MB",
            "// 7156MB node => 2860MB JVM heap (40% of 7156MB rounded down to a multiple of 4MB)",
            "// 7156MB - 2860MB - 200MB = 4096MB which is what we asked for for the tier",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(7503609856L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement below JVM size knot point, 2 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(4).getBytes() - 2 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(3).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "2",
            ").build();",
            "// 5712642048 bytes = 5448MB",
            "// 5448MB node => 2176MB JVM heap (40% of 5448MB rounded down to a multiple of 4MB)",
            "// 5448MB - 2176MB - 200MB = 3072MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(5712642048L));",
            "// 7851737088 bytes = 7488MB",
            "// We expect to be given 2 nodes as there are 2 AZs, so each will be 3744MB",
            "// 3744MB node => 1496MB JVM heap (40% of 3744MB rounded down to a multiple of 4MB)",
            "// 3744MB - 1496MB - 200MB = 2048MB which is half of what we asked for for the tier",
            "// So with 2 nodes of this size we'll have the requested amount",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(7851737088L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement below JVM size knot point, 3 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(4).getBytes() - 3 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(3).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "3",
            ").build();",
            "// 5712642048 bytes = 5448MB",
            "// 5448MB node => 2176MB JVM heap (40% of 5448MB rounded down to a multiple of 4MB)",
            "// 5448MB - 2176MB - 200MB = 3072MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(5712642048L));",
            "// 8195670018 bytes = 7816MB + 2 bytes",
            "// We expect to be given 3 nodes as there are 3 AZs, so each will be 2605 1/3MB",
            "// 2605 1/3MB node => 1040MB JVM heap (40% of 2605 1/3MB rounded down to a multiple of 4MB)",
            "// 2605 1/3MB - 1040MB - 200MB = 1365 1/3MB which is one third of what we asked for for the tier",
            "// So with 3 nodes of this size we'll have the requested amount",
            "// (The 2 byte discrepancy comes from the fact there are 3 nodes and 3 didn't divide exactly into the amount",
            "// of memory we needed, so each node gets a fraction of a byte extra to take it up to a whole number size)",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(8195670018L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above JVM size knot point, 1 AZ (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(30).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(5).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "1",
            ").build();",
            "// 9294577664 bytes = 8864MB",
            "// 8864MB node => 3544MB JVM heap (40% of 8864MB rounded down to a multiple of 4MB)",
            "// 8864MB - 3544MB - 200MB = 5120MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(9294577664L));",
            "// 41750102016 bytes = 39816MB",
            "// 39816MB node => 8896MB JVM heap (40% of 16384MB + 10% of 23432MB rounded down to a multiple of 4MB)",
            "// 39816MB - 8896MB - 200MB = 30720MB which is what we asked for for the tier",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(41750102016L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above JVM size knot point, 2 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(30).getBytes() - 2 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(5).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "2",
            ").build();",
            "// 9294577664 bytes = 8864MB",
            "// 8864MB node => 3544MB JVM heap (40% of 8864MB rounded down to a multiple of 4MB)",
            "// 8864MB - 3544MB - 200MB = 5120MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(9294577664L));",
            "// 47706013696 bytes = 45496MB",
            "// We expect to be given 2 nodes as there are 2 AZs, so each will be 22748MB",
            "// 22748MB node => 7188MB JVM heap (40% of 16384MB + 10% of 6364MB rounded down to a multiple of 4MB)",
            "// 22748MB - 7188MB - 200MB = 15360MB which is half of what we asked for for the tier",
            "// So with 2 nodes of this size we'll have the requested amount",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(47706013696L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above JVM size knot point, 3 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(30).getBytes() - 3 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(5).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "3",
            ").build();",
            "// 9294577664 bytes = 8864MB",
            "// 8864MB node => 3544MB JVM heap (40% of 8864MB rounded down to a multiple of 4MB)",
            "// 8864MB - 3544MB - 200MB = 5120MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(9294577664L));",
            "// 53666119680 bytes = 51180MB",
            "// We expect to be given 3 nodes as there are 3 AZs, so each will be 17060MB",
            "// 17060MB node => 6620MB JVM heap (40% of 16384MB + 10% of 676MB rounded down to a multiple of 4MB)",
            "// 17060MB - 6620MB - 200MB = 10240MB which is one third of what we asked for for the tier",
            "// So with 3 nodes of this size we'll have the requested amount",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(53666119680L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above JVM size knot point, 1 AZ (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(30).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(20).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "1",
            ").build();",
            "// 29817307136 bytes = 28436MB",
            "// 28436MB node => 7756MB JVM heap (40% of 16384MB + 10% of 12052MB rounded down to a multiple of 4MB)",
            "// 28436MB - 7756MB - 200MB = 20480MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(29817307136L));",
            "// 41750102016 bytes = 39816MB",
            "// 39816MB node => 8896MB JVM heap (40% of 16384MB + 10% of 23432MB rounded down to a multiple of 4MB)",
            "// 39816MB - 8896MB - 200MB = 30720MB which is what we asked for for the tier",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(41750102016L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above JVM size knot point, 2 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(30).getBytes() - 2 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(20).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "2",
            ").build();",
            "// 29817307136 bytes = 28436MB",
            "// 28436MB node => 7756MB JVM heap (40% of 16384MB + 10% of 12052MB rounded down to a multiple of 4MB)",
            "// 28436MB - 7756MB - 200MB = 20480MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(29817307136L));",
            "// 47706013696 bytes = 45496MB",
            "// We expect to be given 2 nodes as there are 2 AZs, so each will be 22748MB",
            "// 22748MB node => 7188MB JVM heap (40% of 16384MB + 10% of 6364MB rounded down to a multiple of 4MB)",
            "// 22748MB - 7188MB - 200MB = 15360MB which is half of what we asked for for the tier",
            "// So with 2 nodes of this size we'll have the requested amount",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(47706013696L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above JVM size knot point, 3 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(30).getBytes() - 3 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(20).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "3",
            ").build();",
            "// 29817307136 bytes = 28436MB",
            "// 28436MB node => 7756MB JVM heap (40% of 16384MB + 10% of 12052MB rounded down to a multiple of 4MB)",
            "// 28436MB - 7756MB - 200MB = 20480MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(29817307136L));",
            "// 53666119680 bytes = 51180MB",
            "// We expect to be given 3 nodes as there are 3 AZs, so each will be 17060MB",
            "// 17060MB node => 6620MB JVM heap (40% of 16384MB + 10% of 676MB rounded down to a multiple of 4MB)",
            "// 17060MB - 6620MB - 200MB = 10240MB which is one third of what we asked for for the tier",
            "// So with 3 nodes of this size we'll have the requested amount",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(53666119680L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above single node size, 1 AZ (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(100).getBytes() - 2 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(5).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "1",
            ").build();",
            "// 9294577664 bytes = 8864MB",
            "// 8864MB node => 3544MB JVM heap (40% of 8864MB rounded down to a multiple of 4MB)",
            "// 8864MB - 3544MB - 200MB = 5120MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(9294577664L));",
            "// 131222994944 bytes = 125178MB",
            "// 125144MB requirement => 2 nodes needed, each 62572MB",
            "// 62572MB node => 11172MB JVM heap (40% of 16384MB + 10% of 46188MB rounded down to a multiple of 4MB)",
            "// 62572MB - 11172MB - 200MB = 51200MB which is half of what we asked for for the tier",
            "// So with 2 nodes of this size we'll have the requested amount",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(131222994944L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above single node size, 2 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(100).getBytes() - 2 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(5).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "2",
            ").build();",
            "// 9294577664 bytes = 8864MB",
            "// 8864MB node => 3544MB JVM heap (40% of 8864MB rounded down to a multiple of 4MB)",
            "// 8864MB - 3544MB - 200MB = 5120MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(9294577664L));",
            "// 131222994944 bytes = 125178MB",
            "// We expect to be given 2 nodes as there are 2 AZs, so each will be 62572MB",
            "// 62572MB node => 11172MB JVM heap (40% of 16384MB + 10% of 46188MB rounded down to a multiple of 4MB)",
            "// 62572MB - 11172MB - 200MB = 51200MB which is half of what we asked for for the tier",
            "// So with 2 nodes of this size we'll have the requested amount",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(131222994944L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above single node size, 3 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(100).getBytes() - 3 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(5).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "3",
            ").build();",
            "// 9294577664 bytes = 8864MB",
            "// 8864MB node => 3544MB JVM heap (40% of 8864MB rounded down to a multiple of 4MB)",
            "// 8864MB - 3544MB - 200MB = 5120MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(9294577664L));",
            "// 137170518018 bytes = 130816MB + 2 bytes",
            "// We expect to be given 3 nodes as there are 3 AZs, so each will be 43605 1/3MB",
            "// 43605 1/3MB node => 9272MB JVM heap (40% of 16384MB + 10% of 27221 1/3MB rounded down to a multiple of 4MB)",
            "// 43605 1/3MB - 9272MB - 200MB = 34133 1/3MB which is one third of what we asked for for the tier",
            "// So with 3 nodes of this size we'll have the requested amount",
            "// (The 2 byte discrepancy comes from the fact there are 3 nodes and 3 didn't divide exactly into the amount",
            "// of memory we needed, so each node gets a fraction of a byte extra to take it up to a whole number size)",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(137170518018L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above single node size, 1 AZ (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(155).getBytes() - 3 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(50).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "1",
            ").build();",
            "// 65611497472 bytes = 62572MB",
            "// 62572MB node => 11172MB JVM heap (40% of 16384MB + 10% of 46188MB rounded down to a multiple of 4MB)",
            "// 62572MB - 11172MB - 200MB = 51200MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(65611497472L));",
            "// 202794598401 bytes = 193400MB + 1 byte",
            "// 193406MB requirement => 3 nodes needed, each 64466 2/3MB",
            "// 64466 2/3MB node => 11360MB JVM heap (40% of 16384MB + 10% of 48082 2/3MB rounded down to a multiple of 4MB)",
            "// 64466 2/3MB - 11360MB - 200MB = 52906 2/3MB which is one third of what we asked for for the tier",
            "// So with 3 nodes of this size we'll have the requested amount",
            "// (The 1 byte discrepancy comes from the fact there are 3 nodes and 3 didn't divide exactly into the amount",
            "// of memory we needed, so each node gets a fraction of a byte extra to take it up to a whole number size)",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(202794598401L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above single node size, 2 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(155).getBytes() - 4 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(50).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "2",
            ").build();",
            "// 65611497472 bytes = 62572MB",
            "// 62572MB node => 11172MB JVM heap (40% of 16384MB + 10% of 46188MB rounded down to a multiple of 4MB)",
            "// 62572MB - 11172MB - 200MB = 51200MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(65611497472L));",
            "// 208758898688 bytes = 199088MB",
            "// We expect to be given a multiple of 2 nodes as there are 2 AZs",
            "// 199088MB requirement => 4 nodes needed, each 49772MB",
            "// 49772MB node => 9892MB JVM heap (40% of 16384MB + 10% of 33388MB rounded down to a multiple of 4MB)",
            "// 49772MB - 9892MB - 200MB = 39680MB which is one quarter of what we asked for for the tier",
            "// So with 4 nodes of this size we'll have the requested amount",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(208758898688L));",
            "}",
            "// auto is true with unknown jvm size, memory requirement above single node size, 3 AZs (this is a realistic case for Cloud)",
            "{",
            "capacity = new NativeMemoryCapacity(",
            "ByteSizeValue.ofGb(155).getBytes() - 3 * NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes(),",
            "ByteSizeValue.ofGb(50).getBytes() - NATIVE_EXECUTABLE_CODE_OVERHEAD.getBytes()",
            ");",
            "MlMemoryAutoscalingCapacity autoscalingCapacity = capacity.autoscalingCapacity(",
            "randomIntBetween(5, 90),",
            "true,",
            "AUTO_ML_MEMORY_FOR_64GB_NODE,",
            "3",
            ").build();",
            "// 65611497472 bytes = 62572MB",
            "// 62572MB node => 11172MB JVM heap (40% of 16384MB + 10% of 46188MB rounded down to a multiple of 4MB)",
            "// 62572MB - 11172MB - 200MB = 51200MB which is what we need on a single node",
            "assertThat(autoscalingCapacity.nodeSize().getBytes(), equalTo(65611497472L));",
            "// 202794598401 bytes = 193400MB + 1 byte",
            "// We expect to be given 3 nodes as there are 3 AZs, so each will be 64466 2/3MB",
            "// 64466 2/3MB node => 11360MB JVM heap (40% of 16384MB + 10% of 48082 2/3MB rounded down to a multiple of 4MB)",
            "// 64466 2/3MB - 11360MB - 200MB = 52906 2/3MB which is one third of what we asked for for the tier",
            "// So with 3 nodes of this size we'll have the requested amount",
            "// (The 1 byte discrepancy comes from the fact there are 3 nodes and 3 didn't divide exactly into the amount",
            "// of memory we needed, so each node gets a fraction of a byte extra to take it up to a whole number size)",
            "assertThat(autoscalingCapacity.tierSize().getBytes(), equalTo(202794598401L));",
            "}",
            "}"
        ],
        "max_rank": -0.487889273353294
    },
    {
        "file": "dataset/9_original.java",
        "method": "testStopAtCheckpoint",
        "new_method_name": "handle_new",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            181,
            182,
            183,
            184,
            185,
            186,
            187,
            188,
            189,
            190,
            191,
            192,
            193,
            194,
            195,
            196,
            197,
            198,
            199,
            200,
            201,
            202
        ],
        "extracted_lines": [
            "public void testStopAtCheckpoint() throws Exception {",
            "TransformConfig config = new TransformConfig(",
            "randomAlphaOfLength(10),",
            "randomSourceConfig(),",
            "randomDestConfig(),",
            "null,",
            "new TimeSyncConfig(\"timestamp\", TimeValue.timeValueSeconds(1)),",
            "null,",
            "randomPivotConfig(),",
            "null,",
            "randomBoolean() ? null : randomAlphaOfLengthBetween(1, 1000),",
            "null,",
            "null,",
            "null,",
            "null,",
            "null",
            ");",
            "for (IndexerState state : IndexerState.values()) {",
            "// skip indexing case, tested below",
            "if (IndexerState.INDEXING.equals(state)) {",
            "continue;",
            "}",
            "AtomicReference<IndexerState> stateRef = new AtomicReference<>(state);",
            "TransformContext context = new TransformContext(TransformTaskState.STARTED, \"\", 0, mock(TransformContext.Listener.class));",
            "final MockedTransformIndexer indexer = createMockIndexer(",
            "config,",
            "stateRef,",
            "null,",
            "threadPool,",
            "auditor,",
            "new TransformIndexerPosition(Collections.singletonMap(\"afterkey\", \"value\"), Collections.emptyMap()),",
            "new TransformIndexerStats(),",
            "context",
            ");",
            "assertResponse(listener -> setStopAtCheckpoint(indexer, true, listener));",
            "assertEquals(0, indexer.getSaveStateListenerCallCount());",
            "if (IndexerState.STARTED.equals(state)) {",
            "assertTrue(context.shouldStopAtCheckpoint());",
            "assertTrue(indexer.getPersistedState().shouldStopAtNextCheckpoint());",
            "} else {",
            "// shouldStopAtCheckpoint should not be set, because the indexer is already stopped, stopping or aborting",
            "assertFalse(context.shouldStopAtCheckpoint());",
            "assertFalse(indexer.getPersistedState().shouldStopAtNextCheckpoint());",
            "}",
            "}",
            "// test the case that the indexer is at a checkpoint already",
            "{",
            "AtomicReference<IndexerState> stateRef = new AtomicReference<>(IndexerState.STARTED);",
            "TransformContext context = new TransformContext(TransformTaskState.STARTED, \"\", 0, mock(TransformContext.Listener.class));",
            "final MockedTransformIndexer indexer = createMockIndexer(",
            "config,",
            "stateRef,",
            "null,",
            "threadPool,",
            "auditor,",
            "null,",
            "new TransformIndexerStats(),",
            "context",
            ");",
            "assertResponse(listener -> setStopAtCheckpoint(indexer, true, listener));",
            "assertEquals(0, indexer.getSaveStateListenerCallCount());",
            "// shouldStopAtCheckpoint should not be set, the indexer was started, however at a checkpoint",
            "assertFalse(context.shouldStopAtCheckpoint());",
            "assertFalse(indexer.getPersistedState().shouldStopAtNextCheckpoint());",
            "}",
            "// lets test a running indexer",
            "AtomicReference<IndexerState> state = new AtomicReference<>(IndexerState.STARTED);",
            "{",
            "TransformContext context = new TransformContext(TransformTaskState.STARTED, \"\", 0, mock(TransformContext.Listener.class));",
            "final MockedTransformIndexer indexer = createMockIndexer(",
            "config,",
            "state,",
            "null,",
            "threadPool,",
            "auditor,",
            "null,",
            "new TransformIndexerStats(),",
            "context",
            ");",
            "indexer.start();",
            "assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));",
            "assertEquals(indexer.getState(), IndexerState.INDEXING);",
            "assertResponse(listener -> setStopAtCheckpoint(indexer, true, listener));",
            "indexer.stop();",
            "assertBusy(() -> assertThat(indexer.getState(), equalTo(IndexerState.STOPPED)), 5, TimeUnit.SECONDS);",
            "// listener must have been called by the indexing thread",
            "assertEquals(1, indexer.getSaveStateListenerCallCount());",
            "// as the state is stopped it should go back to directly",
            "assertResponse(listener -> setStopAtCheckpoint(indexer, true, listener));",
            "assertEquals(1, indexer.getSaveStateListenerCallCount());",
            "}",
            "// do another round",
            "{",
            "TransformContext context = new TransformContext(TransformTaskState.STARTED, \"\", 0, mock(TransformContext.Listener.class));",
            "final MockedTransformIndexer indexer = createMockIndexer(",
            "config,",
            "state,",
            "null,",
            "threadPool,",
            "auditor,",
            "null,",
            "new TransformIndexerStats(),",
            "context",
            ");",
            "indexer.start();",
            "assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));",
            "assertEquals(indexer.getState(), IndexerState.INDEXING);",
            "// this time call it 3 times",
            "assertResponse(listener -> setStopAtCheckpoint(indexer, true, listener));",
            "assertResponse(listener -> setStopAtCheckpoint(indexer, true, listener));",
            "assertResponse(listener -> setStopAtCheckpoint(indexer, true, listener));",
            "indexer.stop();",
            "assertBusy(() -> assertThat(indexer.getState(), equalTo(IndexerState.STOPPED)), 5, TimeUnit.SECONDS);",
            "// listener must have been called by the indexing thread between 1 and 3 times",
            "assertThat(indexer.getSaveStateListenerCallCount(), greaterThanOrEqualTo(1));",
            "assertThat(indexer.getSaveStateListenerCallCount(), lessThanOrEqualTo(3));",
            "}",
            "// 3rd round with some back and forth",
            "{",
            "TransformContext context = new TransformContext(TransformTaskState.STARTED, \"\", 0, mock(TransformContext.Listener.class));",
            "final MockedTransformIndexer indexer = createMockIndexer(",
            "config,",
            "state,",
            "null,",
            "threadPool,",
            "auditor,",
            "null,",
            "new TransformIndexerStats(),",
            "context",
            ");",
            "indexer.start();",
            "assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));",
            "assertEquals(indexer.getState(), IndexerState.INDEXING);",
            "// slow down the indexer",
            "CountDownLatch searchLatch = indexer.createAwaitForSearchLatch(1);",
            "// this time call 5 times and change stopAtCheckpoint every time",
            "List<CountDownLatch> responseLatches = new ArrayList<>();",
            "for (int i = 0; i < 5; ++i) {",
            "CountDownLatch latch = new CountDownLatch(1);",
            "boolean stopAtCheckpoint = i % 2 == 0;",
            "countResponse(listener -> setStopAtCheckpoint(indexer, stopAtCheckpoint, listener), latch);",
            "responseLatches.add(latch);",
            "}",
            "// now let the indexer run again",
            "searchLatch.countDown();",
            "indexer.stop();",
            "assertBusy(() -> assertThat(indexer.getState(), equalTo(IndexerState.STOPPED)), 5, TimeUnit.SECONDS);",
            "// wait for all listeners",
            "for (CountDownLatch l : responseLatches) {",
            "assertTrue(\"timed out after 5s\", l.await(5, TimeUnit.SECONDS));",
            "}",
            "// listener must have been called 5 times, because the value changed every time and we slowed down the indexer",
            "assertThat(indexer.getSaveStateListenerCallCount(), equalTo(5));",
            "}",
            "// 4th round: go wild",
            "{",
            "TransformContext context = new TransformContext(TransformTaskState.STARTED, \"\", 0, mock(TransformContext.Listener.class));",
            "final MockedTransformIndexer indexer = createMockIndexer(",
            "config,",
            "state,",
            "null,",
            "threadPool,",
            "auditor,",
            "null,",
            "new TransformIndexerStats(),",
            "context",
            ");",
            "indexer.start();",
            "assertTrue(indexer.maybeTriggerAsyncJob(System.currentTimeMillis()));",
            "assertEquals(indexer.getState(), IndexerState.INDEXING);",
            "// slow down the indexer",
            "CountDownLatch searchLatch = indexer.createAwaitForSearchLatch(1);",
            "List<CountDownLatch> responseLatches = new ArrayList<>();",
            "// default stopAtCheckpoint is false",
            "boolean previousStopAtCheckpoint = false;",
            "for (int i = 0; i < 3; ++i) {",
            "CountDownLatch latch = new CountDownLatch(1);",
            "boolean stopAtCheckpoint = randomBoolean();",
            "previousStopAtCheckpoint = stopAtCheckpoint;",
            "countResponse(listener -> setStopAtCheckpoint(indexer, stopAtCheckpoint, listener), latch);",
            "responseLatches.add(latch);",
            "}",
            "// now let the indexer run again",
            "searchLatch.countDown();",
            "// call it 3 times again",
            "for (int i = 0; i < 3; ++i) {",
            "boolean stopAtCheckpoint = randomBoolean();",
            "previousStopAtCheckpoint = stopAtCheckpoint;",
            "assertResponse(listener -> setStopAtCheckpoint(indexer, stopAtCheckpoint, listener));",
            "}",
            "indexer.stop();",
            "assertBusy(() -> assertThat(indexer.getState(), equalTo(IndexerState.STOPPED)), 5, TimeUnit.SECONDS);",
            "// wait for all listeners",
            "for (CountDownLatch l : responseLatches) {",
            "assertTrue(\"timed out after 5s\", l.await(5, TimeUnit.SECONDS));",
            "}",
            "// there should be no listeners waiting",
            "assertEquals(0, indexer.getSaveStateListenerCount());",
            "// listener must have been called by the indexing thread between timesStopAtCheckpointChanged and 6 times",
            "// this is not exact, because we do not know _when_ the other thread persisted the flag",
            "assertThat(indexer.getSaveStateListenerCallCount(), lessThanOrEqualTo(6));",
            "}",
            "}"
        ],
        "max_rank": -0.49508599508548423
    },
    {
        "file": "dataset/10_original.java",
        "method": "parse",
        "new_method_name": "handle_token",
        "extracted_line_numbers": [
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116
        ],
        "extracted_lines": [
            "if (\"headers\".equals(currentFieldName)) {",
            "String headerName = null;",
            "while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {",
            "if (token == XContentParser.Token.FIELD_NAME) {",
            "headerName = parser.currentName();",
            "} else if (token.isValue()) {",
            "headers.put(headerName, parser.text());",
            "}",
            "}",
            "} else if (\"node_selector\".equals(currentFieldName)) {",
            "String selectorName = null;",
            "while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {",
            "if (token == XContentParser.Token.FIELD_NAME) {",
            "selectorName = parser.currentName();",
            "} else {",
            "NodeSelector newSelector = buildNodeSelector(selectorName, parser);",
            "nodeSelector = nodeSelector == NodeSelector.ANY",
            "? newSelector",
            ": new ComposeNodeSelector(nodeSelector, newSelector);",
            "}",
            "}",
            "} else if (currentFieldName != null) { // must be part of API call then",
            "apiCallSection = new ApiCallSection(currentFieldName);",
            "String paramName = null;",
            "while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {",
            "if (token == XContentParser.Token.FIELD_NAME) {",
            "paramName = parser.currentName();",
            "} else if (token.isValue()) {",
            "if (\"body\".equals(paramName)) {",
            "String body = parser.text();",
            "XContentParser bodyParser = JsonXContent.jsonXContent.createParser(XContentParserConfiguration.EMPTY, body);",
            "// multiple bodies are supported e.g. in case of bulk provided as a whole string",
            "while (bodyParser.nextToken() != null) {",
            "apiCallSection.addBody(bodyParser.mapOrdered());",
            "}",
            "} else {",
            "apiCallSection.addParam(paramName, parser.text());",
            "}",
            "} else if (token == XContentParser.Token.START_OBJECT) {",
            "if (\"body\".equals(paramName)) {",
            "apiCallSection.addBody(parser.mapOrdered());",
            "}",
            "}",
            "}",
            "}"
        ],
        "max_rank": 0.4788931092209616
    },
    {
        "file": "dataset/11_original.java",
        "method": "testSortMVField",
        "new_method_name": "handle_client",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            181,
            182,
            183,
            184,
            185,
            186,
            187,
            188,
            189,
            190,
            191,
            192,
            193,
            194,
            195,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            210,
            211,
            212,
            213,
            214,
            215,
            216,
            217,
            218,
            219,
            220,
            221,
            222,
            223,
            224,
            225,
            226,
            227,
            228,
            229,
            230,
            231,
            232,
            233,
            234,
            235,
            236,
            237,
            238,
            239,
            240,
            241,
            242,
            243,
            244,
            245,
            246
        ],
        "extracted_lines": [
            "public void testSortMVField() throws Exception {",
            "assertAcked(",
            "prepareCreate(\"test\").setMapping(",
            "XContentFactory.jsonBuilder()",
            ".startObject()",
            ".startObject(\"_doc\")",
            ".startObject(\"properties\")",
            ".startObject(\"long_values\")",
            ".field(\"type\", \"long\")",
            ".endObject()",
            ".startObject(\"int_values\")",
            ".field(\"type\", \"integer\")",
            ".endObject()",
            ".startObject(\"short_values\")",
            ".field(\"type\", \"short\")",
            ".endObject()",
            ".startObject(\"byte_values\")",
            ".field(\"type\", \"byte\")",
            ".endObject()",
            ".startObject(\"float_values\")",
            ".field(\"type\", \"float\")",
            ".endObject()",
            ".startObject(\"double_values\")",
            ".field(\"type\", \"double\")",
            ".endObject()",
            ".startObject(\"string_values\")",
            ".field(\"type\", \"keyword\")",
            ".endObject()",
            ".endObject()",
            ".endObject()",
            ".endObject()",
            ")",
            ");",
            "ensureGreen();",
            "client().prepareIndex(\"test\")",
            ".setId(Integer.toString(1))",
            ".setSource(",
            "jsonBuilder().startObject()",
            ".array(\"long_values\", 1L, 5L, 10L, 8L)",
            ".array(\"int_values\", 1, 5, 10, 8)",
            ".array(\"short_values\", 1, 5, 10, 8)",
            ".array(\"byte_values\", 1, 5, 10, 8)",
            ".array(\"float_values\", 1f, 5f, 10f, 8f)",
            ".array(\"double_values\", 1d, 5d, 10d, 8d)",
            ".array(\"string_values\", \"01\", \"05\", \"10\", \"08\")",
            ".endObject()",
            ")",
            ".get();",
            "client().prepareIndex(\"test\")",
            ".setId(Integer.toString(2))",
            ".setSource(",
            "jsonBuilder().startObject()",
            ".array(\"long_values\", 11L, 15L, 20L, 7L)",
            ".array(\"int_values\", 11, 15, 20, 7)",
            ".array(\"short_values\", 11, 15, 20, 7)",
            ".array(\"byte_values\", 11, 15, 20, 7)",
            ".array(\"float_values\", 11f, 15f, 20f, 7f)",
            ".array(\"double_values\", 11d, 15d, 20d, 7d)",
            ".array(\"string_values\", \"11\", \"15\", \"20\", \"07\")",
            ".endObject()",
            ")",
            ".get();",
            "client().prepareIndex(\"test\")",
            ".setId(Integer.toString(3))",
            ".setSource(",
            "jsonBuilder().startObject()",
            ".array(\"long_values\", 2L, 1L, 3L, -4L)",
            ".array(\"int_values\", 2, 1, 3, -4)",
            ".array(\"short_values\", 2, 1, 3, -4)",
            ".array(\"byte_values\", 2, 1, 3, -4)",
            ".array(\"float_values\", 2f, 1f, 3f, -4f)",
            ".array(\"double_values\", 2d, 1d, 3d, -4d)",
            ".array(\"string_values\", \"02\", \"01\", \"03\", \"!4\")",
            ".endObject()",
            ")",
            ".get();",
            "refresh();",
            "SearchResponse searchResponse = client().prepareSearch()",
            ".setQuery(matchAllQuery())",
            ".setSize(10)",
            ".addSort(\"long_values\", SortOrder.ASC)",
            ".get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).longValue(), equalTo(-4L));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).longValue(), equalTo(1L));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).longValue(), equalTo(7L));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"long_values\", SortOrder.DESC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).longValue(), equalTo(20L));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).longValue(), equalTo(10L));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).longValue(), equalTo(3L));",
            "searchResponse = client().prepareSearch()",
            ".setQuery(matchAllQuery())",
            ".setSize(10)",
            ".addSort(SortBuilders.fieldSort(\"long_values\").order(SortOrder.DESC).sortMode(SortMode.SUM))",
            ".get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).longValue(), equalTo(53L));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).longValue(), equalTo(24L));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).longValue(), equalTo(2L));",
            "searchResponse = client().prepareSearch()",
            ".setQuery(matchAllQuery())",
            ".setSize(10)",
            ".addSort(SortBuilders.fieldSort(\"long_values\").order(SortOrder.DESC).sortMode(SortMode.AVG))",
            ".get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).longValue(), equalTo(13L));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).longValue(), equalTo(6L));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).longValue(), equalTo(1L));",
            "searchResponse = client().prepareSearch()",
            ".setQuery(matchAllQuery())",
            ".setSize(10)",
            ".addSort(SortBuilders.fieldSort(\"long_values\").order(SortOrder.DESC).sortMode(SortMode.MEDIAN))",
            ".get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).longValue(), equalTo(13L));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).longValue(), equalTo(7L));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).longValue(), equalTo(2L));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"int_values\", SortOrder.ASC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).intValue(), equalTo(-4));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).intValue(), equalTo(1));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).intValue(), equalTo(7));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"int_values\", SortOrder.DESC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).intValue(), equalTo(20));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).intValue(), equalTo(10));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).intValue(), equalTo(3));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"short_values\", SortOrder.ASC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).intValue(), equalTo(-4));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).intValue(), equalTo(1));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).intValue(), equalTo(7));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"short_values\", SortOrder.DESC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).intValue(), equalTo(20));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).intValue(), equalTo(10));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).intValue(), equalTo(3));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"byte_values\", SortOrder.ASC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).intValue(), equalTo(-4));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).intValue(), equalTo(1));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).intValue(), equalTo(7));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"byte_values\", SortOrder.DESC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).intValue(), equalTo(20));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).intValue(), equalTo(10));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).intValue(), equalTo(3));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"float_values\", SortOrder.ASC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).floatValue(), equalTo(-4f));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).floatValue(), equalTo(1f));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).floatValue(), equalTo(7f));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"float_values\", SortOrder.DESC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).floatValue(), equalTo(20f));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).floatValue(), equalTo(10f));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).floatValue(), equalTo(3f));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"double_values\", SortOrder.ASC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).doubleValue(), equalTo(-4d));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).doubleValue(), equalTo(1d));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).doubleValue(), equalTo(7d));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"double_values\", SortOrder.DESC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(2)));",
            "assertThat(((Number) searchResponse.getHits().getAt(0).getSortValues()[0]).doubleValue(), equalTo(20d));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(((Number) searchResponse.getHits().getAt(1).getSortValues()[0]).doubleValue(), equalTo(10d));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(3)));",
            "assertThat(((Number) searchResponse.getHits().getAt(2).getSortValues()[0]).doubleValue(), equalTo(3d));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"string_values\", SortOrder.ASC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(3)));",
            "assertThat(searchResponse.getHits().getAt(0).getSortValues()[0], equalTo(\"!4\"));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(searchResponse.getHits().getAt(1).getSortValues()[0], equalTo(\"01\"));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(2)));",
            "assertThat(searchResponse.getHits().getAt(2).getSortValues()[0], equalTo(\"07\"));",
            "searchResponse = client().prepareSearch().setQuery(matchAllQuery()).setSize(10).addSort(\"string_values\", SortOrder.DESC).get();",
            "assertThat(searchResponse.getHits().getTotalHits().value, equalTo(3L));",
            "assertThat(searchResponse.getHits().getHits().length, equalTo(3));",
            "assertThat(searchResponse.getHits().getAt(0).getId(), equalTo(Integer.toString(2)));",
            "assertThat(searchResponse.getHits().getAt(0).getSortValues()[0], equalTo(\"20\"));",
            "assertThat(searchResponse.getHits().getAt(1).getId(), equalTo(Integer.toString(1)));",
            "assertThat(searchResponse.getHits().getAt(1).getSortValues()[0], equalTo(\"10\"));",
            "assertThat(searchResponse.getHits().getAt(2).getId(), equalTo(Integer.toString(3)));",
            "assertThat(searchResponse.getHits().getAt(2).getSortValues()[0], equalTo(\"03\"));",
            "}"
        ],
        "max_rank": -0.5000000000007149
    },
    {
        "file": "dataset/12_original.java",
        "method": "getLegalCast",
        "new_method_name": "get_def",
        "extracted_line_numbers": [
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40
        ],
        "extracted_lines": [
            "if (expected == boolean.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, boolean.class, explicit);",
            "} else if (expected == byte.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, byte.class, explicit);",
            "} else if (expected == short.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, short.class, explicit);",
            "} else if (expected == char.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, char.class, explicit);",
            "} else if (expected == int.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, int.class, explicit);",
            "} else if (expected == long.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, long.class, explicit);",
            "} else if (expected == float.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, float.class, explicit);",
            "} else if (expected == double.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, double.class, explicit);",
            "} else if (expected == Boolean.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, Boolean.class, explicit);",
            "} else if (expected == Byte.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, Byte.class, explicit);",
            "} else if (expected == Short.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, Short.class, explicit);",
            "} else if (expected == Character.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, Character.class, explicit);",
            "} else if (expected == Integer.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, Integer.class, explicit);",
            "} else if (expected == Long.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, Long.class, explicit);",
            "} else if (expected == Float.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, Float.class, explicit);",
            "} else if (expected == Double.class) {",
            "return PainlessCast.originalTypetoTargetType(def.class, Double.class, explicit);",
            "}",
            "} else if (actual == String.class) {"
        ],
        "max_rank": 0.40307943247649997
    },
    {
        "file": "dataset/13_original.java",
        "method": "getTypeForFactoryMethod",
        "new_method_name": "handle_factoryBeanName",
        "extracted_line_numbers": [
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            35
        ],
        "extracted_lines": [
            "if (factoryBeanName != null) {",
            "if (factoryBeanName.equals(beanName)) {",
            "throw new BeanDefinitionStoreException(mbd.getResourceDescription(), beanName,",
            "\"factory-bean reference points back to the same bean definition\");",
            "}",
            "// Check declared factory method return type on factory class.",
            "factoryClass = getType(factoryBeanName);",
            "isStatic = false;",
            "}",
            "if (Modifier.isStatic(candidate.getModifiers()) == isStatic && mbd.isFactoryMethod(candidate) &&"
        ],
        "max_rank": 0.48234754256732715
    },
    {
        "file": "dataset/14_original.java",
        "method": "parse",
        "new_method_name": "get_pathPattern",
        "extracted_line_numbers": [
            33,
            34,
            35,
            36,
            39,
            45,
            40,
            41,
            42,
            43,
            44,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            58,
            57,
            59,
            60,
            61,
            62,
            64,
            63,
            65,
            66,
            67,
            68,
            69,
            91
        ],
        "extracted_lines": [
            "if (this.insideVariableCapture) {",
            "throw new PatternParseException(this.pos, this.pathPatternData,",
            "PatternMessage.ILLEGAL_NESTED_CAPTURE);",
            "}",
            "// } else if (pos > 0 && pathPatternData[pos - 1] == '}') {",
            "else if (ch == '}') {",
            "// throw new PatternParseException(pos, pathPatternData,",
            "// PatternMessage.CANNOT_HAVE_ADJACENT_CAPTURES);",
            "this.insideVariableCapture = true;",
            "this.variableCaptureStart = this.pos;",
            "}",
            "if (!this.insideVariableCapture) {",
            "throw new PatternParseException(this.pos, this.pathPatternData,",
            "PatternMessage.MISSING_OPEN_CAPTURE);",
            "}",
            "this.insideVariableCapture = false;",
            "if (this.isCaptureTheRestVariable && (this.pos + 1) < this.pathPatternLength) {",
            "throw new PatternParseException(this.pos + 1, this.pathPatternData,",
            "PatternMessage.NO_MORE_DATA_EXPECTED_AFTER_CAPTURE_THE_REST);",
            "}",
            "this.variableCaptureCount++;",
            "}",
            "if (this.insideVariableCapture && !this.isCaptureTheRestVariable) {",
            "else if (ch == ':') {",
            "skipCaptureRegex();",
            "this.insideVariableCapture = false;",
            "this.variableCaptureCount++;",
            "}",
            "else if (ch == '*') {",
            "}",
            "if (this.insideVariableCapture && this.variableCaptureStart == this.pos - 1) {",
            "this.isCaptureTheRestVariable = true;",
            "}",
            "this.wildcard = true;",
            "}",
            "return new PathPattern(pathPattern, this.parser, this.headPE);"
        ],
        "max_rank": 0.43407267380801595
    },
    {
        "file": "dataset/15_original.java",
        "method": "testOpenEntityManagerInViewFilterAsyncScenario",
        "new_method_name": "handle_mock",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66
        ],
        "extracted_lines": [
            "public void testOpenEntityManagerInViewFilterAsyncScenario() throws Exception {",
            "given(manager.isOpen()).willReturn(true);",
            "final EntityManagerFactory factory2 = mock();",
            "final EntityManager manager2 = mock();",
            "given(factory2.createEntityManager()).willReturn(manager2);",
            "given(manager2.isOpen()).willReturn(true);",
            "MockServletContext sc = new MockServletContext();",
            "StaticWebApplicationContext wac = new StaticWebApplicationContext();",
            "wac.setServletContext(sc);",
            "wac.getDefaultListableBeanFactory().registerSingleton(\"entityManagerFactory\", factory);",
            "wac.getDefaultListableBeanFactory().registerSingleton(\"myEntityManagerFactory\", factory2);",
            "wac.refresh();",
            "sc.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, wac);",
            "MockFilterConfig filterConfig = new MockFilterConfig(wac.getServletContext(), \"filter\");",
            "MockFilterConfig filterConfig2 = new MockFilterConfig(wac.getServletContext(), \"filter2\");",
            "filterConfig2.addInitParameter(\"entityManagerFactoryBeanName\", \"myEntityManagerFactory\");",
            "final OpenEntityManagerInViewFilter filter = new OpenEntityManagerInViewFilter();",
            "filter.init(filterConfig);",
            "final OpenEntityManagerInViewFilter filter2 = new OpenEntityManagerInViewFilter();",
            "filter2.init(filterConfig2);",
            "final AtomicInteger count = new AtomicInteger();",
            "final FilterChain filterChain = (servletRequest, servletResponse) -> {",
            "assertThat(TransactionSynchronizationManager.hasResource(factory)).isTrue();",
            "servletRequest.setAttribute(\"invoked\", Boolean.TRUE);",
            "count.incrementAndGet();",
            "};",
            "final AtomicInteger count2 = new AtomicInteger();",
            "final FilterChain filterChain2 = (servletRequest, servletResponse) -> {",
            "assertThat(TransactionSynchronizationManager.hasResource(factory2)).isTrue();",
            "filter.doFilter(servletRequest, servletResponse, filterChain);",
            "count2.incrementAndGet();",
            "};",
            "FilterChain filterChain3 = new PassThroughFilterChain(filter2, filterChain2);",
            "AsyncWebRequest asyncWebRequest = mock();",
            "given(asyncWebRequest.isAsyncStarted()).willReturn(true);",
            "WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(this.request);",
            "asyncManager.setTaskExecutor(this.taskExecutor);",
            "asyncManager.setAsyncWebRequest(asyncWebRequest);",
            "asyncManager.startCallableProcessing((Callable<String>) () -> \"anything\");",
            "this.taskExecutor.await();",
            "assertThat(asyncManager.getConcurrentResult()).as(\"Concurrent result \").isEqualTo(\"anything\");",
            "assertThat(TransactionSynchronizationManager.hasResource(factory)).isFalse();",
            "assertThat(TransactionSynchronizationManager.hasResource(factory2)).isFalse();",
            "filter2.doFilter(this.request, this.response, filterChain3);",
            "assertThat(TransactionSynchronizationManager.hasResource(factory)).isFalse();",
            "assertThat(TransactionSynchronizationManager.hasResource(factory2)).isFalse();",
            "assertThat(count.get()).isEqualTo(1);",
            "assertThat(count2.get()).isEqualTo(1);",
            "assertThat(request.getAttribute(\"invoked\")).isNotNull();",
            "verify(asyncWebRequest, times(2)).addCompletionHandler(any(Runnable.class));",
            "verify(asyncWebRequest).addTimeoutHandler(any(Runnable.class));",
            "verify(asyncWebRequest, times(2)).addCompletionHandler(any(Runnable.class));",
            "verify(asyncWebRequest).startAsync();",
            "// Async dispatch after concurrent handling produces result ...",
            "reset(asyncWebRequest);",
            "given(asyncWebRequest.isAsyncStarted()).willReturn(false);",
            "assertThat(TransactionSynchronizationManager.hasResource(factory)).isFalse();",
            "assertThat(TransactionSynchronizationManager.hasResource(factory2)).isFalse();",
            "filter.doFilter(this.request, this.response, filterChain3);",
            "assertThat(TransactionSynchronizationManager.hasResource(factory)).isFalse();",
            "assertThat(TransactionSynchronizationManager.hasResource(factory2)).isFalse();",
            "assertThat(count.get()).isEqualTo(2);",
            "assertThat(count2.get()).isEqualTo(2);",
            "verify(this.manager).close();",
            "verify(manager2).close();",
            "wac.close();",
            "}"
        ],
        "max_rank": -0.47435897435894187
    },
    {
        "file": "dataset/16_original.java",
        "method": "compilingMathematicalExpressionsWithDifferentOperandTypes",
        "new_method_name": "handle_new",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78
        ],
        "extracted_lines": [
            "public void compilingMathematicalExpressionsWithDifferentOperandTypes() throws Exception {",
            "NumberHolder nh = new NumberHolder();",
            "expression = parser.parseExpression(\"(T(Integer).valueOf(payload).doubleValue())/18D\");",
            "Object o = expression.getValue(nh);",
            "assertThat(o).isEqualTo(2d);",
            "System.out.println(\"Performance check for SpEL expression: '(T(Integer).valueOf(payload).doubleValue())/18D'\");",
            "long stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "compile(expression);",
            "System.out.println(\"Now compiled:\");",
            "o = expression.getValue(nh);",
            "assertThat(o).isEqualTo(2d);",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "expression = parser.parseExpression(\"payload/18D\");",
            "o = expression.getValue(nh);",
            "assertThat(o).isEqualTo(2d);",
            "System.out.println(\"Performance check for SpEL expression: 'payload/18D'\");",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "compile(expression);",
            "System.out.println(\"Now compiled:\");",
            "o = expression.getValue(nh);",
            "assertThat(o).isEqualTo(2d);",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "stime = System.currentTimeMillis();",
            "for (int i = 0; i < 1000000; i++) {",
            "o = expression.getValue(nh);",
            "}",
            "System.out.println(\"One million iterations: \" + (System.currentTimeMillis()-stime) + \"ms\");",
            "}"
        ],
        "max_rank": -0.38059701492536674
    },
    {
        "file": "dataset/17_original.java",
        "method": "handleTransportRequest",
        "new_method_name": "handle_session",
        "extracted_line_numbers": [
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            64
        ],
        "extracted_lines": [
            "if (session == null) {",
            "if (transportHandler instanceof SockJsSessionFactory sessionFactory) {",
            "Map<String, Object> attributes = new HashMap<>();",
            "if (!chain.applyBeforeHandshake(request, response, attributes)) {",
            "return;",
            "}",
            "session = createSockJsSession(sessionId, sessionFactory, handler, attributes);",
            "isNewSession = true;",
            "}",
            "else {",
            "response.setStatusCode(HttpStatus.NOT_FOUND);",
            "if (logger.isDebugEnabled()) {",
            "logger.debug(\"Session not found, sessionId=\" + sessionId +",
            "\". The session may have been closed \" +",
            "\"(e.g. missed heart-beat) while a message was coming in.\");",
            "}",
            "return;",
            "}",
            "}",
            "if (!transportHandler.checkSessionType(session)) {"
        ],
        "max_rank": 0.49768990634755744
    },
    {
        "file": "dataset/18_original.java",
        "method": "handleRequest",
        "new_method_name": "handle_sockJsPath",
        "extracted_line_numbers": [
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97
        ],
        "extracted_lines": [
            "else {",
            "String[] pathSegments = StringUtils.tokenizeToStringArray(sockJsPath.substring(1), \"/\");",
            "if (pathSegments.length != 3) {",
            "if (logger.isWarnEnabled()) {",
            "logger.warn(LogFormatUtils.formatValue(\"Invalid SockJS path '\" + sockJsPath + \"' - \" +",
            "\"required to have 3 path segments\", -1, true));",
            "}",
            "if (requestInfo != null) {",
            "logger.debug(\"Ignoring transport request: \" + requestInfo);",
            "}",
            "response.setStatusCode(HttpStatus.NOT_FOUND);",
            "return;",
            "}",
            "String serverId = pathSegments[0];",
            "String sessionId = pathSegments[1];",
            "String transport = pathSegments[2];",
            "if (!isWebSocketEnabled() && transport.equals(\"websocket\")) {",
            "if (requestInfo != null) {",
            "logger.debug(\"WebSocket disabled. Ignoring transport request: \" + requestInfo);",
            "}",
            "response.setStatusCode(HttpStatus.NOT_FOUND);",
            "return;",
            "}",
            "else if (!validateRequest(serverId, sessionId, transport) || !validatePath(request)) {",
            "if (requestInfo != null) {",
            "logger.debug(\"Ignoring transport request: \" + requestInfo);",
            "}",
            "response.setStatusCode(HttpStatus.NOT_FOUND);",
            "return;",
            "}",
            "if (requestInfo != null) {",
            "logger.debug(\"Processing transport request: \" + requestInfo);",
            "}",
            "handleTransportRequest(request, response, wsHandler, sessionId, transport);",
            "}"
        ],
        "max_rank": 0.5023095036831767
    },
    {
        "file": "dataset/19_original.java",
        "method": "registerSockJsService",
        "new_method_name": "handle_transportHandlersElement",
        "extracted_line_numbers": [
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30
        ],
        "extracted_lines": [
            "if (transportHandlersElement != null) {",
            "String registerDefaults = transportHandlersElement.getAttribute(\"register-defaults\");",
            "if (registerDefaults.equals(\"false\")) {",
            "sockJsServiceDef.setBeanClass(TransportHandlingSockJsService.class);",
            "}",
            "ManagedList<?> transportHandlers = parseBeanSubElements(transportHandlersElement, context);",
            "sockJsServiceDef.getConstructorArgumentValues().addIndexedArgumentValue(1, transportHandlers);",
            "}",
            "else if (handshakeHandler != null) {",
            "RuntimeBeanReference handshakeHandlerRef = new RuntimeBeanReference(handshakeHandler.getAttribute(\"ref\"));",
            "RootBeanDefinition transportHandler = new RootBeanDefinition(WebSocketTransportHandler.class);",
            "transportHandler.setSource(source);",
            "transportHandler.getConstructorArgumentValues().addIndexedArgumentValue(0, handshakeHandlerRef);",
            "sockJsServiceDef.getConstructorArgumentValues().addIndexedArgumentValue(1, transportHandler);",
            "}"
        ],
        "max_rank": 0.45740108288215653
    },
    {
        "file": "dataset/20_original.java",
        "method": "nullsafeMethodChaining_SPR16489",
        "new_method_name": "handle_new",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91
        ],
        "extracted_lines": [
            "public void nullsafeMethodChaining_SPR16489() throws Exception {",
            "FooObjectHolder foh = new FooObjectHolder();",
            "StandardEvaluationContext context = new StandardEvaluationContext();",
            "context.setRootObject(foh);",
            "// First non compiled:",
            "SpelExpression expression = (SpelExpression) parser.parseExpression(\"getFoo()?.getObject()\");",
            "assertThat(expression.getValue(context)).isEqualTo(\"hello\");",
            "foh.foo = null;",
            "assertThat(expression.getValue(context)).isNull();",
            "assertCanCompile(expression);",
            "foh.foo = new FooObject();",
            "assertThat(expression.getValue(context)).isEqualTo(\"hello\");",
            "foh.foo = null;",
            "assertThat(expression.getValue(context)).isNull();",
            "// Static method references",
            "expression = (SpelExpression) parser.parseExpression(\"#var?.methoda()\");",
            "context.setVariable(\"var\", StaticsHelper.class);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"sh\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "assertCanCompile(expression);",
            "context.setVariable(\"var\", StaticsHelper.class);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"sh\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "// Nullsafe guard on expression element evaluating to primitive/null",
            "expression = (SpelExpression) parser.parseExpression(\"#var?.intValue()\");",
            "context.setVariable(\"var\", 4);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"4\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "assertCanCompile(expression);",
            "context.setVariable(\"var\", 4);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"4\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "// Nullsafe guard on expression element evaluating to primitive/null",
            "expression = (SpelExpression) parser.parseExpression(\"#var?.booleanValue()\");",
            "context.setVariable(\"var\", false);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"false\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "assertCanCompile(expression);",
            "context.setVariable(\"var\", false);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"false\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "// Nullsafe guard on expression element evaluating to primitive/null",
            "expression = (SpelExpression) parser.parseExpression(\"#var?.booleanValue()\");",
            "context.setVariable(\"var\", true);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"true\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "assertCanCompile(expression);",
            "context.setVariable(\"var\", true);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"true\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "// Nullsafe guard on expression element evaluating to primitive/null",
            "expression = (SpelExpression) parser.parseExpression(\"#var?.longValue()\");",
            "context.setVariable(\"var\", 5L);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"5\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "assertCanCompile(expression);",
            "context.setVariable(\"var\", 5L);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"5\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "// Nullsafe guard on expression element evaluating to primitive/null",
            "expression = (SpelExpression) parser.parseExpression(\"#var?.floatValue()\");",
            "context.setVariable(\"var\", 3f);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"3.0\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "assertCanCompile(expression);",
            "context.setVariable(\"var\", 3f);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"3.0\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "// Nullsafe guard on expression element evaluating to primitive/null",
            "expression = (SpelExpression) parser.parseExpression(\"#var?.shortValue()\");",
            "context.setVariable(\"var\", (short)8);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"8\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "assertCanCompile(expression);",
            "context.setVariable(\"var\", (short)8);",
            "assertThat(expression.getValue(context).toString()).isEqualTo(\"8\");",
            "context.setVariable(\"var\", null);",
            "assertThat(expression.getValue(context)).isNull();",
            "}"
        ],
        "max_rank": -0.5000000000001608
    },
    {
        "file": "dataset/21_original.java",
        "method": "reconcileParameters",
        "new_method_name": "handle_true",
        "extracted_line_numbers": [
            34,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82
        ],
        "extracted_lines": [
            "returnDeclared = true;",
            "if (declaredParams.containsKey(paramNameToCheck) || (meta.isReturnParameter() && returnDeclared)) {",
            "SqlParameter param;",
            "if (meta.isReturnParameter()) {",
            "param = declaredParams.get(getFunctionReturnName());",
            "if (param == null && !getOutParameterNames().isEmpty()) {",
            "param = declaredParams.get(getOutParameterNames().get(0).toLowerCase());",
            "}",
            "if (param == null) {",
            "throw new InvalidDataAccessApiUsageException(",
            "\"Unable to locate declared parameter for function return value - \" +",
            "\" add an SqlOutParameter with name '\" + getFunctionReturnName() + \"'\");",
            "}",
            "else {",
            "this.actualFunctionReturnName = param.getName();",
            "}",
            "}",
            "else {",
            "param = declaredParams.get(paramNameToCheck);",
            "}",
            "if (param != null) {",
            "workParams.add(param);",
            "if (logger.isDebugEnabled()) {",
            "logger.debug(\"Using declared parameter for '\" +",
            "(paramNameToUse != null ? paramNameToUse : getFunctionReturnName()) + \"'\");",
            "}",
            "}",
            "}"
        ],
        "max_rank": 0.5373257114235588
    },
    {
        "file": "dataset/22_original.java",
        "method": "readElementValue",
        "new_method_name": "handle_new",
        "extracted_line_numbers": [
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156
        ],
        "extracted_lines": [
            "switch (classFileBuffer[currentOffset] & 0xFF) {",
            "case 'B':",
            "byte[] byteValues = new byte[numValues];",
            "for (int i = 0; i < numValues; i++) {",
            "byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);",
            "currentOffset += 3;",
            "}",
            "annotationVisitor.visit(elementName, byteValues);",
            "break;",
            "case 'Z':",
            "boolean[] booleanValues = new boolean[numValues];",
            "for (int i = 0; i < numValues; i++) {",
            "booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;",
            "currentOffset += 3;",
            "}",
            "annotationVisitor.visit(elementName, booleanValues);",
            "break;",
            "case 'S':",
            "short[] shortValues = new short[numValues];",
            "for (int i = 0; i < numValues; i++) {",
            "shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);",
            "currentOffset += 3;",
            "}",
            "annotationVisitor.visit(elementName, shortValues);",
            "break;",
            "case 'C':",
            "char[] charValues = new char[numValues];",
            "for (int i = 0; i < numValues; i++) {",
            "charValues[i] = (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);",
            "currentOffset += 3;",
            "}",
            "annotationVisitor.visit(elementName, charValues);",
            "break;",
            "case 'I':",
            "int[] intValues = new int[numValues];",
            "for (int i = 0; i < numValues; i++) {",
            "intValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);",
            "currentOffset += 3;",
            "}",
            "annotationVisitor.visit(elementName, intValues);",
            "break;",
            "case 'J':",
            "long[] longValues = new long[numValues];",
            "for (int i = 0; i < numValues; i++) {",
            "longValues[i] = readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);",
            "currentOffset += 3;",
            "}",
            "annotationVisitor.visit(elementName, longValues);",
            "break;",
            "case 'F':",
            "float[] floatValues = new float[numValues];",
            "for (int i = 0; i < numValues; i++) {",
            "floatValues[i] =",
            "Float.intBitsToFloat(",
            "readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));",
            "currentOffset += 3;",
            "}",
            "annotationVisitor.visit(elementName, floatValues);",
            "break;",
            "case 'D':",
            "double[] doubleValues = new double[numValues];",
            "for (int i = 0; i < numValues; i++) {",
            "doubleValues[i] =",
            "Double.longBitsToDouble(",
            "readLong(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]));",
            "currentOffset += 3;",
            "}",
            "annotationVisitor.visit(elementName, doubleValues);",
            "break;",
            "default:",
            "currentOffset =",
            "readElementValues(",
            "annotationVisitor.visitArray(elementName),",
            "currentOffset - 2,",
            "/* named = */ false,",
            "charBuffer);",
            "break;",
            "}"
        ],
        "max_rank": 0.3715517072596638
    },
    {
        "file": "dataset/23_original.java",
        "method": "process",
        "new_method_name": "handle_TokenKind",
        "extracted_line_numbers": [
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            181,
            182,
            183,
            184
        ],
        "extracted_lines": [
            "switch (ch) {",
            "case '+':",
            "if (isTwoCharToken(TokenKind.INC)) {",
            "pushPairToken(TokenKind.INC);",
            "}",
            "else {",
            "pushCharToken(TokenKind.PLUS);",
            "}",
            "break;",
            "case '_': // the other way to start an identifier",
            "lexIdentifier();",
            "break;",
            "case '-':",
            "if (isTwoCharToken(TokenKind.DEC)) {",
            "pushPairToken(TokenKind.DEC);",
            "}",
            "else {",
            "pushCharToken(TokenKind.MINUS);",
            "}",
            "break;",
            "case ':':",
            "pushCharToken(TokenKind.COLON);",
            "break;",
            "case '.':",
            "pushCharToken(TokenKind.DOT);",
            "break;",
            "case ',':",
            "pushCharToken(TokenKind.COMMA);",
            "break;",
            "case '*':",
            "pushCharToken(TokenKind.STAR);",
            "break;",
            "case '/':",
            "pushCharToken(TokenKind.DIV);",
            "break;",
            "case '%':",
            "pushCharToken(TokenKind.MOD);",
            "break;",
            "case '(':",
            "pushCharToken(TokenKind.LPAREN);",
            "break;",
            "case ')':",
            "pushCharToken(TokenKind.RPAREN);",
            "break;",
            "case '[':",
            "pushCharToken(TokenKind.LSQUARE);",
            "break;",
            "case '#':",
            "pushCharToken(TokenKind.HASH);",
            "break;",
            "case ']':",
            "pushCharToken(TokenKind.RSQUARE);",
            "break;",
            "case '{':",
            "pushCharToken(TokenKind.LCURLY);",
            "break;",
            "case '}':",
            "pushCharToken(TokenKind.RCURLY);",
            "break;",
            "case '@':",
            "pushCharToken(TokenKind.BEAN_REF);",
            "break;",
            "case '^':",
            "if (isTwoCharToken(TokenKind.SELECT_FIRST)) {",
            "pushPairToken(TokenKind.SELECT_FIRST);",
            "}",
            "else {",
            "pushCharToken(TokenKind.POWER);",
            "}",
            "break;",
            "case '!':",
            "if (isTwoCharToken(TokenKind.NE)) {",
            "pushPairToken(TokenKind.NE);",
            "}",
            "else if (isTwoCharToken(TokenKind.PROJECT)) {",
            "pushPairToken(TokenKind.PROJECT);",
            "}",
            "else {",
            "pushCharToken(TokenKind.NOT);",
            "}",
            "break;",
            "case '=':",
            "if (isTwoCharToken(TokenKind.EQ)) {",
            "pushPairToken(TokenKind.EQ);",
            "}",
            "else {",
            "pushCharToken(TokenKind.ASSIGN);",
            "}",
            "break;",
            "case '&':",
            "if (isTwoCharToken(TokenKind.SYMBOLIC_AND)) {",
            "pushPairToken(TokenKind.SYMBOLIC_AND);",
            "}",
            "else {",
            "pushCharToken(TokenKind.FACTORY_BEAN_REF);",
            "}",
            "break;",
            "case '|':",
            "if (!isTwoCharToken(TokenKind.SYMBOLIC_OR)) {",
            "raiseParseException(this.pos, SpelMessage.MISSING_CHARACTER, \"|\");",
            "}",
            "pushPairToken(TokenKind.SYMBOLIC_OR);",
            "break;",
            "case '?':",
            "if (isTwoCharToken(TokenKind.SELECT)) {",
            "pushPairToken(TokenKind.SELECT);",
            "}",
            "else if (isTwoCharToken(TokenKind.ELVIS)) {",
            "pushPairToken(TokenKind.ELVIS);",
            "}",
            "else if (isTwoCharToken(TokenKind.SAFE_NAVI)) {",
            "pushPairToken(TokenKind.SAFE_NAVI);",
            "}",
            "else {",
            "pushCharToken(TokenKind.QMARK);",
            "}",
            "break;",
            "case '$':",
            "if (isTwoCharToken(TokenKind.SELECT_LAST)) {",
            "pushPairToken(TokenKind.SELECT_LAST);",
            "}",
            "else {",
            "lexIdentifier();",
            "}",
            "break;",
            "case '>':",
            "if (isTwoCharToken(TokenKind.GE)) {",
            "pushPairToken(TokenKind.GE);",
            "}",
            "else {",
            "pushCharToken(TokenKind.GT);",
            "}",
            "break;",
            "case '<':",
            "if (isTwoCharToken(TokenKind.LE)) {",
            "pushPairToken(TokenKind.LE);",
            "}",
            "else {",
            "pushCharToken(TokenKind.LT);",
            "}",
            "break;",
            "case '0':",
            "case '1':",
            "case '2':",
            "case '3':",
            "case '4':",
            "case '5':",
            "case '6':",
            "case '7':",
            "case '8':",
            "case '9':",
            "lexNumericLiteral(ch == '0');",
            "break;",
            "case ' ':",
            "case '\\t':",
            "case '\\r':",
            "case '\\n':",
            "// drift over white space",
            "this.pos++;",
            "break;",
            "case '\\'':",
            "lexQuotedStringLiteral();",
            "break;",
            "case '\"':",
            "lexDoubleQuotedStringLiteral();",
            "break;",
            "case 0:",
            "// hit sentinel at end of value",
            "this.pos++;  // will take us to the end",
            "break;",
            "case '\\\\':",
            "raiseParseException(this.pos, SpelMessage.UNEXPECTED_ESCAPE_CHAR);",
            "break;",
            "default:",
            "throw new IllegalStateException(",
            "\"Unsupported character '%s' (%d) encountered at position %d in expression.\"",
            ".formatted(ch, (int) ch, (this.pos + 1)));",
            "}"
        ],
        "max_rank": -0.008763817325082565
    },
    {
        "file": "dataset/24_original.java",
        "method": "readCode",
        "new_method_name": "handle_currentOffset",
        "extracted_line_numbers": [
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            181,
            182,
            183,
            184,
            185,
            186,
            187,
            188,
            189,
            190,
            191,
            192,
            193,
            194,
            195,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            210,
            211,
            212,
            213,
            214,
            215,
            216,
            217,
            218,
            219,
            220,
            221,
            222,
            223,
            224,
            225,
            226,
            227,
            228,
            229,
            230,
            231,
            232,
            233,
            234,
            235,
            236,
            237,
            238,
            239,
            240,
            241,
            242,
            243,
            244,
            245,
            246,
            247,
            248,
            249,
            250,
            251,
            252,
            253,
            254,
            255,
            256,
            257,
            258,
            259,
            260,
            261,
            262,
            263,
            264,
            265,
            266,
            267,
            268,
            269,
            270,
            271,
            272,
            273,
            274,
            275,
            276,
            277,
            278,
            279,
            280,
            281,
            282,
            283,
            284,
            285,
            286,
            287,
            288,
            289,
            290,
            291,
            292,
            293,
            294,
            295,
            296,
            297,
            298,
            299,
            300,
            301,
            302,
            303,
            304,
            305,
            306,
            307,
            308
        ],
        "extracted_lines": [
            "while (currentOffset < bytecodeEndOffset) {",
            "final int bytecodeOffset = currentOffset - bytecodeStartOffset;",
            "final int opcode = classBuffer[currentOffset] & 0xFF;",
            "switch (opcode) {",
            "case Opcodes.NOP:",
            "case Opcodes.ACONST_NULL:",
            "case Opcodes.ICONST_M1:",
            "case Opcodes.ICONST_0:",
            "case Opcodes.ICONST_1:",
            "case Opcodes.ICONST_2:",
            "case Opcodes.ICONST_3:",
            "case Opcodes.ICONST_4:",
            "case Opcodes.ICONST_5:",
            "case Opcodes.LCONST_0:",
            "case Opcodes.LCONST_1:",
            "case Opcodes.FCONST_0:",
            "case Opcodes.FCONST_1:",
            "case Opcodes.FCONST_2:",
            "case Opcodes.DCONST_0:",
            "case Opcodes.DCONST_1:",
            "case Opcodes.IALOAD:",
            "case Opcodes.LALOAD:",
            "case Opcodes.FALOAD:",
            "case Opcodes.DALOAD:",
            "case Opcodes.AALOAD:",
            "case Opcodes.BALOAD:",
            "case Opcodes.CALOAD:",
            "case Opcodes.SALOAD:",
            "case Opcodes.IASTORE:",
            "case Opcodes.LASTORE:",
            "case Opcodes.FASTORE:",
            "case Opcodes.DASTORE:",
            "case Opcodes.AASTORE:",
            "case Opcodes.BASTORE:",
            "case Opcodes.CASTORE:",
            "case Opcodes.SASTORE:",
            "case Opcodes.POP:",
            "case Opcodes.POP2:",
            "case Opcodes.DUP:",
            "case Opcodes.DUP_X1:",
            "case Opcodes.DUP_X2:",
            "case Opcodes.DUP2:",
            "case Opcodes.DUP2_X1:",
            "case Opcodes.DUP2_X2:",
            "case Opcodes.SWAP:",
            "case Opcodes.IADD:",
            "case Opcodes.LADD:",
            "case Opcodes.FADD:",
            "case Opcodes.DADD:",
            "case Opcodes.ISUB:",
            "case Opcodes.LSUB:",
            "case Opcodes.FSUB:",
            "case Opcodes.DSUB:",
            "case Opcodes.IMUL:",
            "case Opcodes.LMUL:",
            "case Opcodes.FMUL:",
            "case Opcodes.DMUL:",
            "case Opcodes.IDIV:",
            "case Opcodes.LDIV:",
            "case Opcodes.FDIV:",
            "case Opcodes.DDIV:",
            "case Opcodes.IREM:",
            "case Opcodes.LREM:",
            "case Opcodes.FREM:",
            "case Opcodes.DREM:",
            "case Opcodes.INEG:",
            "case Opcodes.LNEG:",
            "case Opcodes.FNEG:",
            "case Opcodes.DNEG:",
            "case Opcodes.ISHL:",
            "case Opcodes.LSHL:",
            "case Opcodes.ISHR:",
            "case Opcodes.LSHR:",
            "case Opcodes.IUSHR:",
            "case Opcodes.LUSHR:",
            "case Opcodes.IAND:",
            "case Opcodes.LAND:",
            "case Opcodes.IOR:",
            "case Opcodes.LOR:",
            "case Opcodes.IXOR:",
            "case Opcodes.LXOR:",
            "case Opcodes.I2L:",
            "case Opcodes.I2F:",
            "case Opcodes.I2D:",
            "case Opcodes.L2I:",
            "case Opcodes.L2F:",
            "case Opcodes.L2D:",
            "case Opcodes.F2I:",
            "case Opcodes.F2L:",
            "case Opcodes.F2D:",
            "case Opcodes.D2I:",
            "case Opcodes.D2L:",
            "case Opcodes.D2F:",
            "case Opcodes.I2B:",
            "case Opcodes.I2C:",
            "case Opcodes.I2S:",
            "case Opcodes.LCMP:",
            "case Opcodes.FCMPL:",
            "case Opcodes.FCMPG:",
            "case Opcodes.DCMPL:",
            "case Opcodes.DCMPG:",
            "case Opcodes.IRETURN:",
            "case Opcodes.LRETURN:",
            "case Opcodes.FRETURN:",
            "case Opcodes.DRETURN:",
            "case Opcodes.ARETURN:",
            "case Opcodes.RETURN:",
            "case Opcodes.ARRAYLENGTH:",
            "case Opcodes.ATHROW:",
            "case Opcodes.MONITORENTER:",
            "case Opcodes.MONITOREXIT:",
            "case Constants.ILOAD_0:",
            "case Constants.ILOAD_1:",
            "case Constants.ILOAD_2:",
            "case Constants.ILOAD_3:",
            "case Constants.LLOAD_0:",
            "case Constants.LLOAD_1:",
            "case Constants.LLOAD_2:",
            "case Constants.LLOAD_3:",
            "case Constants.FLOAD_0:",
            "case Constants.FLOAD_1:",
            "case Constants.FLOAD_2:",
            "case Constants.FLOAD_3:",
            "case Constants.DLOAD_0:",
            "case Constants.DLOAD_1:",
            "case Constants.DLOAD_2:",
            "case Constants.DLOAD_3:",
            "case Constants.ALOAD_0:",
            "case Constants.ALOAD_1:",
            "case Constants.ALOAD_2:",
            "case Constants.ALOAD_3:",
            "case Constants.ISTORE_0:",
            "case Constants.ISTORE_1:",
            "case Constants.ISTORE_2:",
            "case Constants.ISTORE_3:",
            "case Constants.LSTORE_0:",
            "case Constants.LSTORE_1:",
            "case Constants.LSTORE_2:",
            "case Constants.LSTORE_3:",
            "case Constants.FSTORE_0:",
            "case Constants.FSTORE_1:",
            "case Constants.FSTORE_2:",
            "case Constants.FSTORE_3:",
            "case Constants.DSTORE_0:",
            "case Constants.DSTORE_1:",
            "case Constants.DSTORE_2:",
            "case Constants.DSTORE_3:",
            "case Constants.ASTORE_0:",
            "case Constants.ASTORE_1:",
            "case Constants.ASTORE_2:",
            "case Constants.ASTORE_3:",
            "currentOffset += 1;",
            "break;",
            "case Opcodes.IFEQ:",
            "case Opcodes.IFNE:",
            "case Opcodes.IFLT:",
            "case Opcodes.IFGE:",
            "case Opcodes.IFGT:",
            "case Opcodes.IFLE:",
            "case Opcodes.IF_ICMPEQ:",
            "case Opcodes.IF_ICMPNE:",
            "case Opcodes.IF_ICMPLT:",
            "case Opcodes.IF_ICMPGE:",
            "case Opcodes.IF_ICMPGT:",
            "case Opcodes.IF_ICMPLE:",
            "case Opcodes.IF_ACMPEQ:",
            "case Opcodes.IF_ACMPNE:",
            "case Opcodes.GOTO:",
            "case Opcodes.JSR:",
            "case Opcodes.IFNULL:",
            "case Opcodes.IFNONNULL:",
            "createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);",
            "currentOffset += 3;",
            "break;",
            "case Constants.ASM_IFEQ:",
            "case Constants.ASM_IFNE:",
            "case Constants.ASM_IFLT:",
            "case Constants.ASM_IFGE:",
            "case Constants.ASM_IFGT:",
            "case Constants.ASM_IFLE:",
            "case Constants.ASM_IF_ICMPEQ:",
            "case Constants.ASM_IF_ICMPNE:",
            "case Constants.ASM_IF_ICMPLT:",
            "case Constants.ASM_IF_ICMPGE:",
            "case Constants.ASM_IF_ICMPGT:",
            "case Constants.ASM_IF_ICMPLE:",
            "case Constants.ASM_IF_ACMPEQ:",
            "case Constants.ASM_IF_ACMPNE:",
            "case Constants.ASM_GOTO:",
            "case Constants.ASM_JSR:",
            "case Constants.ASM_IFNULL:",
            "case Constants.ASM_IFNONNULL:",
            "createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);",
            "currentOffset += 3;",
            "break;",
            "case Constants.GOTO_W:",
            "case Constants.JSR_W:",
            "case Constants.ASM_GOTO_W:",
            "createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);",
            "currentOffset += 5;",
            "break;",
            "case Constants.WIDE:",
            "switch (classBuffer[currentOffset + 1] & 0xFF) {",
            "case Opcodes.ILOAD:",
            "case Opcodes.FLOAD:",
            "case Opcodes.ALOAD:",
            "case Opcodes.LLOAD:",
            "case Opcodes.DLOAD:",
            "case Opcodes.ISTORE:",
            "case Opcodes.FSTORE:",
            "case Opcodes.ASTORE:",
            "case Opcodes.LSTORE:",
            "case Opcodes.DSTORE:",
            "case Opcodes.RET:",
            "currentOffset += 4;",
            "break;",
            "case Opcodes.IINC:",
            "currentOffset += 6;",
            "break;",
            "default:",
            "throw new IllegalArgumentException();",
            "}",
            "break;",
            "case Opcodes.TABLESWITCH:",
            "// Skip 0 to 3 padding bytes.",
            "currentOffset += 4 - (bytecodeOffset & 3);",
            "// Read the default label and the number of table entries.",
            "createLabel(bytecodeOffset + readInt(currentOffset), labels);",
            "int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;",
            "currentOffset += 12;",
            "// Read the table labels.",
            "while (numTableEntries-- > 0) {",
            "createLabel(bytecodeOffset + readInt(currentOffset), labels);",
            "currentOffset += 4;",
            "}",
            "break;",
            "case Opcodes.LOOKUPSWITCH:",
            "// Skip 0 to 3 padding bytes.",
            "currentOffset += 4 - (bytecodeOffset & 3);",
            "// Read the default label and the number of switch cases.",
            "createLabel(bytecodeOffset + readInt(currentOffset), labels);",
            "int numSwitchCases = readInt(currentOffset + 4);",
            "currentOffset += 8;",
            "// Read the switch labels.",
            "while (numSwitchCases-- > 0) {",
            "createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);",
            "currentOffset += 8;",
            "}",
            "break;",
            "case Opcodes.ILOAD:",
            "case Opcodes.LLOAD:",
            "case Opcodes.FLOAD:",
            "case Opcodes.DLOAD:",
            "case Opcodes.ALOAD:",
            "case Opcodes.ISTORE:",
            "case Opcodes.LSTORE:",
            "case Opcodes.FSTORE:",
            "case Opcodes.DSTORE:",
            "case Opcodes.ASTORE:",
            "case Opcodes.RET:",
            "case Opcodes.BIPUSH:",
            "case Opcodes.NEWARRAY:",
            "case Opcodes.LDC:",
            "currentOffset += 2;",
            "break;",
            "case Opcodes.SIPUSH:",
            "case Constants.LDC_W:",
            "case Constants.LDC2_W:",
            "case Opcodes.GETSTATIC:",
            "case Opcodes.PUTSTATIC:",
            "case Opcodes.GETFIELD:",
            "case Opcodes.PUTFIELD:",
            "case Opcodes.INVOKEVIRTUAL:",
            "case Opcodes.INVOKESPECIAL:",
            "case Opcodes.INVOKESTATIC:",
            "case Opcodes.NEW:",
            "case Opcodes.ANEWARRAY:",
            "case Opcodes.CHECKCAST:",
            "case Opcodes.INSTANCEOF:",
            "case Opcodes.IINC:",
            "currentOffset += 3;",
            "break;",
            "case Opcodes.INVOKEINTERFACE:",
            "case Opcodes.INVOKEDYNAMIC:",
            "currentOffset += 5;",
            "break;",
            "case Opcodes.MULTIANEWARRAY:",
            "currentOffset += 4;",
            "break;",
            "default:",
            "throw new IllegalArgumentException();",
            "}",
            "}"
        ],
        "max_rank": 0.5625925082513252
    },
    {
        "file": "dataset/25_original.java",
        "method": "testSegmentStoreComputedValue",
        "new_method_name": "handle_queuingRemovalListener",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68
        ],
        "extracted_lines": [
            "public void testSegmentStoreComputedValue() {",
            "QueuingRemovalListener<Object, Object> listener = queuingRemovalListener();",
            "LocalCache<Object, Object> map =",
            "makeLocalCache(createCacheBuilder().concurrencyLevel(1).removalListener(listener));",
            "Segment<Object, Object> segment = map.segments[0];",
            "Object key = new Object();",
            "int hash = map.hash(key);",
            "AtomicReferenceArray<ReferenceEntry<Object, Object>> table = segment.table;",
            "int index = hash & (table.length() - 1);",
            "DummyEntry<Object, Object> entry = DummyEntry.create(key, hash, null);",
            "LoadingValueReference<Object, Object> valueRef = new LoadingValueReference<>();",
            "entry.setValueReference(valueRef);",
            "// absent",
            "Object value = new Object();",
            "assertTrue(listener.isEmpty());",
            "assertEquals(0, segment.count);",
            "assertNull(segment.get(key, hash));",
            "assertTrue(segment.storeLoadedValue(key, hash, valueRef, value));",
            "assertSame(value, segment.get(key, hash));",
            "assertEquals(1, segment.count);",
            "assertTrue(listener.isEmpty());",
            "// clobbered",
            "Object value2 = new Object();",
            "assertFalse(segment.storeLoadedValue(key, hash, valueRef, value2));",
            "assertEquals(1, segment.count);",
            "assertSame(value, segment.get(key, hash));",
            "RemovalNotification<Object, Object> notification = listener.remove();",
            "assertEquals(immutableEntry(key, value2), notification);",
            "assertEquals(RemovalCause.REPLACED, notification.getCause());",
            "assertTrue(listener.isEmpty());",
            "// inactive",
            "Object value3 = new Object();",
            "map.clear();",
            "listener.clear();",
            "assertEquals(0, segment.count);",
            "table.set(index, entry);",
            "assertTrue(segment.storeLoadedValue(key, hash, valueRef, value3));",
            "assertSame(value3, segment.get(key, hash));",
            "assertEquals(1, segment.count);",
            "assertTrue(listener.isEmpty());",
            "// replaced",
            "Object value4 = new Object();",
            "DummyValueReference<Object, Object> value3Ref = DummyValueReference.create(value3);",
            "valueRef = new LoadingValueReference<>(value3Ref);",
            "entry.setValueReference(valueRef);",
            "table.set(index, entry);",
            "assertSame(value3, segment.get(key, hash));",
            "assertEquals(1, segment.count);",
            "assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));",
            "assertSame(value4, segment.get(key, hash));",
            "assertEquals(1, segment.count);",
            "notification = listener.remove();",
            "assertEquals(immutableEntry(key, value3), notification);",
            "assertEquals(RemovalCause.REPLACED, notification.getCause());",
            "assertTrue(listener.isEmpty());",
            "// collected",
            "entry.setValueReference(valueRef);",
            "table.set(index, entry);",
            "assertSame(value3, segment.get(key, hash));",
            "assertEquals(1, segment.count);",
            "value3Ref.clear();",
            "assertTrue(segment.storeLoadedValue(key, hash, valueRef, value4));",
            "assertSame(value4, segment.get(key, hash));",
            "assertEquals(1, segment.count);",
            "notification = listener.remove();",
            "assertEquals(immutableEntry(key, null), notification);",
            "assertEquals(RemovalCause.COLLECTED, notification.getCause());",
            "assertTrue(listener.isEmpty());",
            "}"
        ],
        "max_rank": -0.4197530864197794
    },
    {
        "file": "dataset/26_original.java",
        "method": "assertInvariants",
        "new_method_name": "handle_key",
        "extracted_line_numbers": [
            0,
            4,
            5,
            6,
            7,
            8,
            9,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            31
        ],
        "extracted_lines": [
            "protected final void assertInvariants(Map<K, V> map) {",
            "assertEquals(map.size() == 0, map.isEmpty());",
            "assertEquals(map.size(), keySet.size());",
            "assertEquals(keySet.size() == 0, keySet.isEmpty());",
            "assertEquals(!keySet.isEmpty(), keySet.iterator().hasNext());",
            "int expectedKeySetHash = 0;",
            "for (K key : keySet) {",
            "expectedKeySetHash += key != null ? key.hashCode() : 0;",
            "assertTrue(map.containsKey(key));",
            "assertTrue(map.containsValue(value));",
            "assertTrue(valueCollection.contains(value));",
            "assertTrue(valueCollection.containsAll(Collections.singleton(value)));",
            "assertTrue(entrySet.contains(mapEntry(key, value)));",
            "assertTrue(allowsNullKeys || (key != null));",
            "}",
            "assertEquals(expectedKeySetHash, keySet.hashCode());",
            "assertEquals(map.size(), valueCollection.size());",
            "assertEquals(valueCollection.size() == 0, valueCollection.isEmpty());",
            "assertEquals(!valueCollection.isEmpty(), valueCollection.iterator().hasNext());",
            "for (V value : valueCollection) {",
            "assertTrue(map.containsValue(value));",
            "assertTrue(allowsNullValues || (value != null));",
            "}",
            "assertEquals(map.size(), entrySet.size());",
            "assertEquals(entrySet.size() == 0, entrySet.isEmpty());",
            "assertEquals(!entrySet.isEmpty(), entrySet.iterator().hasNext());",
            "assertEntrySetNotContainsString(entrySet);",
            "if (supportsValuesHashCode) {",
            "int expectedEntrySetHash = 0;",
            "for (Entry<K, V> entry : entrySet) {",
            "assertTrue(map.containsKey(entry.getKey()));",
            "assertTrue(map.containsValue(entry.getValue()));",
            "int expectedHash =",
            "(entry.getKey() == null ? 0 : entry.getKey().hashCode())",
            "^ (entry.getValue() == null ? 0 : entry.getValue().hashCode());",
            "assertEquals(expectedHash, entry.hashCode());",
            "expectedEntrySetHash += expectedHash;",
            "}",
            "assertEquals(expectedEntrySetHash, entrySet.hashCode());",
            "assertTrue(entrySet.containsAll(new HashSet<Entry<K, V>>(entrySet)));",
            "assertTrue(entrySet.equals(new HashSet<Entry<K, V>>(entrySet)));",
            "}",
            "Object[] entrySetToArray1 = entrySet.toArray();",
            "assertEquals(map.size(), entrySetToArray1.length);",
            "assertTrue(Arrays.asList(entrySetToArray1).containsAll(entrySet));",
            "Entry<?, ?>[] entrySetToArray2 = new Entry<?, ?>[map.size() + 2];",
            "entrySetToArray2[map.size()] = mapEntry(\"foo\", 1);",
            "assertSame(entrySetToArray2, entrySet.toArray(entrySetToArray2));",
            "assertNull(entrySetToArray2[map.size()]);",
            "assertTrue(Arrays.asList(entrySetToArray2).containsAll(entrySet));",
            "Object[] valuesToArray1 = valueCollection.toArray();",
            "assertEquals(map.size(), valuesToArray1.length);",
            "assertTrue(Arrays.asList(valuesToArray1).containsAll(valueCollection));",
            "Object[] valuesToArray2 = new Object[map.size() + 2];",
            "valuesToArray2[map.size()] = \"foo\";",
            "assertSame(valuesToArray2, valueCollection.toArray(valuesToArray2));",
            "assertNull(valuesToArray2[map.size()]);",
            "assertTrue(Arrays.asList(valuesToArray2).containsAll(valueCollection));",
            "if (supportsValuesHashCode) {",
            "int expectedHash = 0;",
            "for (Entry<K, V> entry : entrySet) {",
            "expectedHash += entry.hashCode();",
            "}",
            "assertEquals(expectedHash, map.hashCode());",
            "}",
            "assertMoreInvariants(map);",
            "}",
            "boolean supportsValuesHashCode = supportsValuesHashCode(map);"
        ],
        "max_rank": -0.44710825506675417
    },
    {
        "file": "dataset/27_original.java",
        "method": "assertInvariants",
        "new_method_name": "handle_key",
        "extracted_line_numbers": [
            0,
            4,
            5,
            6,
            7,
            8,
            9,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            31
        ],
        "extracted_lines": [
            "protected final void assertInvariants(Map<K, V> map) {",
            "assertEquals(map.size() == 0, map.isEmpty());",
            "assertEquals(map.size(), keySet.size());",
            "assertEquals(keySet.size() == 0, keySet.isEmpty());",
            "assertEquals(!keySet.isEmpty(), keySet.iterator().hasNext());",
            "int expectedKeySetHash = 0;",
            "for (K key : keySet) {",
            "expectedKeySetHash += key != null ? key.hashCode() : 0;",
            "assertTrue(map.containsKey(key));",
            "assertTrue(map.containsValue(value));",
            "assertTrue(valueCollection.contains(value));",
            "assertTrue(valueCollection.containsAll(Collections.singleton(value)));",
            "assertTrue(entrySet.contains(mapEntry(key, value)));",
            "assertTrue(allowsNullKeys || (key != null));",
            "}",
            "assertEquals(expectedKeySetHash, keySet.hashCode());",
            "assertEquals(map.size(), valueCollection.size());",
            "assertEquals(valueCollection.size() == 0, valueCollection.isEmpty());",
            "assertEquals(!valueCollection.isEmpty(), valueCollection.iterator().hasNext());",
            "for (V value : valueCollection) {",
            "assertTrue(map.containsValue(value));",
            "assertTrue(allowsNullValues || (value != null));",
            "}",
            "assertEquals(map.size(), entrySet.size());",
            "assertEquals(entrySet.size() == 0, entrySet.isEmpty());",
            "assertEquals(!entrySet.isEmpty(), entrySet.iterator().hasNext());",
            "assertEntrySetNotContainsString(entrySet);",
            "if (supportsValuesHashCode) {",
            "int expectedEntrySetHash = 0;",
            "for (Entry<K, V> entry : entrySet) {",
            "assertTrue(map.containsKey(entry.getKey()));",
            "assertTrue(map.containsValue(entry.getValue()));",
            "int expectedHash =",
            "(entry.getKey() == null ? 0 : entry.getKey().hashCode())",
            "^ (entry.getValue() == null ? 0 : entry.getValue().hashCode());",
            "assertEquals(expectedHash, entry.hashCode());",
            "expectedEntrySetHash += expectedHash;",
            "}",
            "assertEquals(expectedEntrySetHash, entrySet.hashCode());",
            "assertTrue(entrySet.containsAll(new HashSet<Entry<K, V>>(entrySet)));",
            "assertTrue(entrySet.equals(new HashSet<Entry<K, V>>(entrySet)));",
            "}",
            "Object[] entrySetToArray1 = entrySet.toArray();",
            "assertEquals(map.size(), entrySetToArray1.length);",
            "assertTrue(Arrays.asList(entrySetToArray1).containsAll(entrySet));",
            "Entry<?, ?>[] entrySetToArray2 = new Entry<?, ?>[map.size() + 2];",
            "entrySetToArray2[map.size()] = mapEntry(\"foo\", 1);",
            "assertSame(entrySetToArray2, entrySet.toArray(entrySetToArray2));",
            "assertNull(entrySetToArray2[map.size()]);",
            "assertTrue(Arrays.asList(entrySetToArray2).containsAll(entrySet));",
            "Object[] valuesToArray1 = valueCollection.toArray();",
            "assertEquals(map.size(), valuesToArray1.length);",
            "assertTrue(Arrays.asList(valuesToArray1).containsAll(valueCollection));",
            "Object[] valuesToArray2 = new Object[map.size() + 2];",
            "valuesToArray2[map.size()] = \"foo\";",
            "assertSame(valuesToArray2, valueCollection.toArray(valuesToArray2));",
            "assertNull(valuesToArray2[map.size()]);",
            "assertTrue(Arrays.asList(valuesToArray2).containsAll(valueCollection));",
            "if (supportsValuesHashCode) {",
            "int expectedHash = 0;",
            "for (Entry<K, V> entry : entrySet) {",
            "expectedHash += entry.hashCode();",
            "}",
            "assertEquals(expectedHash, map.hashCode());",
            "}",
            "assertMoreInvariants(map);",
            "}",
            "boolean supportsValuesHashCode = supportsValuesHashCode(map);"
        ],
        "max_rank": -0.44710825506675417
    },
    {
        "file": "dataset/28_original.java",
        "method": "testGetIfPresent",
        "new_method_name": "handle_CacheBuilder",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65
        ],
        "extracted_lines": [
            "public void testGetIfPresent() {",
            "Cache<Object, Object> cache = CacheBuilder.newBuilder().recordStats().build();",
            "CacheStats stats = cache.stats();",
            "assertEquals(0, stats.missCount());",
            "assertEquals(0, stats.loadSuccessCount());",
            "assertEquals(0, stats.loadExceptionCount());",
            "assertEquals(0, stats.hitCount());",
            "Object one = new Object();",
            "Object two = new Object();",
            "assertNull(cache.getIfPresent(one));",
            "stats = cache.stats();",
            "assertEquals(1, stats.missCount());",
            "assertEquals(0, stats.loadSuccessCount());",
            "assertEquals(0, stats.loadExceptionCount());",
            "assertEquals(0, stats.hitCount());",
            "assertNull(cache.asMap().get(one));",
            "assertFalse(cache.asMap().containsKey(one));",
            "assertFalse(cache.asMap().containsValue(two));",
            "assertNull(cache.getIfPresent(two));",
            "stats = cache.stats();",
            "assertEquals(2, stats.missCount());",
            "assertEquals(0, stats.loadSuccessCount());",
            "assertEquals(0, stats.loadExceptionCount());",
            "assertEquals(0, stats.hitCount());",
            "assertNull(cache.asMap().get(two));",
            "assertFalse(cache.asMap().containsKey(two));",
            "assertFalse(cache.asMap().containsValue(one));",
            "cache.put(one, two);",
            "assertSame(two, cache.getIfPresent(one));",
            "stats = cache.stats();",
            "assertEquals(2, stats.missCount());",
            "assertEquals(0, stats.loadSuccessCount());",
            "assertEquals(0, stats.loadExceptionCount());",
            "assertEquals(1, stats.hitCount());",
            "assertSame(two, cache.asMap().get(one));",
            "assertTrue(cache.asMap().containsKey(one));",
            "assertTrue(cache.asMap().containsValue(two));",
            "assertNull(cache.getIfPresent(two));",
            "stats = cache.stats();",
            "assertEquals(3, stats.missCount());",
            "assertEquals(0, stats.loadSuccessCount());",
            "assertEquals(0, stats.loadExceptionCount());",
            "assertEquals(1, stats.hitCount());",
            "assertNull(cache.asMap().get(two));",
            "assertFalse(cache.asMap().containsKey(two));",
            "assertFalse(cache.asMap().containsValue(one));",
            "cache.put(two, one);",
            "assertSame(two, cache.getIfPresent(one));",
            "stats = cache.stats();",
            "assertEquals(3, stats.missCount());",
            "assertEquals(0, stats.loadSuccessCount());",
            "assertEquals(0, stats.loadExceptionCount());",
            "assertEquals(2, stats.hitCount());",
            "assertSame(two, cache.asMap().get(one));",
            "assertTrue(cache.asMap().containsKey(one));",
            "assertTrue(cache.asMap().containsValue(two));",
            "assertSame(one, cache.getIfPresent(two));",
            "stats = cache.stats();",
            "assertEquals(3, stats.missCount());",
            "assertEquals(0, stats.loadSuccessCount());",
            "assertEquals(0, stats.loadExceptionCount());",
            "assertEquals(3, stats.hitCount());",
            "assertSame(one, cache.asMap().get(two));",
            "assertTrue(cache.asMap().containsKey(two));",
            "assertTrue(cache.asMap().containsValue(one));",
            "}"
        ],
        "max_rank": -0.4513888888888477
    },
    {
        "file": "dataset/29_original.java",
        "method": "assertMultimapIsUnmodifiable",
        "new_method_name": "handle_ArrayListMultimap",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            93
        ],
        "extracted_lines": [
            "public static <K, V> void assertMultimapIsUnmodifiable(Multimap<K, V> multimap, K sampleKey, V sampleValue) {",
            "List<Entry<K, V>> originalEntries =",
            "Collections.unmodifiableList(Lists.newArrayList(multimap.entries()));",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test #clear()",
            "try {",
            "multimap.clear();",
            "fail(\"clear succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test asMap().entrySet()",
            "assertSetIsUnmodifiable(",
            "multimap.asMap().entrySet(), Maps.immutableEntry(sampleKey, sampleValueAsCollection));",
            "// Test #values()",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "assertCollectionIsUnmodifiable(values, sampleValue);",
            "}",
            "// Test #entries()",
            "assertCollectionIsUnmodifiable(multimap.entries(), Maps.immutableEntry(sampleKey, sampleValue));",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Iterate over every element in the entry set",
            "for (Entry<K, V> entry : multimap.entries()) {",
            "assertMapEntryIsUnmodifiable(entry);",
            "}",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test #keys()",
            "assertMultisetIsUnmodifiable(multimap.keys(), sampleKey);",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test #keySet()",
            "assertSetIsUnmodifiable(multimap.keySet(), sampleKey);",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test #get()",
            "assertCollectionIsUnmodifiable(multimap.get(key), sampleValue);",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "}",
            "// Test #put()",
            "try {",
            "multimap.put(sampleKey, sampleValue);",
            "fail(\"put succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test #putAll(K, Collection<V>)",
            "try {",
            "multimap.putAll(sampleKey, sampleValueAsCollection);",
            "fail(\"putAll(K, Iterable) succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test #putAll(Multimap<K, V>)",
            "Multimap<K, V> multimap2 = ArrayListMultimap.create();",
            "multimap2.put(sampleKey, sampleValue);",
            "try {",
            "multimap.putAll(multimap2);",
            "fail(\"putAll(Multimap<K, V>) succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test #remove()",
            "try {",
            "multimap.remove(sampleKey, sampleValue);",
            "fail(\"remove succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test #removeAll()",
            "try {",
            "multimap.removeAll(sampleKey);",
            "fail(\"removeAll succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test #replaceValues()",
            "try {",
            "multimap.replaceValues(sampleKey, sampleValueAsCollection);",
            "fail(\"replaceValues succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "// Test #asMap()",
            "try {",
            "multimap.asMap().remove(sampleKey);",
            "fail(\"asMap().remove() succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "try {",
            "multimap.asMap().get(presentKey).remove(sampleValue);",
            "fail(\"asMap().get().remove() succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "try {",
            "multimap.asMap().values().iterator().next().remove(sampleValue);",
            "fail(\"asMap().values().iterator().next().remove() succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "try {",
            "((Collection<?>) multimap.asMap().values().toArray()[0]).clear();",
            "fail(\"asMap().values().toArray()[0].clear() succeeded on unmodifiable multimap\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "}",
            "assertCollectionIsUnmodifiable(multimap.values(), sampleValue);",
            "assertMultimapRemainsUnmodified(multimap, originalEntries);",
            "}",
            "K presentKey = multimap.keySet().iterator().next();"
        ],
        "max_rank": -0.3394523865785664
    },
    {
        "file": "dataset/30_original.java",
        "method": "testUnmodifiableNavigableMap",
        "new_method_name": "handle_Maps",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102
        ],
        "extracted_lines": [
            "public void testUnmodifiableNavigableMap() {",
            "TreeMap<Integer, String> mod = Maps.newTreeMap();",
            "mod.put(1, \"one\");",
            "mod.put(2, \"two\");",
            "mod.put(3, \"three\");",
            "NavigableMap<Integer, String> unmod = unmodifiableNavigableMap(mod);",
            "/* unmod is a view. */",
            "mod.put(4, \"four\");",
            "assertEquals(\"four\", unmod.get(4));",
            "assertEquals(\"four\", unmod.descendingMap().get(4));",
            "ensureNotDirectlyModifiable(unmod);",
            "ensureNotDirectlyModifiable(unmod.descendingMap());",
            "ensureNotDirectlyModifiable(unmod.headMap(2, true));",
            "ensureNotDirectlyModifiable(unmod.subMap(1, true, 3, true));",
            "ensureNotDirectlyModifiable(unmod.tailMap(2, true));",
            "Collection<String> values = unmod.values();",
            "try {",
            "values.add(\"4\");",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "try {",
            "values.remove(\"four\");",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "try {",
            "values.removeAll(Collections.singleton(\"four\"));",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "try {",
            "values.retainAll(Collections.singleton(\"four\"));",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "try {",
            "Iterator<String> iterator = values.iterator();",
            "iterator.next();",
            "iterator.remove();",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "Set<Entry<Integer, String>> entries = unmod.entrySet();",
            "try {",
            "Iterator<Entry<Integer, String>> iterator = entries.iterator();",
            "iterator.next();",
            "iterator.remove();",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "Entry<Integer, String> entry = entries.iterator().next();",
            "try {",
            "entry.setValue(\"four\");",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "entry = unmod.lowerEntry(1);",
            "assertNull(entry);",
            "entry = unmod.floorEntry(2);",
            "try {",
            "entry.setValue(\"four\");",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "entry = unmod.ceilingEntry(2);",
            "try {",
            "entry.setValue(\"four\");",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "entry = unmod.lowerEntry(2);",
            "try {",
            "entry.setValue(\"four\");",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "entry = unmod.higherEntry(2);",
            "try {",
            "entry.setValue(\"four\");",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "entry = unmod.firstEntry();",
            "try {",
            "entry.setValue(\"four\");",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "entry = unmod.lastEntry();",
            "try {",
            "entry.setValue(\"four\");",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "@SuppressWarnings(\"unchecked\")",
            "Entry<Integer, String> entry2 = (Entry<Integer, String>) entries.toArray()[0];",
            "try {",
            "entry2.setValue(\"four\");",
            "fail(\"UnsupportedOperationException expected\");",
            "} catch (UnsupportedOperationException expected) {",
            "}",
            "}"
        ],
        "max_rank": -0.46285714285700197
    },
    {
        "file": "dataset/31_original.java",
        "method": "retryUpdate",
        "new_method_name": "handle_n",
        "extracted_line_numbers": [
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69
        ],
        "extracted_lines": [
            "if ((as = cells) != null && (n = as.length) > 0) {",
            "if ((a = as[(n - 1) & h]) == null) {",
            "if (busy == 0) { // Try to attach new Cell",
            "Cell r = new Cell(x); // Optimistically create",
            "if (busy == 0 && casBusy()) {",
            "boolean created = false;",
            "try { // Recheck under lock",
            "Cell[] rs;",
            "int m, j;",
            "if ((rs = cells) != null && (m = rs.length) > 0 && rs[j = (m - 1) & h] == null) {",
            "rs[j] = r;",
            "created = true;",
            "}",
            "} finally {",
            "busy = 0;",
            "}",
            "if (created) break;",
            "continue; // Slot is now non-empty",
            "}",
            "}",
            "collide = false;",
            "} else if (!wasUncontended) // CAS already known to fail",
            "wasUncontended = true; // Continue after rehash",
            "else if (a.cas(v = a.value, fn(v, x))) break;",
            "else if (n >= NCPU || cells != as) collide = false; // At max size or stale",
            "else if (!collide) collide = true;",
            "else if (busy == 0 && casBusy()) {",
            "try {",
            "if (cells == as) { // Expand table unless stale",
            "Cell[] rs = new Cell[n << 1];",
            "for (int i = 0; i < n; ++i) rs[i] = as[i];",
            "cells = rs;",
            "}",
            "} finally {",
            "busy = 0;",
            "}",
            "collide = false;",
            "continue; // Retry with expanded table",
            "}",
            "h ^= h << 13; // Rehash",
            "h ^= h >>> 17;",
            "h ^= h << 5;",
            "hc[0] = h; // Record index for next time",
            "} else if (busy == 0 && cells == as && casBusy()) {",
            "boolean init = false;",
            "try { // Initialize table",
            "if (cells == as) {",
            "Cell[] rs = new Cell[2];",
            "rs[h & 1] = new Cell(x);",
            "cells = rs;",
            "init = true;",
            "}",
            "} finally {",
            "busy = 0;",
            "}",
            "if (init) break;",
            "} else if (casBase(v = base, fn(v, x))) break; // Fall back on using base"
        ],
        "max_rank": -0.0359040310338993
    },
    {
        "file": "dataset/32_original.java",
        "method": "retryUpdate",
        "new_method_name": "handle_n",
        "extracted_line_numbers": [
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69
        ],
        "extracted_lines": [
            "if ((as = cells) != null && (n = as.length) > 0) {",
            "if ((a = as[(n - 1) & h]) == null) {",
            "if (busy == 0) { // Try to attach new Cell",
            "Cell r = new Cell(x); // Optimistically create",
            "if (busy == 0 && casBusy()) {",
            "boolean created = false;",
            "try { // Recheck under lock",
            "Cell[] rs;",
            "int m, j;",
            "if ((rs = cells) != null && (m = rs.length) > 0 && rs[j = (m - 1) & h] == null) {",
            "rs[j] = r;",
            "created = true;",
            "}",
            "} finally {",
            "busy = 0;",
            "}",
            "if (created) break;",
            "continue; // Slot is now non-empty",
            "}",
            "}",
            "collide = false;",
            "} else if (!wasUncontended) // CAS already known to fail",
            "wasUncontended = true; // Continue after rehash",
            "else if (a.cas(v = a.value, fn(v, x))) break;",
            "else if (n >= NCPU || cells != as) collide = false; // At max size or stale",
            "else if (!collide) collide = true;",
            "else if (busy == 0 && casBusy()) {",
            "try {",
            "if (cells == as) { // Expand table unless stale",
            "Cell[] rs = new Cell[n << 1];",
            "for (int i = 0; i < n; ++i) rs[i] = as[i];",
            "cells = rs;",
            "}",
            "} finally {",
            "busy = 0;",
            "}",
            "collide = false;",
            "continue; // Retry with expanded table",
            "}",
            "h ^= h << 13; // Rehash",
            "h ^= h >>> 17;",
            "h ^= h << 5;",
            "hc[0] = h; // Record index for next time",
            "} else if (busy == 0 && cells == as && casBusy()) {",
            "boolean init = false;",
            "try { // Initialize table",
            "if (cells == as) {",
            "Cell[] rs = new Cell[2];",
            "rs[h & 1] = new Cell(x);",
            "cells = rs;",
            "init = true;",
            "}",
            "} finally {",
            "busy = 0;",
            "}",
            "if (init) break;",
            "} else if (casBase(v = base, fn(v, x))) break; // Fall back on using base"
        ],
        "max_rank": -0.0359040310338993
    },
    {
        "file": "dataset/33_original.java",
        "method": "testSetFutureCancelBash",
        "new_method_name": "handle_isWindows",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134
        ],
        "extracted_lines": [
            "public void testSetFutureCancelBash() {",
            "if (isWindows()) {",
            "return; // TODO: b/136041958 - Running very slowly on Windows CI.",
            "}",
            "final int size = 50;",
            "final CyclicBarrier barrier =",
            "new CyclicBarrier(",
            "2 // for the setter threads",
            "+ size // for the listeners",
            "+ size // for the get threads,",
            "+ 1); // for the main thread",
            "final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());",
            "final AtomicReference<AbstractFuture<String>> currentFuture = Atomics.newReference();",
            "final AtomicReference<AbstractFuture<String>> setFutureFuture = Atomics.newReference();",
            "final AtomicBoolean setFutureSetSuccess = new AtomicBoolean();",
            "final AtomicBoolean setFutureCompletionSuccess = new AtomicBoolean();",
            "final AtomicBoolean cancellationSuccess = new AtomicBoolean();",
            "Runnable cancelRunnable =",
            "new Runnable() {",
            "@Override",
            "public void run() {",
            "cancellationSuccess.set(currentFuture.get().cancel(true));",
            "awaitUnchecked(barrier);",
            "}",
            "};",
            "Runnable setFutureCompleteSuccessfullyRunnable =",
            "new Runnable() {",
            "@Override",
            "public void run() {",
            "AbstractFuture<String> future = setFutureFuture.get();",
            "setFutureSetSuccess.set(currentFuture.get().setFuture(future));",
            "setFutureCompletionSuccess.set(future.set(\"hello-async-world\"));",
            "awaitUnchecked(barrier);",
            "}",
            "};",
            "final Set<Object> finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());",
            "Runnable collectResultsRunnable =",
            "new Runnable() {",
            "@Override",
            "public void run() {",
            "try {",
            "String result = Uninterruptibles.getUninterruptibly(currentFuture.get());",
            "finalResults.add(result);",
            "} catch (ExecutionException e) {",
            "finalResults.add(e.getCause());",
            "} catch (CancellationException e) {",
            "finalResults.add(CancellationException.class);",
            "} finally {",
            "awaitUnchecked(barrier);",
            "}",
            "}",
            "};",
            "Runnable collectResultsTimedGetRunnable =",
            "new Runnable() {",
            "@Override",
            "public void run() {",
            "Future<String> future = currentFuture.get();",
            "while (true) {",
            "try {",
            "String result = Uninterruptibles.getUninterruptibly(future, 0, TimeUnit.SECONDS);",
            "finalResults.add(result);",
            "break;",
            "} catch (ExecutionException e) {",
            "finalResults.add(e.getCause());",
            "break;",
            "} catch (CancellationException e) {",
            "finalResults.add(CancellationException.class);",
            "break;",
            "} catch (TimeoutException e) {",
            "// loop",
            "}",
            "}",
            "awaitUnchecked(barrier);",
            "}",
            "};",
            "List<Runnable> allTasks = new ArrayList<>();",
            "allTasks.add(cancelRunnable);",
            "allTasks.add(setFutureCompleteSuccessfullyRunnable);",
            "for (int k = 0; k < size; k++) {",
            "// For each listener we add a task that submits it to the executor directly for the blocking",
            "// get use case and another task that adds it as a listener to the future to exercise both",
            "// racing addListener calls and addListener calls completing after the future completes.",
            "final Runnable listener =",
            "k % 2 == 0 ? collectResultsRunnable : collectResultsTimedGetRunnable;",
            "allTasks.add(listener);",
            "allTasks.add(",
            "new Runnable() {",
            "@Override",
            "public void run() {",
            "currentFuture.get().addListener(listener, executor);",
            "}",
            "});",
            "}",
            "assertEquals(allTasks.size() + 1, barrier.getParties()); // sanity check",
            "for (int i = 0; i < 1000; i++) {",
            "Collections.shuffle(allTasks);",
            "final AbstractFuture<String> future = new AbstractFuture<String>() {};",
            "final AbstractFuture<String> setFuture = new AbstractFuture<String>() {};",
            "currentFuture.set(future);",
            "setFutureFuture.set(setFuture);",
            "for (Runnable task : allTasks) {",
            "executor.execute(task);",
            "}",
            "awaitUnchecked(barrier);",
            "assertThat(future.isDone()).isTrue();",
            "// inspect state and ensure it is correct!",
            "// asserts that all get calling threads received the same value",
            "Object result = Iterables.getOnlyElement(finalResults);",
            "if (result == CancellationException.class) {",
            "assertTrue(future.isCancelled());",
            "assertTrue(cancellationSuccess.get());",
            "// cancellation can interleave in 3 ways",
            "// 1. prior to setFuture",
            "// 2. after setFuture before set() on the future assigned",
            "// 3. after setFuture and set() are called but before the listener completes.",
            "if (!setFutureSetSuccess.get() || !setFutureCompletionSuccess.get()) {",
            "// If setFuture fails or set on the future fails then it must be because that future was",
            "// cancelled",
            "assertTrue(setFuture.isCancelled());",
            "assertTrue(setFuture.wasInterrupted()); // we only call cancel(true)",
            "}",
            "} else {",
            "// set on the future completed",
            "assertFalse(cancellationSuccess.get());",
            "assertTrue(setFutureSetSuccess.get());",
            "assertTrue(setFutureCompletionSuccess.get());",
            "}",
            "// reset for next iteration",
            "setFutureSetSuccess.set(false);",
            "setFutureCompletionSuccess.set(false);",
            "cancellationSuccess.set(false);",
            "finalResults.clear();",
            "}",
            "executor.shutdown();",
            "}"
        ],
        "max_rank": -0.48579545454548245
    },
    {
        "file": "dataset/34_original.java",
        "method": "testFutureBash",
        "new_method_name": "handle_isWindows",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176,
            177
        ],
        "extracted_lines": [
            "public void testFutureBash() {",
            "if (isWindows()) {",
            "return; // TODO: b/136041958 - Running very slowly on Windows CI.",
            "}",
            "final CyclicBarrier barrier =",
            "new CyclicBarrier(",
            "6 // for the setter threads",
            "+ 50 // for the listeners",
            "+ 50 // for the blocking get threads,",
            "+ 1); // for the main thread",
            "final ExecutorService executor = Executors.newFixedThreadPool(barrier.getParties());",
            "final AtomicReference<AbstractFuture<String>> currentFuture = Atomics.newReference();",
            "final AtomicInteger numSuccessfulSetCalls = new AtomicInteger();",
            "Callable<@Nullable Void> completeSuccessfullyRunnable =",
            "new Callable<@Nullable Void>() {",
            "@Override",
            "public @Nullable Void call() {",
            "if (currentFuture.get().set(\"set\")) {",
            "numSuccessfulSetCalls.incrementAndGet();",
            "}",
            "awaitUnchecked(barrier);",
            "return null;",
            "}",
            "};",
            "Callable<@Nullable Void> completeExceptionallyRunnable =",
            "new Callable<@Nullable Void>() {",
            "Exception failureCause = new Exception(\"setException\");",
            "@Override",
            "public @Nullable Void call() {",
            "if (currentFuture.get().setException(failureCause)) {",
            "numSuccessfulSetCalls.incrementAndGet();",
            "}",
            "awaitUnchecked(barrier);",
            "return null;",
            "}",
            "};",
            "Callable<@Nullable Void> cancelRunnable =",
            "new Callable<@Nullable Void>() {",
            "@Override",
            "public @Nullable Void call() {",
            "if (currentFuture.get().cancel(true)) {",
            "numSuccessfulSetCalls.incrementAndGet();",
            "}",
            "awaitUnchecked(barrier);",
            "return null;",
            "}",
            "};",
            "Callable<@Nullable Void> setFutureCompleteSuccessfullyRunnable =",
            "new Callable<@Nullable Void>() {",
            "ListenableFuture<String> future = Futures.immediateFuture(\"setFuture\");",
            "@Override",
            "public @Nullable Void call() {",
            "if (currentFuture.get().setFuture(future)) {",
            "numSuccessfulSetCalls.incrementAndGet();",
            "}",
            "awaitUnchecked(barrier);",
            "return null;",
            "}",
            "};",
            "Callable<@Nullable Void> setFutureCompleteExceptionallyRunnable =",
            "new Callable<@Nullable Void>() {",
            "ListenableFuture<String> future =",
            "Futures.immediateFailedFuture(new Exception(\"setFuture\"));",
            "@Override",
            "public @Nullable Void call() {",
            "if (currentFuture.get().setFuture(future)) {",
            "numSuccessfulSetCalls.incrementAndGet();",
            "}",
            "awaitUnchecked(barrier);",
            "return null;",
            "}",
            "};",
            "Callable<@Nullable Void> setFutureCancelRunnable =",
            "new Callable<@Nullable Void>() {",
            "ListenableFuture<String> future = Futures.immediateCancelledFuture();",
            "@Override",
            "public @Nullable Void call() {",
            "if (currentFuture.get().setFuture(future)) {",
            "numSuccessfulSetCalls.incrementAndGet();",
            "}",
            "awaitUnchecked(barrier);",
            "return null;",
            "}",
            "};",
            "final Set<Object> finalResults = Collections.synchronizedSet(Sets.newIdentityHashSet());",
            "Runnable collectResultsRunnable =",
            "new Runnable() {",
            "@Override",
            "public void run() {",
            "try {",
            "String result = Uninterruptibles.getUninterruptibly(currentFuture.get());",
            "finalResults.add(result);",
            "} catch (ExecutionException e) {",
            "finalResults.add(e.getCause());",
            "} catch (CancellationException e) {",
            "finalResults.add(CancellationException.class);",
            "} finally {",
            "awaitUnchecked(barrier);",
            "}",
            "}",
            "};",
            "Runnable collectResultsTimedGetRunnable =",
            "new Runnable() {",
            "@Override",
            "public void run() {",
            "Future<String> future = currentFuture.get();",
            "while (true) {",
            "try {",
            "String result = Uninterruptibles.getUninterruptibly(future, 0, TimeUnit.SECONDS);",
            "finalResults.add(result);",
            "break;",
            "} catch (ExecutionException e) {",
            "finalResults.add(e.getCause());",
            "break;",
            "} catch (CancellationException e) {",
            "finalResults.add(CancellationException.class);",
            "break;",
            "} catch (TimeoutException e) {",
            "// loop",
            "}",
            "}",
            "awaitUnchecked(barrier);",
            "}",
            "};",
            "List<Callable<?>> allTasks = new ArrayList<>();",
            "allTasks.add(completeSuccessfullyRunnable);",
            "allTasks.add(completeExceptionallyRunnable);",
            "allTasks.add(cancelRunnable);",
            "allTasks.add(setFutureCompleteSuccessfullyRunnable);",
            "allTasks.add(setFutureCompleteExceptionallyRunnable);",
            "allTasks.add(setFutureCancelRunnable);",
            "for (int k = 0; k < 50; k++) {",
            "// For each listener we add a task that submits it to the executor directly for the blocking",
            "// get use case and another task that adds it as a listener to the future to exercise both",
            "// racing addListener calls and addListener calls completing after the future completes.",
            "final Runnable listener =",
            "k % 2 == 0 ? collectResultsRunnable : collectResultsTimedGetRunnable;",
            "allTasks.add(Executors.callable(listener));",
            "allTasks.add(",
            "new Callable<@Nullable Void>() {",
            "@Override",
            "public @Nullable Void call() throws Exception {",
            "currentFuture.get().addListener(listener, executor);",
            "return null;",
            "}",
            "});",
            "}",
            "assertEquals(allTasks.size() + 1, barrier.getParties());",
            "for (int i = 0; i < 1000; i++) {",
            "Collections.shuffle(allTasks);",
            "final AbstractFuture<String> future = new AbstractFuture<String>() {};",
            "currentFuture.set(future);",
            "for (Callable<?> task : allTasks) {",
            "@SuppressWarnings(\"unused\") // https://errorprone.info/bugpattern/FutureReturnValueIgnored",
            "Future<?> possiblyIgnoredError = executor.submit(task);",
            "}",
            "awaitUnchecked(barrier);",
            "assertThat(future.isDone()).isTrue();",
            "// inspect state and ensure it is correct!",
            "// asserts that all get calling threads received the same value",
            "Object result = Iterables.getOnlyElement(finalResults);",
            "if (result == CancellationException.class) {",
            "assertTrue(future.isCancelled());",
            "if (future.wasInterrupted()) {",
            "// We were cancelled, it is possible that setFuture could have succeeded too.",
            "assertThat(numSuccessfulSetCalls.get()).isIn(Range.closed(1, 2));",
            "} else {",
            "assertThat(numSuccessfulSetCalls.get()).isEqualTo(1);",
            "}",
            "} else {",
            "assertThat(numSuccessfulSetCalls.get()).isEqualTo(1);",
            "}",
            "// reset for next iteration",
            "numSuccessfulSetCalls.set(0);",
            "finalResults.clear();",
            "}",
            "executor.shutdown();",
            "}"
        ],
        "max_rank": -0.48504273504277867
    },
    {
        "file": "dataset/35_original.java",
        "method": "testSmear",
        "new_method_name": null,
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106
        ],
        "extracted_lines": [
            "public void testSmear() {",
            "assertEquals(1459320713, smear(754102528));",
            "assertEquals(-160560296, smear(1234567890));",
            "assertEquals(-1017931171, smear(1));",
            "assertEquals(-1350072884, smear(-2000000000));",
            "assertEquals(-809843551, smear(2000000000));",
            "assertEquals(-309370926, smear(-1155484576));",
            "assertEquals(-1645495900, smear(-723955400));",
            "assertEquals(766424523, smear(1033096058));",
            "assertEquals(-757003149, smear(-1690734402));",
            "assertEquals(-245078984, smear(-1557280266));",
            "assertEquals(-1401957971, smear(1327362106));",
            "assertEquals(1398564061, smear(-1930858313));",
            "assertEquals(799903031, smear(502539523));",
            "assertEquals(587718043, smear(-1728529858));",
            "assertEquals(1757836855, smear(-938301587));",
            "assertEquals(1002498708, smear(1431162155));",
            "assertEquals(52905316, smear(1085665355));",
            "assertEquals(-1590037357, smear(1654374947));",
            "assertEquals(-100883544, smear(-1661998771));",
            "assertEquals(1312247346, smear(-65105105));",
            "assertEquals(-79641824, smear(-73789608));",
            "assertEquals(1739416943, smear(-518907128));",
            "assertEquals(483849880, smear(99135751));",
            "assertEquals(1797032732, smear(-252332814));",
            "assertEquals(329701497, smear(755814641));",
            "assertEquals(-1411506712, smear(1180918287));",
            "assertEquals(-132448996, smear(1344049776));",
            "assertEquals(51088191, smear(553609048));",
            "assertEquals(-322136643, smear(1580443894));",
            "assertEquals(1443704906, smear(629649304));",
            "assertEquals(-553641505, smear(-1266264776));",
            "assertEquals(996203724, smear(99807007));",
            "assertEquals(-1135153980, smear(5955764));",
            "assertEquals(-202220609, smear(-1946737912));",
            "assertEquals(1170627357, smear(39620447));",
            "assertEquals(666671983, smear(-152527805));",
            "assertEquals(830549906, smear(-1877116806));",
            "assertEquals(818272619, smear(448784075));",
            "assertEquals(743117554, smear(1086124775));",
            "assertEquals(1631368220, smear(-1609984092));",
            "assertEquals(-1030514623, smear(1227951724));",
            "assertEquals(1982371623, smear(1764356251));",
            "assertEquals(940948840, smear(64111306));",
            "assertEquals(1789753804, smear(-960731419));",
            "assertEquals(875698259, smear(-100082026));",
            "assertEquals(-1958263900, smear(-39845375));",
            "assertEquals(-1953676635, smear(-1339022546));",
            "assertEquals(1916180219, smear(2092649110));",
            "assertEquals(-1364581757, smear(-568315836));",
            "assertEquals(1918915654, smear(-1089884900));",
            "assertEquals(938102267, smear(-81839914));",
            "assertEquals(645819996, smear(-1146103148));",
            "assertEquals(-1072963524, smear(-1846688624));",
            "assertEquals(1704102819, smear(-784703072));",
            "assertEquals(-1183783966, smear(55004124));",
            "assertEquals(2097842757, smear(-691960657));",
            "assertEquals(-2139783994, smear(1770461755));",
            "assertEquals(1305227358, smear(-2032810463));",
            "assertEquals(-863362476, smear(-1177788003));",
            "assertEquals(37648593, smear(-432352882));",
            "assertEquals(1172853257, smear(-65824064));",
            "assertEquals(1811397990, smear(575267217));",
            "assertEquals(-91361736, smear(-1949367821));",
            "assertEquals(770365725, smear(356750287));",
            "assertEquals(522521211, smear(798819494));",
            "assertEquals(-37176651, smear(-92022521));",
            "assertEquals(-645245125, smear(1318001577));",
            "assertEquals(1460094042, smear(-1192467086));",
            "assertEquals(-1713924794, smear(-1412716779));",
            "assertEquals(-587126285, smear(-1223932479));",
            "assertEquals(2124902646, smear(276053035));",
            "assertEquals(1660727203, smear(615126903));",
            "assertEquals(-1851411975, smear(1542603436));",
            "assertEquals(-150321817, smear(1988388716));",
            "assertEquals(-1474601337, smear(1177882237));",
            "assertEquals(173314316, smear(19265476));",
            "assertEquals(910078796, smear(-1430871151));",
            "assertEquals(-1788757022, smear(307082914));",
            "assertEquals(-37217695, smear(-1333570194));",
            "assertEquals(-1750409108, smear(1496453452));",
            "assertEquals(-1184297296, smear(-790542135));",
            "assertEquals(1909334635, smear(1455004595));",
            "assertEquals(-626278147, smear(-1690249972));",
            "assertEquals(-1343393583, smear(-604059026));",
            "assertEquals(-72620618, smear(-290476856));",
            "assertEquals(-1721662527, smear(-122204761));",
            "assertEquals(20732956, smear(-1097539750));",
            "assertEquals(1689535747, smear(-576617062));",
            "assertEquals(-910174660, smear(-2002123957));",
            "assertEquals(-451949594, smear(-1663951485));",
            "assertEquals(-1040666441, smear(193034304));",
            "assertEquals(-568575382, smear(768747578));",
            "assertEquals(-1136854138, smear(1337360486));",
            "assertEquals(-1846303810, smear(934457803));",
            "assertEquals(560788004, smear(873612482));",
            "assertEquals(-1639693734, smear(-624972850));",
            "assertEquals(1401682479, smear(355564760));",
            "assertEquals(537840760, smear(41547336));",
            "assertEquals(822662855, smear(1781447028));",
            "assertEquals(2116379380, smear(-1321591463));",
            "assertEquals(1651021961, smear(1081281446));",
            "assertEquals(325386824, smear(-982203381));",
            "assertEquals(302543644, smear(-222544851));",
            "assertEquals(-467777650, smear(-1233998085));",
            "assertEquals(391483003, smear(-1331702554));",
            "}"
        ],
        "max_rank": -0.50000000000005
    },
    {
        "file": "dataset/36_original.java",
        "method": "validateNetwork",
        "new_method_name": "handle_node",
        "extracted_line_numbers": [
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150
        ],
        "extracted_lines": [
            "for (N node : sanityCheckSet(network.nodes())) {",
            "assertThat(nodeString).contains(node.toString());",
            "assertThat(network.adjacentNodes(node)).isEqualTo(asGraph.adjacentNodes(node));",
            "assertThat(network.predecessors(node)).isEqualTo(asGraph.predecessors(node));",
            "assertThat(network.successors(node)).isEqualTo(asGraph.successors(node));",
            "int selfLoopCount = network.edgesConnecting(node, node).size();",
            "assertThat(network.incidentEdges(node).size() + selfLoopCount)",
            ".isEqualTo(network.degree(node));",
            "if (network.isDirected()) {",
            "assertThat(network.incidentEdges(node).size() + selfLoopCount)",
            ".isEqualTo(network.inDegree(node) + network.outDegree(node));",
            "assertThat(network.inEdges(node)).hasSize(network.inDegree(node));",
            "assertThat(network.outEdges(node)).hasSize(network.outDegree(node));",
            "} else {",
            "assertThat(network.predecessors(node)).isEqualTo(network.adjacentNodes(node));",
            "assertThat(network.successors(node)).isEqualTo(network.adjacentNodes(node));",
            "assertThat(network.inEdges(node)).isEqualTo(network.incidentEdges(node));",
            "assertThat(network.outEdges(node)).isEqualTo(network.incidentEdges(node));",
            "assertThat(network.inDegree(node)).isEqualTo(network.degree(node));",
            "assertThat(network.outDegree(node)).isEqualTo(network.degree(node));",
            "}",
            "for (N otherNode : network.nodes()) {",
            "Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));",
            "switch (edgesConnecting.size()) {",
            "case 0:",
            "assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull();",
            "assertThat(network.edgeConnecting(node, otherNode).isPresent()).isFalse();",
            "assertThat(network.hasEdgeConnecting(node, otherNode)).isFalse();",
            "break;",
            "case 1:",
            "E edge = edgesConnecting.iterator().next();",
            "assertThat(network.edgeConnectingOrNull(node, otherNode)).isEqualTo(edge);",
            "assertThat(network.edgeConnecting(node, otherNode).get()).isEqualTo(edge);",
            "assertThat(network.hasEdgeConnecting(node, otherNode)).isTrue();",
            "break;",
            "default:",
            "assertThat(network.hasEdgeConnecting(node, otherNode)).isTrue();",
            "try {",
            "network.edgeConnectingOrNull(node, otherNode);",
            "fail();",
            "} catch (IllegalArgumentException expected) {",
            "}",
            "try {",
            "network.edgeConnecting(node, otherNode);",
            "fail();",
            "} catch (IllegalArgumentException expected) {",
            "}",
            "}",
            "boolean isSelfLoop = node.equals(otherNode);",
            "boolean connected = !edgesConnecting.isEmpty();",
            "if (network.isDirected() || !isSelfLoop) {",
            "assertThat(edgesConnecting)",
            ".isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode)));",
            "}",
            "if (!network.allowsParallelEdges()) {",
            "assertThat(edgesConnecting.size()).isAtMost(1);",
            "}",
            "if (!network.allowsSelfLoops() && isSelfLoop) {",
            "assertThat(connected).isFalse();",
            "}",
            "assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected);",
            "assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected);",
            "for (E edge : edgesConnecting) {",
            "assertThat(network.incidentNodes(edge))",
            ".isEqualTo(EndpointPair.of(network, node, otherNode));",
            "assertThat(network.outEdges(node)).contains(edge);",
            "assertThat(network.inEdges(otherNode)).contains(edge);",
            "}",
            "}",
            "for (N adjacentNode : sanityCheckSet(network.adjacentNodes(node))) {",
            "assertTrue(",
            "network.predecessors(node).contains(adjacentNode)",
            "|| network.successors(node).contains(adjacentNode));",
            "assertTrue(",
            "!network.edgesConnecting(node, adjacentNode).isEmpty()",
            "|| !network.edgesConnecting(adjacentNode, node).isEmpty());",
            "}",
            "for (N predecessor : sanityCheckSet(network.predecessors(node))) {",
            "assertThat(network.successors(predecessor)).contains(node);",
            "assertThat(network.edgesConnecting(predecessor, node)).isNotEmpty();",
            "}",
            "for (N successor : sanityCheckSet(network.successors(node))) {",
            "assertThat(network.predecessors(successor)).contains(node);",
            "assertThat(network.edgesConnecting(node, successor)).isNotEmpty();",
            "}",
            "for (E incidentEdge : sanityCheckSet(network.incidentEdges(node))) {",
            "assertTrue(",
            "network.inEdges(node).contains(incidentEdge)",
            "|| network.outEdges(node).contains(incidentEdge));",
            "assertThat(network.edges()).contains(incidentEdge);",
            "assertThat(network.incidentNodes(incidentEdge)).contains(node);",
            "}",
            "for (E inEdge : sanityCheckSet(network.inEdges(node))) {",
            "assertThat(network.incidentEdges(node)).contains(inEdge);",
            "assertThat(network.outEdges(network.incidentNodes(inEdge).adjacentNode(node)))",
            ".contains(inEdge);",
            "if (network.isDirected()) {",
            "assertThat(network.incidentNodes(inEdge).target()).isEqualTo(node);",
            "}",
            "}",
            "for (E outEdge : sanityCheckSet(network.outEdges(node))) {",
            "assertThat(network.incidentEdges(node)).contains(outEdge);",
            "assertThat(network.inEdges(network.incidentNodes(outEdge).adjacentNode(node)))",
            ".contains(outEdge);",
            "if (network.isDirected()) {",
            "assertThat(network.incidentNodes(outEdge).source()).isEqualTo(node);",
            "}",
            "}",
            "}"
        ],
        "max_rank": 0.09647908043177064
    },
    {
        "file": "dataset/37_original.java",
        "method": "drain",
        "new_method_name": "handle_cancelled",
        "extracted_line_numbers": [
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73
        ],
        "extracted_lines": [
            "for (;;) {",
            "if (cancelled) {",
            "clear();",
            "return;",
            "}",
            "boolean d = done;",
            "Throwable error = this.error;",
            "if (d && error != null) {",
            "if (onDropped != null) {",
            "T v = latest.getAndSet(null);",
            "if (v != null) {",
            "try {",
            "onDropped.accept(v);",
            "} catch (Throwable ex) {",
            "Exceptions.throwIfFatal(ex);",
            "error = new CompositeException(error, ex);",
            "}",
            "}",
            "} else {",
            "latest.lazySet(null);",
            "}",
            "downstream.onError(error);",
            "worker.dispose();",
            "return;",
            "}",
            "T v = latest.get();",
            "boolean empty = v == null;",
            "if (d) {",
            "if (!empty) {",
            "v = latest.getAndSet(null);",
            "if (emitLast) {",
            "downstream.onNext(v);",
            "} else {",
            "if (onDropped != null) {",
            "try {",
            "onDropped.accept(v);",
            "} catch (Throwable ex) {",
            "Exceptions.throwIfFatal(ex);",
            "downstream.onError(ex);",
            "worker.dispose();",
            "return;",
            "}",
            "}",
            "}",
            "}",
            "downstream.onComplete();",
            "worker.dispose();",
            "return;",
            "}",
            "if (empty) {",
            "if (timerFired) {",
            "timerRunning = false;",
            "timerFired = false;",
            "}",
            "break;",
            "}",
            "if (!timerRunning || timerFired) {",
            "v = latest.getAndSet(null);",
            "downstream.onNext(v);",
            "timerFired = false;",
            "timerRunning = true;",
            "worker.schedule(this, timeout, unit);",
            "} else {",
            "break;",
            "}",
            "}"
        ],
        "max_rank": -0.051450617283951804
    },
    {
        "file": "dataset/38_original.java",
        "method": "drain",
        "new_method_name": "handle_isDone",
        "extracted_line_numbers": [
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67
        ],
        "extracted_lines": [
            "if (isDone && isEmpty) {",
            "Throwable ex = error;",
            "if (ex != null) {",
            "if (window != null) {",
            "window.onError(ex);",
            "}",
            "downstream.onError(ex);",
            "} else {",
            "if (window != null) {",
            "window.onComplete();",
            "}",
            "downstream.onComplete();",
            "}",
            "cleanupResources();",
            "upstreamCancelled = true;",
            "continue;",
            "}",
            "else if (!isEmpty) {",
            "if (o == NEXT_WINDOW) {",
            "if (window != null) {",
            "window.onComplete();",
            "window = null;",
            "this.window = null;",
            "}",
            "if (downstreamCancelled.get()) {",
            "timer.dispose();",
            "} else {",
            "if (requested.get() == emitted) {",
            "upstream.cancel();",
            "cleanupResources();",
            "upstreamCancelled = true;",
            "downstream.onError(missingBackpressureMessage(emitted));",
            "} else {",
            "emitted++;",
            "windowCount.getAndIncrement();",
            "window = UnicastProcessor.create(bufferSize, windowRunnable);",
            "this.window = window;",
            "FlowableWindowSubscribeIntercept<T> intercept = new FlowableWindowSubscribeIntercept<>(window);",
            "downstream.onNext(intercept);",
            "if (intercept.tryAbandon()) {",
            "window.onComplete();",
            "}",
            "}",
            "}",
            "} else if (window != null) {",
            "@SuppressWarnings(\"unchecked\")",
            "T item = (T)o;",
            "window.onNext(item);",
            "}",
            "continue;",
            "}"
        ],
        "max_rank": 0.11124897959184082
    },
    {
        "file": "dataset/39_original.java",
        "method": "drainLoop",
        "new_method_name": "handle_requested",
        "extracted_line_numbers": [
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78
        ],
        "extracted_lines": [
            "for (;;) {",
            "long r = requested.get();",
            "long e = 0;",
            "middle:",
            "while (e != r) {",
            "if (cancelled) {",
            "cleanup();",
            "return;",
            "}",
            "Throwable ex = errors.get();",
            "if (ex != null) {",
            "cleanup();",
            "a.onError(ex);",
            "return;",
            "}",
            "boolean d = done.get() == 0;",
            "boolean empty = true;",
            "for (int i = 0; i < s.length; i++) {",
            "JoinInnerSubscriber<T> inner = s[i];",
            "SimplePlainQueue<T> q = inner.queue;",
            "if (q != null) {",
            "T v = q.poll();",
            "if (v != null) {",
            "empty = false;",
            "a.onNext(v);",
            "inner.requestOne();",
            "if (++e == r) {",
            "break middle;",
            "}",
            "}",
            "}",
            "}",
            "if (d && empty) {",
            "a.onComplete();",
            "return;",
            "}",
            "if (empty) {",
            "break;",
            "}",
            "}",
            "if (e == r) {",
            "if (cancelled) {",
            "cleanup();",
            "return;",
            "}",
            "Throwable ex = errors.get();",
            "if (ex != null) {",
            "cleanup();",
            "a.onError(ex);",
            "return;",
            "}",
            "boolean d = done.get() == 0;",
            "boolean empty = true;",
            "for (int i = 0; i < n; i++) {",
            "JoinInnerSubscriber<T> inner = s[i];",
            "SimpleQueue<T> q = inner.queue;",
            "if (q != null && !q.isEmpty()) {",
            "empty = false;",
            "break;",
            "}",
            "}",
            "if (d && empty) {",
            "a.onComplete();",
            "return;",
            "}",
            "}",
            "if (e != 0) {",
            "BackpressureHelper.produced(requested, e);",
            "}",
            "missed = addAndGet(-missed);",
            "if (missed == 0) {",
            "break;",
            "}",
            "}"
        ],
        "max_rank": -0.2058317656543862
    },
    {
        "file": "dataset/40_original.java",
        "method": "drain",
        "new_method_name": "handle_active",
        "extracted_line_numbers": [
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81
        ],
        "extracted_lines": [
            "if (!active) {",
            "boolean d = done;",
            "if (d && !veryEnd) {",
            "Throwable ex = errors.get();",
            "if (ex != null) {",
            "errors.tryTerminateConsumer(downstream);",
            "return;",
            "}",
            "}",
            "T v;",
            "try {",
            "v = queue.poll();",
            "} catch (Throwable e) {",
            "Exceptions.throwIfFatal(e);",
            "upstream.cancel();",
            "errors.tryAddThrowableOrReport(e);",
            "errors.tryTerminateConsumer(downstream);",
            "return;",
            "}",
            "boolean empty = v == null;",
            "if (d && empty) {",
            "errors.tryTerminateConsumer(downstream);",
            "return;",
            "}",
            "if (!empty) {",
            "Publisher<? extends R> p;",
            "try {",
            "p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");",
            "} catch (Throwable e) {",
            "Exceptions.throwIfFatal(e);",
            "upstream.cancel();",
            "errors.tryAddThrowableOrReport(e);",
            "errors.tryTerminateConsumer(downstream);",
            "return;",
            "}",
            "if (sourceMode != QueueSubscription.SYNC) {",
            "int c = consumed + 1;",
            "if (c == limit) {",
            "consumed = 0;",
            "upstream.request(c);",
            "} else {",
            "consumed = c;",
            "}",
            "}",
            "if (p instanceof Supplier) {",
            "@SuppressWarnings(\"unchecked\")",
            "Supplier<R> supplier = (Supplier<R>) p;",
            "R vr;",
            "try {",
            "vr = supplier.get();",
            "} catch (Throwable e) {",
            "Exceptions.throwIfFatal(e);",
            "errors.tryAddThrowableOrReport(e);",
            "if (!veryEnd) {",
            "upstream.cancel();",
            "errors.tryTerminateConsumer(downstream);",
            "return;",
            "}",
            "vr = null;",
            "}",
            "if (vr == null) {",
            "continue;",
            "}",
            "if (inner.isUnbounded()) {",
            "downstream.onNext(vr);",
            "continue;",
            "} else {",
            "active = true;",
            "inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));",
            "}",
            "} else {",
            "active = true;",
            "p.subscribe(inner);",
            "}",
            "}",
            "}"
        ],
        "max_rank": -0.009305830750731185
    },
    {
        "file": "dataset/41_original.java",
        "method": "run",
        "new_method_name": "handle_active",
        "extracted_line_numbers": [
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85
        ],
        "extracted_lines": [
            "if (!active) {",
            "boolean d = done;",
            "if (d && !veryEnd) {",
            "Throwable ex = errors.get();",
            "if (ex != null) {",
            "errors.tryTerminateConsumer(downstream);",
            "worker.dispose();",
            "return;",
            "}",
            "}",
            "T v;",
            "try {",
            "v = queue.poll();",
            "} catch (Throwable e) {",
            "Exceptions.throwIfFatal(e);",
            "upstream.cancel();",
            "errors.tryAddThrowableOrReport(e);",
            "errors.tryTerminateConsumer(downstream);",
            "worker.dispose();",
            "return;",
            "}",
            "boolean empty = v == null;",
            "if (d && empty) {",
            "errors.tryTerminateConsumer(downstream);",
            "worker.dispose();",
            "return;",
            "}",
            "if (!empty) {",
            "Publisher<? extends R> p;",
            "try {",
            "p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");",
            "} catch (Throwable e) {",
            "Exceptions.throwIfFatal(e);",
            "upstream.cancel();",
            "errors.tryAddThrowableOrReport(e);",
            "errors.tryTerminateConsumer(downstream);",
            "worker.dispose();",
            "return;",
            "}",
            "if (sourceMode != QueueSubscription.SYNC) {",
            "int c = consumed + 1;",
            "if (c == limit) {",
            "consumed = 0;",
            "upstream.request(c);",
            "} else {",
            "consumed = c;",
            "}",
            "}",
            "if (p instanceof Supplier) {",
            "@SuppressWarnings(\"unchecked\")",
            "Supplier<R> supplier = (Supplier<R>) p;",
            "R vr;",
            "try {",
            "vr = supplier.get();",
            "} catch (Throwable e) {",
            "Exceptions.throwIfFatal(e);",
            "errors.tryAddThrowableOrReport(e);",
            "if (!veryEnd) {",
            "upstream.cancel();",
            "errors.tryTerminateConsumer(downstream);",
            "worker.dispose();",
            "return;",
            "}",
            "vr = null;",
            "}",
            "if (vr == null || cancelled) {",
            "continue;",
            "}",
            "if (inner.isUnbounded()) {",
            "downstream.onNext(vr);",
            "continue;",
            "} else {",
            "active = true;",
            "inner.setSubscription(new SimpleScalarSubscription<>(vr, inner));",
            "}",
            "} else {",
            "active = true;",
            "p.subscribe(inner);",
            "}",
            "}",
            "}"
        ],
        "max_rank": -0.08046680313279014
    },
    {
        "file": "dataset/42_original.java",
        "method": "drain",
        "new_method_name": "handle_requested",
        "extracted_line_numbers": [
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94
        ],
        "extracted_lines": [
            "for (;;) {",
            "long r = requested.get();",
            "long e = 0L;",
            "while (e != r) {",
            "if (cancelled) {",
            "Arrays.fill(lists, null);",
            "return;",
            "}",
            "Throwable ex = error.get();",
            "if (ex != null) {",
            "cancelAll();",
            "Arrays.fill(lists, null);",
            "a.onError(ex);",
            "return;",
            "}",
            "T min = null;",
            "int minIndex = -1;",
            "for (int i = 0; i < n; i++) {",
            "List<T> list = lists[i];",
            "int index = indexes[i];",
            "if (list.size() != index) {",
            "if (min == null) {",
            "min = list.get(index);",
            "minIndex = i;",
            "} else {",
            "T b = list.get(index);",
            "boolean smaller;",
            "try {",
            "smaller = comparator.compare(min, b) > 0;",
            "} catch (Throwable exc) {",
            "Exceptions.throwIfFatal(exc);",
            "cancelAll();",
            "Arrays.fill(lists, null);",
            "if (!error.compareAndSet(null, exc)) {",
            "RxJavaPlugins.onError(exc);",
            "}",
            "a.onError(error.get());",
            "return;",
            "}",
            "if (smaller) {",
            "min = b;",
            "minIndex = i;",
            "}",
            "}",
            "}",
            "}",
            "if (min == null) {",
            "Arrays.fill(lists, null);",
            "a.onComplete();",
            "return;",
            "}",
            "a.onNext(min);",
            "indexes[minIndex]++;",
            "e++;",
            "}",
            "if (cancelled) {",
            "Arrays.fill(lists, null);",
            "return;",
            "}",
            "Throwable ex = error.get();",
            "if (ex != null) {",
            "cancelAll();",
            "Arrays.fill(lists, null);",
            "a.onError(ex);",
            "return;",
            "}",
            "boolean empty = true;",
            "for (int i = 0; i < n; i++) {",
            "if (indexes[i] != lists[i].size()) {",
            "empty = false;",
            "break;",
            "}",
            "}",
            "if (empty) {",
            "Arrays.fill(lists, null);",
            "a.onComplete();",
            "return;",
            "}",
            "if (e != 0) {",
            "BackpressureHelper.produced(requested, e);",
            "}",
            "missed = addAndGet(-missed);",
            "if (missed == 0) {",
            "break;",
            "}",
            "}"
        ],
        "max_rank": -0.19670997879137242
    },
    {
        "file": "dataset/43_original.java",
        "method": "onErrorWithSuper",
        "new_method_name": "get_scheduler",
        "extracted_line_numbers": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131
        ],
        "extracted_lines": [
            "try {",
            "Consumer<? super Throwable> errorHandler = new Consumer<Throwable>() {",
            "@Override",
            "public void accept(Throwable t) {",
            "throw new TestException(\"Forced failure 2\");",
            "}",
            "};",
            "RxJavaPlugins.setErrorHandler(errorHandler);",
            "Consumer<? super Throwable> errorHandler1 = RxJavaPlugins.getErrorHandler();",
            "assertSame(errorHandler, errorHandler1);",
            "Function<? super Scheduler, ? extends Scheduler> scheduler2scheduler = new Function<Scheduler, Scheduler>() {",
            "@Override",
            "public Scheduler apply(Scheduler scheduler) throws Exception {",
            "return scheduler;",
            "}",
            "};",
            "Function<? super Supplier<Scheduler>, ? extends Scheduler> callable2scheduler = new Function<Supplier<Scheduler>, Scheduler>() {",
            "@Override",
            "public Scheduler apply(Supplier<Scheduler> schedulerSupplier) throws Throwable {",
            "return schedulerSupplier.get();",
            "}",
            "};",
            "Function<? super ConnectableFlowable, ? extends ConnectableFlowable> connectableFlowable2ConnectableFlowable = new Function<ConnectableFlowable, ConnectableFlowable>() {",
            "@Override",
            "public ConnectableFlowable apply(ConnectableFlowable connectableFlowable) throws Exception {",
            "return connectableFlowable;",
            "}",
            "};",
            "Function<? super ConnectableObservable, ? extends ConnectableObservable> connectableObservable2ConnectableObservable = new Function<ConnectableObservable, ConnectableObservable>() {",
            "@Override",
            "public ConnectableObservable apply(ConnectableObservable connectableObservable) throws Exception {",
            "return connectableObservable;",
            "}",
            "};",
            "Function<? super Flowable, ? extends Flowable> flowable2Flowable = new Function<Flowable, Flowable>() {",
            "@Override",
            "public Flowable apply(Flowable flowable) throws Exception {",
            "return flowable;",
            "}",
            "};",
            "BiFunction<? super Flowable, ? super Subscriber, ? extends Subscriber> flowable2subscriber = new BiFunction<Flowable, Subscriber, Subscriber>() {",
            "@Override",
            "public Subscriber apply(Flowable flowable, Subscriber subscriber) throws Exception {",
            "return subscriber;",
            "}",
            "};",
            "Function<Maybe, Maybe> maybe2maybe = new Function<Maybe, Maybe>() {",
            "@Override",
            "public Maybe apply(Maybe maybe) throws Exception {",
            "return maybe;",
            "}",
            "};",
            "BiFunction<Maybe, MaybeObserver, MaybeObserver> maybe2observer = new BiFunction<Maybe, MaybeObserver, MaybeObserver>() {",
            "@Override",
            "public MaybeObserver apply(Maybe maybe, MaybeObserver maybeObserver) throws Exception {",
            "return maybeObserver;",
            "}",
            "};",
            "Function<Observable, Observable> observable2observable = new Function<Observable, Observable>() {",
            "@Override",
            "public Observable apply(Observable observable) throws Exception {",
            "return observable;",
            "}",
            "};",
            "BiFunction<? super Observable, ? super Observer, ? extends Observer> observable2observer = new BiFunction<Observable, Observer, Observer>() {",
            "@Override",
            "public Observer apply(Observable observable, Observer observer) throws Exception {",
            "return observer;",
            "}",
            "};",
            "Function<? super ParallelFlowable, ? extends ParallelFlowable> parallelFlowable2parallelFlowable = new Function<ParallelFlowable, ParallelFlowable>() {",
            "@Override",
            "public ParallelFlowable apply(ParallelFlowable parallelFlowable) throws Exception {",
            "return parallelFlowable;",
            "}",
            "};",
            "Function<Single, Single> single2single = new Function<Single, Single>() {",
            "@Override",
            "public Single apply(Single single) throws Exception {",
            "return single;",
            "}",
            "};",
            "BiFunction<? super Single, ? super SingleObserver, ? extends SingleObserver> single2observer = new BiFunction<Single, SingleObserver, SingleObserver>() {",
            "@Override",
            "public SingleObserver apply(Single single, SingleObserver singleObserver) throws Exception {",
            "return singleObserver;",
            "}",
            "};",
            "Function<? super Runnable, ? extends Runnable> runnable2runnable = new Function<Runnable, Runnable>() {",
            "@Override",
            "public Runnable apply(Runnable runnable) throws Exception {",
            "return runnable;",
            "}",
            "};",
            "BiFunction<? super Completable, ? super CompletableObserver, ? extends CompletableObserver> completableObserver2completableObserver = new BiFunction<Completable, CompletableObserver, CompletableObserver>() {",
            "@Override",
            "public CompletableObserver apply(Completable completable, CompletableObserver completableObserver) throws Exception {",
            "return completableObserver;",
            "}",
            "};",
            "Function<? super Completable, ? extends Completable> completable2completable = new Function<Completable, Completable>() {",
            "@Override",
            "public Completable apply(Completable completable) throws Exception {",
            "return completable;",
            "}",
            "};",
            "RxJavaPlugins.setInitComputationSchedulerHandler(callable2scheduler);",
            "RxJavaPlugins.setComputationSchedulerHandler(scheduler2scheduler);",
            "RxJavaPlugins.setIoSchedulerHandler(scheduler2scheduler);",
            "RxJavaPlugins.setNewThreadSchedulerHandler(scheduler2scheduler);",
            "RxJavaPlugins.setOnConnectableFlowableAssembly(connectableFlowable2ConnectableFlowable);",
            "RxJavaPlugins.setOnConnectableObservableAssembly(connectableObservable2ConnectableObservable);",
            "RxJavaPlugins.setOnFlowableAssembly(flowable2Flowable);",
            "RxJavaPlugins.setOnFlowableSubscribe(flowable2subscriber);",
            "RxJavaPlugins.setOnMaybeAssembly(maybe2maybe);",
            "RxJavaPlugins.setOnMaybeSubscribe(maybe2observer);",
            "RxJavaPlugins.setOnObservableAssembly(observable2observable);",
            "RxJavaPlugins.setOnObservableSubscribe(observable2observer);",
            "RxJavaPlugins.setOnParallelAssembly(parallelFlowable2parallelFlowable);",
            "RxJavaPlugins.setOnSingleAssembly(single2single);",
            "RxJavaPlugins.setOnSingleSubscribe(single2observer);",
            "RxJavaPlugins.setScheduleHandler(runnable2runnable);",
            "RxJavaPlugins.setSingleSchedulerHandler(scheduler2scheduler);",
            "RxJavaPlugins.setOnCompletableSubscribe(completableObserver2completableObserver);",
            "RxJavaPlugins.setOnCompletableAssembly(completable2completable);",
            "RxJavaPlugins.setInitSingleSchedulerHandler(callable2scheduler);",
            "RxJavaPlugins.setInitNewThreadSchedulerHandler(callable2scheduler);",
            "RxJavaPlugins.setInitIoSchedulerHandler(callable2scheduler);",
            "} finally {",
            "RxJavaPlugins.reset();",
            "}"
        ],
        "max_rank": -0.20922286289016495
    },
    {
        "file": "dataset/44_original.java",
        "method": "checkBadSourceFlowable",
        "new_method_name": "handle_new",
        "extracted_line_numbers": [
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            109,
            111
        ],
        "extracted_lines": [
            "Flowable<T> bad = new Flowable<T>() {",
            "@Override",
            "protected void subscribeActual(Subscriber<? super T> subscriber) {",
            "subscriber.onSubscribe(new BooleanSubscription());",
            "if (goodValue != null) {",
            "subscriber.onNext(goodValue);",
            "}",
            "if (error) {",
            "subscriber.onError(new TestException(\"error\"));",
            "} else {",
            "subscriber.onComplete();",
            "}",
            "if (badValue != null) {",
            "subscriber.onNext(badValue);",
            "}",
            "subscriber.onError(new TestException(\"second\"));",
            "subscriber.onComplete();",
            "}",
            "};",
            "Object o = mapper.apply(bad);",
            "if (o instanceof CompletableSource) {",
            "CompletableSource os = (CompletableSource) o;",
            "TestObserverEx<Object> to = new TestObserverEx<>();",
            "os.subscribe(to);",
            "to.awaitDone(5, TimeUnit.SECONDS);",
            "to.assertSubscribed();",
            "if (expected != null) {",
            "to.assertValues(expected);",
            "}",
            "if (error) {",
            "to.assertError(TestException.class)",
            ".assertErrorMessage(\"error\")",
            ".assertNotComplete();",
            "} else {",
            "to.assertNoErrors().assertComplete();",
            "}",
            "}",
            "} catch (AssertionError ex) {",
            "} catch (Throwable ex) {"
        ],
        "max_rank": 0.5004924118077232
    },
    {
        "file": "dataset/45_original.java",
        "method": "drain",
        "new_method_name": "handle_cancelled",
        "extracted_line_numbers": [
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109
        ],
        "extracted_lines": [
            "for (;;) {",
            "if (cancelled) {",
            "q.clear();",
            "return;",
            "}",
            "Throwable ex = error.get();",
            "if (ex != null) {",
            "q.clear();",
            "cancelAll();",
            "errorAll(a);",
            "return;",
            "}",
            "boolean d = active.get() == 0;",
            "Integer mode = (Integer)q.poll();",
            "boolean empty = mode == null;",
            "if (d && empty) {",
            "lefts.clear();",
            "rights.clear();",
            "disposables.dispose();",
            "a.onComplete();",
            "return;",
            "}",
            "if (empty) {",
            "break;",
            "}",
            "Object val = q.poll();",
            "if (mode == LEFT_VALUE) {",
            "@SuppressWarnings(\"unchecked\")",
            "TLeft left = (TLeft)val;",
            "int idx = leftIndex++;",
            "lefts.put(idx, left);",
            "ObservableSource<TLeftEnd> p;",
            "try {",
            "p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null ObservableSource\");",
            "} catch (Throwable exc) {",
            "fail(exc, a, q);",
            "return;",
            "}",
            "LeftRightEndObserver end = new LeftRightEndObserver(this, true, idx);",
            "disposables.add(end);",
            "p.subscribe(end);",
            "ex = error.get();",
            "if (ex != null) {",
            "q.clear();",
            "cancelAll();",
            "errorAll(a);",
            "return;",
            "}",
            "for (TRight right : rights.values()) {",
            "R w;",
            "try {",
            "w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");",
            "} catch (Throwable exc) {",
            "fail(exc, a, q);",
            "return;",
            "}",
            "a.onNext(w);",
            "}",
            "}",
            "else if (mode == RIGHT_VALUE) {",
            "@SuppressWarnings(\"unchecked\")",
            "TRight right = (TRight)val;",
            "int idx = rightIndex++;",
            "rights.put(idx, right);",
            "ObservableSource<TRightEnd> p;",
            "try {",
            "p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null ObservableSource\");",
            "} catch (Throwable exc) {",
            "fail(exc, a, q);",
            "return;",
            "}",
            "LeftRightEndObserver end = new LeftRightEndObserver(this, false, idx);",
            "disposables.add(end);",
            "p.subscribe(end);",
            "ex = error.get();",
            "if (ex != null) {",
            "q.clear();",
            "cancelAll();",
            "errorAll(a);",
            "return;",
            "}",
            "for (TLeft left : lefts.values()) {",
            "R w;",
            "try {",
            "w = Objects.requireNonNull(resultSelector.apply(left, right), \"The resultSelector returned a null value\");",
            "} catch (Throwable exc) {",
            "fail(exc, a, q);",
            "return;",
            "}",
            "a.onNext(w);",
            "}",
            "}",
            "else if (mode == LEFT_CLOSE) {",
            "LeftRightEndObserver end = (LeftRightEndObserver)val;",
            "lefts.remove(end.index);",
            "disposables.remove(end);",
            "} else {",
            "LeftRightEndObserver end = (LeftRightEndObserver)val;",
            "rights.remove(end.index);",
            "disposables.remove(end);",
            "}",
            "}"
        ],
        "max_rank": -0.05429920694666063
    },
    {
        "file": "dataset/46_original.java",
        "method": "drain",
        "new_method_name": "handle_cancelled",
        "extracted_line_numbers": [
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118
        ],
        "extracted_lines": [
            "for (;;) {",
            "if (cancelled) {",
            "q.clear();",
            "return;",
            "}",
            "Throwable ex = error.get();",
            "if (ex != null) {",
            "q.clear();",
            "cancelAll();",
            "errorAll(a);",
            "return;",
            "}",
            "boolean d = active.get() == 0;",
            "Integer mode = (Integer)q.poll();",
            "boolean empty = mode == null;",
            "if (d && empty) {",
            "for (UnicastProcessor<?> up : lefts.values()) {",
            "up.onComplete();",
            "}",
            "lefts.clear();",
            "rights.clear();",
            "disposables.dispose();",
            "a.onComplete();",
            "return;",
            "}",
            "if (empty) {",
            "break;",
            "}",
            "Object val = q.poll();",
            "if (mode == LEFT_VALUE) {",
            "@SuppressWarnings(\"unchecked\")",
            "TLeft left = (TLeft)val;",
            "UnicastProcessor<TRight> up = UnicastProcessor.create();",
            "int idx = leftIndex++;",
            "lefts.put(idx, up);",
            "Publisher<TLeftEnd> p;",
            "try {",
            "p = Objects.requireNonNull(leftEnd.apply(left), \"The leftEnd returned a null Publisher\");",
            "} catch (Throwable exc) {",
            "fail(exc, a, q);",
            "return;",
            "}",
            "LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, true, idx);",
            "disposables.add(end);",
            "p.subscribe(end);",
            "ex = error.get();",
            "if (ex != null) {",
            "q.clear();",
            "cancelAll();",
            "errorAll(a);",
            "return;",
            "}",
            "R w;",
            "try {",
            "w = Objects.requireNonNull(resultSelector.apply(left, up), \"The resultSelector returned a null value\");",
            "} catch (Throwable exc) {",
            "fail(exc, a, q);",
            "return;",
            "}",
            "// TODO since only left emission calls the actual, it is possible to link downstream backpressure with left's source and not error out",
            "if (requested.get() != 0L) {",
            "a.onNext(w);",
            "BackpressureHelper.produced(requested, 1);",
            "} else {",
            "fail(MissingBackpressureException.createDefault(), a, q);",
            "return;",
            "}",
            "for (TRight right : rights.values()) {",
            "up.onNext(right);",
            "}",
            "}",
            "else if (mode == RIGHT_VALUE) {",
            "@SuppressWarnings(\"unchecked\")",
            "TRight right = (TRight)val;",
            "int idx = rightIndex++;",
            "rights.put(idx, right);",
            "Publisher<TRightEnd> p;",
            "try {",
            "p = Objects.requireNonNull(rightEnd.apply(right), \"The rightEnd returned a null Publisher\");",
            "} catch (Throwable exc) {",
            "fail(exc, a, q);",
            "return;",
            "}",
            "LeftRightEndSubscriber end = new LeftRightEndSubscriber(this, false, idx);",
            "disposables.add(end);",
            "p.subscribe(end);",
            "ex = error.get();",
            "if (ex != null) {",
            "q.clear();",
            "cancelAll();",
            "errorAll(a);",
            "return;",
            "}",
            "for (UnicastProcessor<TRight> up : lefts.values()) {",
            "up.onNext(right);",
            "}",
            "}",
            "else if (mode == LEFT_CLOSE) {",
            "LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;",
            "UnicastProcessor<TRight> up = lefts.remove(end.index);",
            "disposables.remove(end);",
            "if (up != null) {",
            "up.onComplete();",
            "}",
            "}",
            "else {",
            "LeftRightEndSubscriber end = (LeftRightEndSubscriber)val;",
            "rights.remove(end.index);",
            "disposables.remove(end);",
            "}",
            "}"
        ],
        "max_rank": -0.05251019387899415
    },
    {
        "file": "dataset/47_original.java",
        "method": "checkClass",
        "new_method_name": "handle_ii",
        "extracted_line_numbers": [
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143
        ],
        "extracted_lines": [
            "for (int ii = 0; ii < baseObjects.size(); ii += 2) {",
            "Object baseObject = baseObjects.get(ii);",
            "Object tag = baseObjects.get(ii + 1);",
            "Class<?>[] params = m.getParameterTypes();",
            "int n = params.length;",
            "for (int i = 0; i < n; i++) {",
            "ParamOverride overrideEntry = null;",
            "if (overrideList != null) {",
            "for (ParamOverride e : overrideList) {",
            "if (e.index == i && Arrays.equals(e.arguments, params)) {",
            "overrideEntry = e;",
            "break;",
            "}",
            "}",
            "}",
            "Class<?> entryClass = params[i];",
            "Object[] callParams = new Object[n];",
            "for (int j = 0; j < n; j++) {",
            "if (j != i) {",
            "if (params[j].isPrimitive()) {",
            "ParamOverride overrideParam = null;",
            "if (overrideList != null) {",
            "for (ParamOverride e : overrideList) {",
            "if (e.index == j && Arrays.equals(e.arguments, params)) {",
            "overrideParam = e;",
            "break;",
            "}",
            "}",
            "}",
            "Object def = defaultPrimitive(params[j], overrideParam);",
            "if (def == null) {",
            "b.append(\"\\r\\nMissing default non-null value for \" + m + \" # \" + j + \" (\" + params[j] + \")\");",
            "fail++;",
            "continue outer;",
            "}",
            "callParams[j] = def;",
            "} else {",
            "Object def = defaultValues.get(params[j]);",
            "if (def == null) {",
            "b.append(\"\\r\\nMissing default non-null value for \" + m + \" # \" + j + \" (\" + params[j] + \")\");",
            "fail++;",
            "continue outer;",
            "}",
            "callParams[j] = def;",
            "}",
            "}",
            "}",
            "List<Object> entryValues = new ArrayList<>();",
            "if (entryClass.isPrimitive()) {",
            "addCheckPrimitive(params[i], overrideEntry, entryValues);",
            "} else {",
            "entryValues.add(null);",
            "entryValues.add(overrideEntry != null && overrideEntry.mode == ParamMode.ANY);",
            "Object def = defaultValues.get(params[i]);",
            "if (def == null) {",
            "b.append(\"\\r\\nMissing default non-null value for \" + m + \" # \" + i + \" (\" + params[i] + \")\");",
            "fail++;",
            "continue outer;",
            "}",
            "entryValues.add(def);",
            "entryValues.add(true);",
            "}",
            "for (int k = 0; k < entryValues.size(); k += 2) {",
            "Object[] callParams2 = callParams.clone();",
            "Object p = entryValues.get(k);",
            "callParams2[i] = p;",
            "boolean shouldSucceed = (Boolean)entryValues.get(k + 1);",
            "boolean success = false;",
            "Throwable error = null;",
            "errors.clear();",
            "try {",
            "m.invoke(baseObject, callParams2);",
            "success = true;",
            "} catch (Throwable ex) {",
            "// let it fail",
            "error = ex;",
            "}",
            "if (!success && error.getCause() instanceof NullPointerException) {",
            "if (!error.getCause().toString().contains(\"is null\")) {",
            "fail++;",
            "b.append(\"\\r\\nNPEs should indicate which argument failed: \" + m + \" # \" + i + \" = \" + p + \", tag = \" + tag + \", params = \" + Arrays.toString(callParams2));",
            "}",
            "}",
            "if (success != shouldSucceed) {",
            "fail++;",
            "if (shouldSucceed) {",
            "b.append(\"\\r\\nFailed (should have succeeded): \" + m + \" # \" + i + \" = \" + p + \", tag = \" + tag + \", params = \" + Arrays.toString(callParams2));",
            "b.append(\"\\r\\n    \").append(error);",
            "if (error.getCause() != null) {",
            "b.append(\"\\r\\n    \").append(error.getCause());",
            "}",
            "} else {",
            "b.append(\"\\r\\nNo failure (should have failed): \" + m + \" # \" + i + \" = \" + p + \", tag = \" + tag + \", params = \" + Arrays.toString(callParams2));",
            "}",
            "continue outer;",
            "}",
            "if (!errors.isEmpty()) {",
            "fail++;",
            "b.append(\"\\r\\nUndeliverable errors:\");",
            "for (Throwable err : errors) {",
            "b.append(\"\\r\\n    \").append(err);",
            "if (err.getCause() != null) {",
            "b.append(\"\\r\\n    \").append(err.getCause());",
            "}",
            "}",
            "continue outer;",
            "}",
            "}",
            "}",
            "}"
        ],
        "max_rank": 0.10142563969846441
    },
    {
        "file": "dataset/48_original.java",
        "method": "completableDocRefersToCompletableTypes",
        "new_method_name": "handle_m",
        "extracted_line_numbers": [
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169
        ],
        "extracted_lines": [
            "if (m.javadoc != null) {",
            "jdx = 0;",
            "for (;;) {",
            "int idx = m.javadoc.indexOf(\"onNext\", jdx);",
            "if (idx >= 0) {",
            "if (!m.signature.contains(\"Publisher\")",
            "&& !m.signature.contains(\"Flowable\")",
            "&& !m.signature.contains(\"Observable\")",
            "&& !m.signature.contains(\"ObservableSource\")) {",
            "e.append(\"java.lang.RuntimeException: Completable doc mentions onNext but no Flowable/Observable in signature\\r\\n at io.reactivex.rxjava3.core.\")",
            ".append(\"Completable.method(Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
            "}",
            "jdx = idx + 6;",
            "} else {",
            "break;",
            "}",
            "}",
            "jdx = 0;",
            "for (;;) {",
            "int idx = m.javadoc.indexOf(\"Subscriber\", jdx);",
            "if (idx >= 0) {",
            "if (!m.signature.contains(\"Publisher\")",
            "&& !m.signature.contains(\"Flowable\")",
            "&& !m.signature.contains(\"TestSubscriber\")) {",
            "e.append(\"java.lang.RuntimeException: Completable doc mentions Subscriber but not using Flowable\\r\\n at io.reactivex.rxjava3.core.\")",
            ".append(\"Completable.method(Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
            "}",
            "jdx = idx + 6;",
            "} else {",
            "break;",
            "}",
            "}",
            "jdx = 0;",
            "for (;;) {",
            "int idx = m.javadoc.indexOf(\" Subscription\", jdx);",
            "if (idx >= 0) {",
            "if (!m.signature.contains(\"Flowable\")",
            "&& !m.signature.contains(\"Publisher\")",
            ") {",
            "e.append(\"java.lang.RuntimeException: Completable doc mentions Subscription but not using Flowable\\r\\n at io.reactivex.rxjava3.core.\")",
            ".append(\"Completable.method(Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
            "}",
            "jdx = idx + 6;",
            "} else {",
            "break;",
            "}",
            "}",
            "jdx = 0;",
            "for (;;) {",
            "int idx = m.javadoc.indexOf(\"Observer\", jdx);",
            "if (idx >= 0) {",
            "if (!m.signature.contains(\"ObservableSource\")",
            "&& !m.signature.contains(\"Observable\")",
            "&& !m.signature.contains(\"TestObserver\")) {",
            "if (idx < 11 || !m.javadoc.substring(idx - 11, idx + 8).equals(\"CompletableObserver\")) {",
            "e.append(\"java.lang.RuntimeException: Completable doc mentions Observer but not using Observable\\r\\n at io.reactivex.rxjava3.core.\")",
            ".append(\"Completable.method(Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
            "}",
            "}",
            "jdx = idx + 6;",
            "} else {",
            "break;",
            "}",
            "}",
            "jdx = 0;",
            "for (;;) {",
            "int idx = m.javadoc.indexOf(\"Publisher\", jdx);",
            "if (idx >= 0) {",
            "if (!m.signature.contains(\"Publisher\")) {",
            "if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(\"(Publisher\")) {",
            "e.append(\"java.lang.RuntimeException: Completable doc mentions Publisher but not in the signature\\r\\n at io.reactivex.rxjava3.core.\")",
            ".append(\"Completable.method(Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
            "}",
            "}",
            "jdx = idx + 6;",
            "} else {",
            "break;",
            "}",
            "}",
            "jdx = 0;",
            "for (;;) {",
            "int idx = m.javadoc.indexOf(\"Flowable\", jdx);",
            "if (idx >= 0) {",
            "if (!m.signature.contains(\"Flowable\")) {",
            "Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*Flowable\");",
            "if (!p.matcher(m.javadoc).find()) {",
            "e.append(\"java.lang.RuntimeException: Completable doc mentions Flowable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\")",
            ".append(\"Completable.method(Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
            "}",
            "}",
            "jdx = idx + 6;",
            "} else {",
            "break;",
            "}",
            "}",
            "jdx = 0;",
            "for (;;) {",
            "int idx = m.javadoc.indexOf(\"Single\", jdx);",
            "if (idx >= 0) {",
            "if (!m.signature.contains(\"Single\")) {",
            "Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*Single\");",
            "if (!p.matcher(m.javadoc).find()) {",
            "e.append(\"java.lang.RuntimeException: Completable doc mentions Single but not in the signature\\r\\n at io.reactivex.rxjava3.core.\")",
            ".append(\"Completable.method(Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
            "}",
            "}",
            "jdx = idx + 6;",
            "} else {",
            "break;",
            "}",
            "}",
            "jdx = 0;",
            "for (;;) {",
            "int idx = m.javadoc.indexOf(\"SingleSource\", jdx);",
            "if (idx >= 0) {",
            "if (!m.signature.contains(\"SingleSource\")) {",
            "Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*SingleSource\");",
            "if (!p.matcher(m.javadoc).find()) {",
            "e.append(\"java.lang.RuntimeException: Completable doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\")",
            ".append(\"Completable.method(Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
            "}",
            "}",
            "jdx = idx + 6;",
            "} else {",
            "break;",
            "}",
            "}",
            "jdx = 0;",
            "for (;;) {",
            "int idx = m.javadoc.indexOf(\" Observable\", jdx);",
            "if (idx >= 0) {",
            "if (!m.signature.contains(\"Observable\")) {",
            "Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*Observable\");",
            "if (!p.matcher(m.javadoc).find()) {",
            "e.append(\"java.lang.RuntimeException: Completable doc mentions Observable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\")",
            ".append(\"Completable.method(Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
            "}",
            "}",
            "jdx = idx + 6;",
            "} else {",
            "break;",
            "}",
            "}",
            "jdx = 0;",
            "for (;;) {",
            "int idx = m.javadoc.indexOf(\"ObservableSource\", jdx);",
            "if (idx >= 0) {",
            "if (!m.signature.contains(\"ObservableSource\")) {",
            "Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*ObservableSource\");",
            "if (!p.matcher(m.javadoc).find()) {",
            "e.append(\"java.lang.RuntimeException: Completable doc mentions ObservableSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\")",
            ".append(\"Completable.method(Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
            "}",
            "}",
            "jdx = idx + 6;",
            "} else {",
            "break;",
            "}",
            "}",
            "checkAtReturnAndSignatureMatch(\"Completable\", m, e, \"Flowable\", \"Observable\", \"Maybe\", \"Single\", \"Completable\", \"Disposable\", \"Iterable\", \"Stream\", \"Future\", \"CompletionStage\");",
            "aOrAn(e, m, \"Completable\");",
            "missingClosingDD(e, m, \"Completable\", \"io.reactivex.rxjava3.core\");",
            "backpressureMentionedWithoutAnnotation(e, m, \"Completable\");",
            "}"
        ],
        "max_rank": -0.13310091040185412
    },
    {
        "file": "dataset/49_original.java",
        "method": "testAtSpaceBoundaries",
        "new_method_name": "handle_b",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72
        ],
        "extracted_lines": [
            "public void testAtSpaceBoundaries() throws CodeUnitInsertionException, IOException {",
            "assertUndefinedWithAddr(b.addr(-0x0001), manager.codeUnits().getBefore(0, b.data(0x0000)));",
            "assertUndefinedWithAddr(b.data(0x0000), manager.codeUnits().getAfter(0, b.addr(-0x0001)));",
            "assertUndefinedWithAddr(b.addr(-0x0001), manager.data().getBefore(0, b.data(0x0000)));",
            "assertUndefinedWithAddr(b.data(0x0000), manager.data().getAfter(0, b.addr(-0x0001)));",
            "assertNull(manager.definedUnits().getBefore(0, b.data(0x0000)));",
            "assertNull(manager.definedUnits().getAfter(0, b.addr(-0x0001)));",
            "assertNull(manager.instructions().getBefore(0, b.data(0x0000)));",
            "assertNull(manager.instructions().getAfter(0, b.addr(-0x0001)));",
            "assertNull(manager.definedData().getBefore(0, b.data(0x0000)));",
            "assertNull(manager.definedData().getAfter(0, b.addr(-0x0001)));",
            "assertUndefinedWithAddr(b.addr(-0x0001),",
            "manager.undefinedData().getBefore(0, b.data(0x0000)));",
            "assertUndefinedWithAddr(b.data(0x0000),",
            "manager.undefinedData().getAfter(0, b.addr(-0x0001)));",
            "TraceInstruction iCodeMax;",
            "try (Transaction tx = b.startTransaction()) {",
            "iCodeMax = b.addInstruction(0, b.addr(-0x0002), b.host, b.buf(0xf4, 0));",
            "}",
            "assertEquals(iCodeMax, manager.codeUnits().getBefore(0, b.data(0x0000)));",
            "assertEquals(iCodeMax, manager.definedUnits().getFloor(0, b.data(0x4000)));",
            "assertEquals(iCodeMax, manager.definedUnits().getBefore(0, b.data(0x0000)));",
            "assertEquals(iCodeMax, manager.instructions().getFloor(0, b.data(0x4000)));",
            "assertEquals(iCodeMax, manager.instructions().getBefore(0, b.data(0x0000)));",
            "assertNull(manager.definedData().getFloor(0, b.data(0x4000)));",
            "assertUndefinedWithAddr(b.addr(-0x0003),",
            "manager.undefinedData().getBefore(0, b.data(0x0000)));",
            "assertUndefinedWithAddr(b.data(0x0000),",
            "manager.undefinedData().getCeiling(0, b.addr(-0x0002)));",
            "b.trace.undo();",
            "TraceData dDataMin;",
            "try (Transaction tx = b.startTransaction()) {",
            "dDataMin = b.addData(0, b.data(0x0000), IntegerDataType.dataType, b.buf(1, 2, 3, 4));",
            "}",
            "assertEquals(dDataMin, manager.codeUnits().getAfter(0, b.addr(-0x0001)));",
            "assertEquals(dDataMin, manager.definedUnits().getCeiling(0, b.addr(0x4000)));",
            "assertEquals(dDataMin, manager.definedUnits().getAfter(0, b.addr(-0x0001)));",
            "assertNull(manager.instructions().getCeiling(0, b.addr(0x4000)));",
            "assertEquals(dDataMin, manager.definedData().getCeiling(0, b.addr(0x4000)));",
            "assertEquals(dDataMin, manager.definedData().getAfter(0, b.addr(-0x0001)));",
            "assertUndefinedWithAddr(b.data(0x0004),",
            "manager.undefinedData().getAfter(0, b.addr(-0x0001)));",
            "assertUndefinedWithAddr(b.addr(-0x0001),",
            "manager.undefinedData().getFloor(0, b.data(0x0003)));",
            "try (Transaction tx = b.startTransaction()) {",
            "iCodeMax = b.addInstruction(0, b.addr(-0x0002), b.host, b.buf(0xf4, 0));",
            "}",
            "TraceData uCodePre = manager.undefinedData().getAt(0, b.addr(-0x0003));",
            "assertUndefinedWithAddr(b.addr(-0x0003), uCodePre);",
            "TraceData uDataPost = manager.undefinedData().getAt(0, b.data(0x0004));",
            "assertUndefinedWithAddr(b.data(0x0004), uDataPost);",
            "assertEquals(List.of(uCodePre, iCodeMax, dDataMin, uDataPost),",
            "list(manager.codeUnits().get(0, b.addr(-0x0003), b.data(0x0004), true)));",
            "assertEquals(List.of(uDataPost, dDataMin, iCodeMax, uCodePre),",
            "list(manager.codeUnits().get(0, b.addr(-0x0003), b.data(0x0004), false)));",
            "// Also test single space at those boundaries (should get nothing)",
            "DBTraceCodeSpace dataSpace = manager.getForSpace(b.language.getDefaultDataSpace(), false);",
            "assertNotNull(dataSpace);",
            "assertNull(dataSpace.codeUnits().getBefore(0, b.data(0x0000)));",
            "assertNull(dataSpace.data().getBefore(0, b.data(0x0000)));",
            "assertNull(dataSpace.definedUnits().getBefore(0, b.data(0x0000)));",
            "assertNull(dataSpace.instructions().getBefore(0, b.data(0x0000)));",
            "assertNull(dataSpace.definedData().getBefore(0, b.data(0x0000)));",
            "assertNull(dataSpace.undefinedData().getBefore(0, b.data(0x0000)));",
            "DBTraceCodeSpace codeSpace = manager.getForSpace(b.language.getDefaultSpace(), false);",
            "assertNotNull(codeSpace);",
            "assertNull(codeSpace.codeUnits().getAfter(0, b.addr(-0x0001)));",
            "assertNull(codeSpace.data().getAfter(0, b.addr(-0x0001)));",
            "assertNull(codeSpace.definedUnits().getAfter(0, b.addr(-0x0001)));",
            "assertNull(codeSpace.instructions().getAfter(0, b.addr(-0x0001)));",
            "assertNull(codeSpace.definedData().getAfter(0, b.addr(-0x0001)));",
            "assertNull(codeSpace.undefinedData().getAfter(0, b.addr(-0x0001)));",
            "}"
        ],
        "max_rank": -0.4999999999999689
    },
    {
        "file": "dataset/50_original.java",
        "method": "disassembleRegion",
        "new_method_name": "handle_lastPseudoInstructionBlock",
        "extracted_line_numbers": [
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28
        ],
        "extracted_lines": [
            "if (lastPseudoInstructionBlock != null) {",
            "pseudoInstruction = lastPseudoInstructionBlock.getInstructionAt(nextAddr);",
            "if (pseudoInstruction == null) {",
            "error = lastPseudoInstructionBlock.getInstructionConflict();",
            "if (error != null && !nextAddr.equals(error.getInstructionAddress())) {",
            "error = null;",
            "}",
            "}",
            "}",
            "if (pseudoInstruction == null && error == null) {"
        ],
        "max_rank": 0.5013659605551398
    },
    {
        "file": "dataset/51_original.java",
        "method": "testVersionLocalTruncationUpdate",
        "new_method_name": "handle_new",
        "extracted_line_numbers": [
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70
        ],
        "extracted_lines": [
            "try {",
            "// Simulate checkout of version-1 (new private instance)",
            "privateTestFileMgr = new PrivateTestFileMgr(2);",
            "vbf = new LocalManagedBufferFile(versionedTestFileMgr, 1, -1);",
            "pbf = new LocalManagedBufferFile(vbf.getBufferSize(), privateTestFileMgr, PRIVATE);",
            "LocalBufferFile.copyFile(vbf, pbf, null, TaskMonitor.DUMMY);",
            "vbf.close();",
            "vbf = null;",
            "pbf.close();",
            "pbf = null;",
            "//",
            "// Modify private checkout file (with different changes than version-2 contains)",
            "// Truncation case: private file is longer than version-2 and must get truncated",
            "//",
            "// Open private file for version update",
            "pbf = new LocalManagedBufferFile(privateTestFileMgr, true, -1, PRIVATE);",
            "saveFile = (LocalManagedBufferFile) pbf.getSaveFile();",
            "assertNotNull(saveFile);",
            "// Write application level change file",
            "writeAppChangeFile(pbf);",
            "// Modify save file",
            "byte[] data = new byte[BUFFER_SIZE];",
            "DataBuffer buf = new DataBuffer(data);",
            "Arrays.fill(data, (byte) 0xf2);// modified empty buffer",
            "buf.setId(12);",
            "saveFile.put(buf, 2);",
            "Arrays.fill(data, (byte) 0xf3);// new buffer",
            "buf.setId(13);",
            "saveFile.put(buf, 3);",
            "Arrays.fill(data, (byte) 0xf4);// new buffer - added to free list below",
            "buf.setId(14);",
            "saveFile.put(buf, 4);",
            "Arrays.fill(data, (byte) 0xf5);// new buffer",
            "buf.setId(13);",
            "saveFile.put(buf, 5);",
            "// Set free ID list for output file",
            "int[] newFreeList = new int[] { 0, 4, 6 };",
            "saveFile.setFreeIndexes(newFreeList);",
            "// Copy/Set file parameters",
            "saveFile.setParameter(\"TestParm1\", 0x320);",
            "saveFile.setParameter(\"TestParm2\", 0x540);",
            "saveFile.setParameter(\"TestParm3\", 0x670);",
            "pbf.saveCompleted(true);",
            "pbf.close();",
            "pbf = null;",
            "saveFile.close();",
            "saveFile = null;",
            "//",
            "// Perform update of private file to replicate version-2",
            "//",
            "// Open version-2",
            "vbf = new LocalManagedBufferFile(versionedTestFileMgr, false, -1, VERSIONED);",
            "// Reopen private file",
            "pbf = new LocalManagedBufferFile(privateTestFileMgr, true, -1, -1);",
            "// Perform quick update of private file to replicate version-2 file - should wipe-out all private changes",
            "pbf.updateFrom(vbf, 1, TaskMonitor.DUMMY);",
            "pbf.close();",
            "pbf = null;",
            "// Reopen to pickup update modifications",
            "pbf = new LocalManagedBufferFile(privateTestFileMgr, true, -1, -1);",
            "checkSameContent(vbf, pbf);",
            "vbf.close();",
            "vbf = null;",
            "pbf.close();",
            "pbf = null;",
            "}"
        ],
        "max_rank": 0.39403470298558124
    },
    {
        "file": "dataset/52_original.java",
        "method": "parseByte",
        "new_method_name": "handle_byte",
        "extracted_line_numbers": [
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69
        ],
        "extracted_lines": [
            "switch (c) {",
            "case '0':",
            "b = (byte) (',');",
            "break;",
            "case '1':",
            "b = (byte) ('/');",
            "break;",
            "case '2':",
            "b = (byte) ('\\\\');",
            "break;",
            "case '3':",
            "b = (byte) (':');",
            "break;",
            "case '4':",
            "b = (byte) ('.');",
            "break;",
            "case '5':",
            "b = (byte) (' ');",
            "break;",
            "case '6':",
            "b = (byte) ('\\n');",
            "break;",
            "case '7':",
            "b = (byte) ('\\t');",
            "break;",
            "case '8':",
            "b = (byte) ('\\'');",
            "break;",
            "case '9':",
            "b = (byte) ('-');",
            "break;",
            "case '$':",
            "if ((dmang.peek() == MDMang.DONE)) {",
            "throw new MDException(\"MDString parse error: not enough data\");",
            "}",
            "c = dmang.getAndIncrement();",
            "if (c < 'A' || c > ('A' + 15)) {",
            "throw new MDException(\"MDString parse error: invalid hex code:\" + c);",
            "}",
            "b = (byte) ((c - 'A') << 4);",
            "if ((dmang.peek() == MDMang.DONE)) {",
            "throw new MDException(\"MDString parse error: not enough data\");",
            "}",
            "c = dmang.getAndIncrement();",
            "if (c < 'A' || c > ('A' + 15)) {",
            "throw new MDException(\"MDString parse error: invalid hex code:\" + c);",
            "}",
            "b |= (byte) (c - 'A');",
            "break;",
            "default:",
            "throw new MDException(\"MDString parse error: invalid code2: \" + c);",
            "}"
        ],
        "max_rank": 0.19268355320070546
    },
    {
        "file": "dataset/53_original.java",
        "method": "grabFromFunction",
        "new_method_name": "handle_dbFunction",
        "extracted_line_numbers": [
            48,
            54,
            73,
            75,
            77
        ],
        "extracted_lines": [
            "Parameter[] p = dbFunction.getParameters();",
            "Parameter var = p[i];",
            "Symbol symbol = var.getSymbol();",
            "id = symbol.getID();",
            "HighSymbol paramSymbol = newMappedSymbol(id, name, dt, storage, resAddr, i);"
        ],
        "max_rank": 0.4549230815455914
    },
    {
        "file": "dataset/54_original.java",
        "method": "processTag",
        "new_method_name": "handle_c",
        "extracted_line_numbers": [
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61
        ],
        "extracted_lines": [
            "switch (mode) {",
            "case READING_ATTR:",
            "if (c == '=') {",
            "attr = buf.toString().toLowerCase();",
            "mode = LOOKING_FOR_VALUE;",
            "break;",
            "}",
            "if (c == ' ' || c == '\\t') {",
            "attr = buf.toString().toLowerCase();",
            "map.put(attr, null);",
            "mode = LOOKING_FOR_NEXT_ATTR;",
            "break;",
            "}",
            "buf.append(c);",
            "break;",
            "case LOOKING_FOR_VALUE:",
            "if (c == ' ' || c == '\\t') {",
            "// we now allow spaces after the '=', but before the '\"' starts, as our",
            "// tidy tool breaks on the '=' sometimes",
            "//map.put(attr, null);",
            "//mode = LOOKING_FOR_NEXT_ATTR;",
            "break;",
            "}",
            "if (c == '\"' || c == '\\'') {",
            "buf = new StringBuffer();",
            "mode = READING_VALUE;",
            "term = c;",
            "break;",
            "}",
            "buf = new StringBuffer();",
            "buf.append(c);",
            "mode = READING_VALUE;",
            "term = 0;",
            "break;",
            "case READING_VALUE:",
            "if (c == term || (term == 0 && (c == ' ' || c == '\\t'))) {",
            "map.put(attr, buf.toString());",
            "mode = LOOKING_FOR_NEXT_ATTR;",
            "break;",
            "}",
            "buf.append(c);",
            "break;",
            "default:",
            "if (c == ' ' || c == '\\t') {",
            "continue;",
            "}",
            "buf = new StringBuffer();",
            "buf.append(c);",
            "mode = READING_ATTR;",
            "}"
        ],
        "max_rank": 0.239397542607995
    },
    {
        "file": "dataset/55_original.java",
        "method": "flowConstants",
        "new_method_name": "get_false",
        "extracted_line_numbers": [
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            83,
            73,
            75
        ],
        "extracted_lines": [
            "if (ftype.isComputed() && ftype.isJump()) {",
            "Varnode pcVal = context.getRegisterVarnodeValue(",
            "program.getLanguage().getProgramCounter());",
            "if (pcVal != null) {",
            "if (isLinkRegister(context, pcVal) &&",
            "!instr.getFlowType().isTerminal()) {",
            "// need to set the return override",
            "instr.setFlowOverride(FlowOverride.RETURN);",
            "// get rid of any references that might have been put on from",
            "// bad flows",
            "ReferenceManager refMgr = program.getReferenceManager();",
            "refMgr.removeAllReferencesFrom(instr.getAddress());",
            "}",
            "}",
            "// if LR is a constant and is set right after this, this is a call",
            "Varnode lrVal = context.getRegisterVarnodeValue(lrRegister);",
            "if (lrVal != null) {",
            "if (context.isConstant(lrVal)) {",
            "long target = lrVal.getAddress().getOffset();",
            "Address addr = instr.getMaxAddress().add(1);",
            "if (target == addr.getOffset() && !instr.getFlowType().isCall()) {",
            "// if there are is a read reference there as well,",
            "//  then this is really a branch, not a call",
            "if (hasDataReferenceTo(program, addr)) {",
            "return false;",
            "}",
            "// if flow already over-ridden don't override again",
            "if (instr.getFlowOverride() != FlowOverride.NONE) {",
            "return false;",
            "}",
            "instr.setFlowOverride(FlowOverride.CALL);",
            "// need to trigger disassembly below! if not already",
            "doArmThumbDisassembly(program, instr, context, addr,",
            "instr.getFlowType(), false, monitor);",
            "// need to trigger re-function creation!",
            "Function f = program.getFunctionManager().getFunctionContaining(",
            "instr.getMinAddress());",
            "if (f != null) {",
            "try {",
            "CreateFunctionCmd.fixupFunctionBody(program, f,",
            "monitor);",
            "}",
            "catch (CancelledException e) {",
            "return true;",
            "}",
            "//AutoAnalysisManager.getAnalysisManager(program).functionDefined(",
            "//\tfunc.getBody());",
            "}",
            "}",
            "}",
            "}",
            "}",
            "return (pcVal.isRegister() &&",
            "ReferenceIterator referencesTo = refMgr.getReferencesTo(addr);",
            "Reference reference = referencesTo.next();"
        ],
        "max_rank": 0.465026483741141
    },
    {
        "file": "dataset/56_original.java",
        "method": "updateFunction",
        "new_method_name": "handle_thunkedFunction",
        "extracted_line_numbers": [
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135
        ],
        "extracted_lines": [
            "try {",
            "startUpdate();",
            "checkDeleted();",
            "if (thunkedFunction != null) {",
            "thunkedFunction.updateFunction(callingConvention, returnVar, newParams, updateType,",
            "force, source);",
            "return;",
            "}",
            "loadVariables();",
            "purgeBadVariables();",
            "boolean useCustomStorage = (updateType == FunctionUpdateType.CUSTOM_STORAGE);",
            "setCustomVariableStorage(useCustomStorage);",
            "if (callingConvention != null) {",
            "setCallingConvention(callingConvention);",
            "}",
            "callingConvention = getCallingConventionName();",
            "if (returnVar == null) {",
            "returnVar = returnParam;",
            "}",
            "else if (returnVar.isUniqueVariable()) {",
            "throw new IllegalArgumentException(",
            "\"Invalid return specified: UniqueVariable not allowed\");",
            "}",
            "DataType returnType = returnVar.getDataType();",
            "VariableStorage returnStorage = returnVar.getVariableStorage();",
            "if (!useCustomStorage) {",
            "// remove auto params and forced-indirect return",
            "newParams = new ArrayList<Variable>(newParams); // copy for edit",
            "boolean thisParamRemoved =",
            "removeExplicitThisParameter(newParams, callingConvention);",
            "if (removeExplicitReturnStorageParameter(newParams)) {",
            "returnVar = revertIndirectParameter(returnVar, true);",
            "}",
            "if (returnVar instanceof Parameter) {",
            "returnType = ((Parameter) returnVar).getFormalDataType();",
            "}",
            "returnStorage = VariableStorage.UNASSIGNED_STORAGE;",
            "if (updateType == FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS &&",
            "!thisParamRemoved &&",
            "CompilerSpec.CALLING_CONVENTION_thiscall.equals(callingConvention) &&",
            "newParams.size() != 0) {",
            "// Attempt to remove inferred unnamed 'this' parameter",
            "// WARNING! This is a bit of a hack - not sure how to account for what may be auto-params",
            "// within a list of parameters computed via analysis",
            "Variable firstParam = newParams.get(0);",
            "if (firstParam.getSource() == SourceType.DEFAULT &&",
            "firstParam.getLength() == program.getDefaultPointerSize()) {",
            "newParams.remove(0);",
            "}",
            "}",
            "}",
            "// Update return data type",
            "getReturn().setDataType(returnType, returnStorage, true, source);",
            "Set<String> nonParamNames = new HashSet<>();",
            "for (Symbol s : program.getSymbolTable().getSymbols(this)) {",
            "if (s.getSource() != SourceType.DEFAULT &&",
            "s.getSymbolType() != SymbolType.PARAMETER) {",
            "nonParamNames.add(s.getName());",
            "}",
            "}",
            "// Must ensure that all names do not conflict and that variable types are",
            "// resolved to this program so that they have the proper sizes",
            "List<Variable> clonedParams = new ArrayList<>();",
            "for (int i = 0; i < newParams.size(); i++) {",
            "Variable p = newParams.get(i);",
            "if (!useCustomStorage && (p instanceof AutoParameterImpl)) {",
            "continue;",
            "}",
            "if (p.isUniqueVariable()) {",
            "throw new IllegalArgumentException(",
            "\"Invalid parameter specified: UniqueVariable not allowed\");",
            "}",
            "checkForParameterNameConflict(p, newParams, nonParamNames);",
            "clonedParams.add(getResolvedVariable(p, false, !useCustomStorage));",
            "}",
            "newParams = clonedParams;",
            "if (useCustomStorage) {",
            "checkStorageConflicts(newParams, force);",
            "}",
            "// Repopulate params list",
            "List<ParameterDB> oldParams = params;",
            "params = new ArrayList<>();",
            "// Clear current param names",
            "for (ParameterDB param : oldParams) {",
            "param.setName(null, SourceType.DEFAULT);",
            "}",
            "int newParamIndex = 0;",
            "// Reassign old parameters if possible",
            "while (newParamIndex < oldParams.size() && newParamIndex < newParams.size()) {",
            "ParameterDB oldParam = oldParams.get(newParamIndex);",
            "Variable newParam = newParams.get(newParamIndex++);",
            "DataType dt = (newParam instanceof Parameter && !useCustomStorage)",
            "? ((Parameter) newParam).getFormalDataType()",
            ": newParam.getDataType();",
            "oldParam.setName(newParam.getName(), newParam.getSource());",
            "oldParam.setStorageAndDataType(newParam.getVariableStorage(), dt);",
            "oldParam.setComment(newParam.getComment());",
            "params.add(oldParam); // re-add to list",
            "}",
            "// Remove unused old parameters",
            "for (int i = newParamIndex; i < oldParams.size(); i++) {",
            "ParameterDB oldParam = oldParams.get(i);",
            "Symbol s = oldParam.getSymbol();",
            "symbolMap.remove(s);",
            "s.delete();",
            "}",
            "// Append new parameters if needed",
            "SymbolManager symbolMgr = program.getSymbolTable();",
            "for (int i = newParamIndex; i < newParams.size(); i++) {",
            "Variable newParam = newParams.get(i);",
            "DataType dt = (newParam instanceof Parameter && !useCustomStorage)",
            "? ((Parameter) newParam).getFormalDataType()",
            ": newParam.getDataType();",
            "VariableStorage storage = useCustomStorage ? newParam.getVariableStorage()",
            ": VariableStorage.UNASSIGNED_STORAGE;",
            "String name = newParam.getName();",
            "if (name == null || name.length() == 0) {",
            "name = SymbolUtilities.getDefaultParamName(i);",
            "}",
            "VariableSymbolDB s = symbolMgr.createVariableSymbol(name, this,",
            "SymbolType.PARAMETER, i, storage, newParam.getSource());",
            "s.setStorageAndDataType(storage, dt);",
            "ParameterDB paramDb = new ParameterDB(this, s);",
            "paramDb.setComment(newParam.getComment());",
            "params.add(i, paramDb);",
            "symbolMap.put(s, paramDb);",
            "}",
            "if (source.isHigherPriorityThan(getStoredSignatureSource())) {",
            "setSignatureSource(source);",
            "}",
            "// assign dynamic storage",
            "updateParametersAndReturn();",
            "manager.functionChanged(this, ChangeManager.FUNCTION_CHANGED_PARAMETERS);",
            "}"
        ],
        "max_rank": -0.1441566901013113
    },
    {
        "file": "dataset/57_original.java",
        "method": "testOperandFieldOptions",
        "new_method_name": "handle_GhidraOptions",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111
        ],
        "extracted_lines": [
            "public void testOperandFieldOptions() throws Exception {",
            "showTool(tool);",
            "loadProgram();",
            "Options options = tool.getOptions(GhidraOptions.CATEGORY_BROWSER_FIELDS);",
            "List<String> names = getOptionNames(options, \"Operands Field\");",
            "assertEquals(15, names.size());",
            "assertEquals(\"Operands Field.Add Space After Separator\", names.get(0));",
            "assertEquals(\"Operands Field.Always Show Primary Reference\", names.get(1));",
            "assertEquals(\"Operands Field.Display Abbreviated Default Label Names\", names.get(2));",
            "assertEquals(\"Operands Field.Display Namespace\", names.get(3));",
            "assertEquals(\"Operands Field.Enable Word Wrapping\", names.get(4));",
            "assertEquals(\"Operands Field.Follow Read or Indirect Pointer References\", names.get(5));",
            "assertEquals(\"Operands Field.Include Scalar Reference Adjustment\", names.get(6));",
            "assertEquals(\"Operands Field.Markup Inferred Variable References\", names.get(7));",
            "assertEquals(\"Operands Field.Markup Register Variable References\", names.get(8));",
            "assertEquals(\"Operands Field.Markup Stack Variable References\", names.get(9));",
            "assertEquals(\"Operands Field.Maximum Length of String in Default Labels\", names.get(10));",
            "assertEquals(\"Operands Field.Maximum Lines To Display\", names.get(11));",
            "assertEquals(\"Operands Field.Show Block Names\", names.get(12));",
            "assertEquals(\"Operands Field.Show Offcut Information\", names.get(13));",
            "assertEquals(\"Operands Field.Underline References\", names.get(14));",
            "NamespaceWrappedOption namespaceOption =",
            "(NamespaceWrappedOption) options.getCustomOption(names.get(3),",
            "new NamespaceWrappedOption());",
            "assertTrue(cb.goToField(addr(\"0x100eee0\"), \"Address\", 0, 0));",
            "ListingTextField btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(1, getNumberOfLines(btf));",
            "options.setBoolean(names.get(4), true);",
            "options.setInt(names.get(11), 4);",
            "cb.updateNow();",
            "//--- Verify stack variable markup options",
            "assertTrue(cb.goToField(addr(\"0x1002d06\"), \"Operands\", 0, 0));",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"dword ptr [EBP + param_5]\", btf.getText());",
            "options.setBoolean(names.get(9), false);",
            "cb.updateNow();",
            "cb.goToField(addr(\"0x1002d06\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"dword ptr [EBP + 0x14]=>param_5\", btf.getText());",
            "//--- Verify register variable markup options",
            "Command cmd = new AddRegisterRefCmd(addr(\"0x1002d0b\"), 0, program.getRegister(\"EDI\"),",
            "SourceType.USER_DEFINED);",
            "applyCmd(program, cmd);",
            "cb.updateNow();",
            "assertTrue(cb.goToField(addr(\"0x1002d0b\"), \"Operands\", 0, 0));",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"local_EDI_22,EAX\", btf.getText());",
            "assertTrue(cb.goToField(addr(\"0x1002d0f\"), \"Operands\", 0, 0));",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"local_EDI_22,local_EDI_22\", btf.getText()); // inferred register variable mark-up",
            "options.setBoolean(names.get(7), true);",
            "cb.updateNow();",
            "cb.goToField(addr(\"0x1002d0f\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"local_EDI_22,local_EDI_22\", btf.getText());",
            "options.setBoolean(names.get(8), false);",
            "cb.updateNow();",
            "cb.goToField(addr(\"0x1002d0f\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"EDI,EDI\", btf.getText());",
            "cb.goToField(addr(\"0x1002d0b\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"EDI=>local_EDI_22,EAX\", btf.getText());",
            "//---------",
            "cb.goToField(addr(\"0x100eee0\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(4, getNumberOfLines(btf));",
            "options.setBoolean(names.get(4), false);",
            "cb.updateNow();",
            "cb.goToField(addr(\"0x100eee0\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(1, getNumberOfLines(btf));",
            "assertTrue(cb.goToField(addr(\"0x10061a7\"), \"Operands\", 0, 0));",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"dword ptr [DAT_01008044]\", btf.getText());",
            "options.setBoolean(names.get(12), true);",
            "cb.updateNow();",
            "cb.goToField(addr(\"0x10061a7\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"dword ptr [.data:DAT_01008044]\", btf.getText());",
            "//---------",
            "cb.goToField(addr(\"0x1003daa\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"TestLib::ExtNS::ExtLab\", btf.getText());",
            "cb.goToField(addr(\"0x1001012\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"->TestLib::ExtNS::ExtLab\", btf.getText());",
            "namespaceOption.setShowLibraryInNamespace(false);",
            "options.setCustomOption(names.get(3), namespaceOption);",
            "cb.updateNow();",
            "cb.goToField(addr(\"0x1003daa\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"ExtNS::ExtLab\", btf.getText());",
            "cb.goToField(addr(\"0x1001012\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"->ExtNS::ExtLab\", btf.getText());",
            "namespaceOption.setShowLibraryInNamespace(true);",
            "namespaceOption.setShowNonLocalNamespace(false);",
            "options.setCustomOption(names.get(3), namespaceOption);",
            "cb.updateNow();",
            "cb.goToField(addr(\"0x1003daa\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"ExtLab\", btf.getText());",
            "cb.goToField(addr(\"0x1001012\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"->ExtLab\", btf.getText());",
            "options.setBoolean(names.get(5), false);",
            "cb.updateNow();",
            "cb.goToField(addr(\"0x1001012\"), \"Operands\", 0, 0);",
            "btf = (ListingTextField) cb.getCurrentField();",
            "assertEquals(\"PTR_ExtLab_01003daa\", btf.getText());",
            "}"
        ],
        "max_rank": -0.4955357142856575
    },
    {
        "file": "dataset/58_original.java",
        "method": "getRecord",
        "new_method_name": "handle_poolRef",
        "extracted_line_numbers": [
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            106,
            113,
            123,
            130,
            101,
            102,
            103,
            104,
            105,
            107,
            108,
            109,
            110,
            111,
            112,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            124,
            125,
            126,
            127,
            128
        ],
        "extracted_lines": [
            "if (poolRef instanceof ConstantPoolIntegerInfo) {",
            "res.tag = ConstantPool.PRIMITIVE;",
            "res.token = \"int\";",
            "res.value = ((ConstantPoolIntegerInfo) poolRef).getValue();",
            "res.type = IntegerDataType.dataType;",
            "}",
            "else if (poolRef instanceof ConstantPoolFloatInfo) {",
            "else if (poolRef instanceof ConstantPoolStringInfo) {",
            "else if (poolRef instanceof ConstantPoolClassInfo) {",
            "else if (poolRef instanceof ConstantPoolMethodTypeInfo) {",
            "else if (poolRef instanceof ConstantPoolMethodHandleInfo) {",
            "res.tag = ConstantPool.PRIMITIVE;",
            "res.token = \"float\";",
            "res.value = ((ConstantPoolFloatInfo) poolRef).getRawBytes() & 0xffffffffL;",
            "res.type = FloatDataType.dataType;",
            "}",
            "int string_index = ((ConstantPoolStringInfo) poolRef).getStringIndex();",
            "res.tag = ConstantPool.STRING_LITERAL;",
            "res.byteData = ((ConstantPoolUtf8Info) constantPool[string_index]).getBytes();",
            "res.type = DescriptorDecoder.getReferenceTypeOfDescriptor(\"java/lang/String\",",
            "dtManager, false);",
            "}",
            "res.tag = ConstantPool.CLASS_REFERENCE;",
            "name_index = ((ConstantPoolClassInfo) poolRef).getNameIndex();",
            "fullyQualifiedName =",
            "((ConstantPoolUtf8Info) constantPool[name_index]).getString();",
            "String className = getClassName(fullyQualifiedName);",
            "res.token = className + \".class\";",
            "res.type = DescriptorDecoder.getReferenceTypeOfDescriptor(fullyQualifiedName,",
            "dtManager, false);",
            "}",
            "res.tag = ConstantPool.POINTER_METHOD;",
            "name_index = ((ConstantPoolMethodTypeInfo) poolRef).getDescriptorIndex();",
            "res.token = ((ConstantPoolUtf8Info) constantPool[name_index]).getString();",
            "res.type = dtManager.getPointer(DWordDataType.dataType);",
            "}"
        ],
        "max_rank": 0.48802987999693426
    },
    {
        "file": "dataset/59_original.java",
        "method": "testAddSynchronizedDomainObject",
        "new_method_name": "handle_obj1Listener",
        "extracted_line_numbers": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            181,
            182,
            183,
            184,
            185,
            186,
            187,
            188,
            189,
            190,
            191,
            192,
            193,
            194,
            195,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            210,
            211,
            212,
            213,
            214,
            215,
            216,
            217,
            218,
            219,
            220,
            221,
            222,
            223
        ],
        "extracted_lines": [
            "public void testAddSynchronizedDomainObject() throws IOException {",
            "assertNull(obj1.getCurrentTransactionInfo());",
            "assertNull(obj2.getCurrentTransactionInfo());",
            "assertEquals(1, obj1.getUndoStackDepth());",
            "assertEquals(1, obj2.getUndoStackDepth());",
            "assertTrue(obj1.canUndo());",
            "assertTrue(obj2.canUndo());",
            "assertFalse(obj1.canRedo());",
            "assertFalse(obj2.canRedo());",
            "TransactionInfo tx = obj1Listener.getLastTransaction();",
            "obj1Listener.getEvents();",
            "assertNotNull(tx);",
            "tx = obj2Listener.getLastTransaction();",
            "obj2Listener.getEvents();",
            "assertNotNull(tx);",
            "assertNull(obj1.getSynchronizedDomainObjects());",
            "assertNull(obj2.getSynchronizedDomainObjects());",
            "try {",
            "obj1.addSynchronizedDomainObject(obj2);",
            "}",
            "catch (LockException e) {",
            "e.printStackTrace();",
            "Assert.fail(e.getMessage());",
            "}",
            "DomainObject[] synchronizedDomainObjects = obj1.getSynchronizedDomainObjects();",
            "assertNotNull(synchronizedDomainObjects);",
            "assertEquals(2, synchronizedDomainObjects.length);",
            "assertEquals(obj1, synchronizedDomainObjects[0]);",
            "assertEquals(obj2, synchronizedDomainObjects[1]);",
            "assertArrayEquals(synchronizedDomainObjects, obj2.getSynchronizedDomainObjects());",
            "assertEquals(0, obj1.getUndoStackDepth());",
            "assertEquals(0, obj2.getUndoStackDepth());",
            "assertFalse(obj1.canUndo());",
            "assertFalse(obj2.canUndo());",
            "assertFalse(obj1.canRedo());",
            "assertFalse(obj2.canRedo());",
            "String[] events1 = obj1Listener.getEvents();",
            "assertEquals(UNDO_STATE_CHANGE1, events1[events1.length - 1]);",
            "String[] events2 = obj2Listener.getEvents();",
            "assertEquals(UNDO_STATE_CHANGE2, events2[events2.length - 1]);",
            "// Test rollback (non-committed) transaction",
            "int txId1 = obj1.startTransaction(\"Test1\");",
            "try {",
            "assertNotNull(obj2.getCurrentTransactionInfo());",
            "propertyList1.setString(\"A1.B1\", \"TestB1\");",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { START, UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] { START, UNDO_STATE_CHANGE2 }, events2));",
            "int txId2 = obj2.startTransaction(\"Test2\");",
            "try {",
            "propertyList2.setString(\"A2.B2\", \"TestB2\");",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { START, UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] { START, UNDO_STATE_CHANGE2 }, events2));",
            "}",
            "finally {",
            "obj2.endTransaction(txId2, true);",
            "}",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] {}, events1));",
            "assertTrue(Arrays.equals(new String[] {}, events2));",
            "assertEquals(\"TestB1\", propertyList1.getString(\"A1.B1\", \"NULL\"));",
            "assertEquals(\"TestB2\", propertyList2.getString(\"A2.B2\", \"NULL\"));",
            "}",
            "finally {",
            "obj1.endTransaction(txId1, false);",
            "}",
            "// obj2 rollback causes obj2 to rollback",
            "assertEquals(\"NULL\", propertyList1.getString(\"A1.B1\", \"NULL\"));",
            "assertEquals(\"NULL\", propertyList2.getString(\"A2.B2\", \"NULL\"));",
            "assertNull(obj1.getCurrentTransactionInfo());",
            "assertEquals(0, obj1.getUndoStackDepth());",
            "assertEquals(0, obj2.getUndoStackDepth());",
            "assertFalse(obj1.canUndo());",
            "assertFalse(obj2.canUndo());",
            "assertFalse(obj1.canRedo());",
            "assertFalse(obj2.canRedo());",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { END, UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] { END, UNDO_STATE_CHANGE2 }, events2));",
            "// Test committed transaction",
            "txId1 = obj1.startTransaction(\"Test1\");",
            "try {",
            "assertNotNull(obj2.getCurrentTransactionInfo());",
            "propertyList1.setString(\"A1.B1\", \"TestB1\");",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { START, UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] { START, UNDO_STATE_CHANGE2 }, events2));",
            "int txId2 = obj2.startTransaction(\"Test2\");",
            "try {",
            "propertyList2.setString(\"A2.B2\", \"TestB2\");",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { START, UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] { START, UNDO_STATE_CHANGE2 }, events2));",
            "}",
            "finally {",
            "obj2.endTransaction(txId2, true);",
            "}",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] {}, events1));",
            "assertTrue(Arrays.equals(new String[] {}, events2));",
            "assertEquals(\"TestB1\", propertyList1.getString(\"A1.B1\", \"NULL\"));",
            "assertEquals(\"TestB2\", propertyList2.getString(\"A2.B2\", \"NULL\"));",
            "}",
            "finally {",
            "obj1.endTransaction(txId1, true);",
            "}",
            "assertEquals(\"TestB1\", propertyList1.getString(\"A1.B1\", \"NULL\"));",
            "assertEquals(\"TestB2\", propertyList2.getString(\"A2.B2\", \"NULL\"));",
            "assertNull(obj1.getCurrentTransactionInfo());",
            "assertEquals(1, obj1.getUndoStackDepth());",
            "assertEquals(1, obj2.getUndoStackDepth());",
            "assertTrue(obj1.canUndo());",
            "assertTrue(obj2.canUndo());",
            "assertFalse(obj1.canRedo());",
            "assertFalse(obj2.canRedo());",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { END, UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] { END, UNDO_STATE_CHANGE2 }, events2));",
            "assertEquals(\"obj1: Test1\\nobj2: Test2\", obj1.getUndoName());",
            "assertEquals(\"obj1: Test1\\nobj2: Test2\", obj2.getUndoName());",
            "assertEquals(\"\", obj1.getRedoName());",
            "assertEquals(\"\", obj2.getRedoName());",
            "obj1.undo();",
            "assertFalse(obj1.canUndo());",
            "assertFalse(obj2.canUndo());",
            "assertTrue(obj1.canRedo());",
            "assertTrue(obj2.canRedo());",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] { UNDO_STATE_CHANGE2 }, events2));",
            "assertEquals(\"NULL\", propertyList1.getString(\"A1.B1\", \"NULL\"));",
            "assertEquals(\"NULL\", propertyList2.getString(\"A2.B2\", \"NULL\"));",
            "assertEquals(\"\", obj1.getUndoName());",
            "assertEquals(\"\", obj2.getUndoName());",
            "assertEquals(\"obj1: Test1\\nobj2: Test2\", obj1.getRedoName());",
            "assertEquals(\"obj1: Test1\\nobj2: Test2\", obj2.getRedoName());",
            "obj1.redo();",
            "assertTrue(obj1.canUndo());",
            "assertTrue(obj2.canUndo());",
            "assertFalse(obj1.canRedo());",
            "assertFalse(obj2.canRedo());",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] { UNDO_STATE_CHANGE2 }, events2));",
            "assertEquals(\"TestB1\", propertyList1.getString(\"A1.B1\", \"NULL\"));",
            "assertEquals(\"TestB2\", propertyList2.getString(\"A2.B2\", \"NULL\"));",
            "try {",
            "obj1.releaseSynchronizedDomainObject();",
            "}",
            "catch (LockException e) {",
            "e.printStackTrace();",
            "Assert.fail();",
            "}",
            "assertEquals(0, obj1.getUndoStackDepth());",
            "assertEquals(0, obj2.getUndoStackDepth());",
            "assertFalse(obj1.canUndo());",
            "assertFalse(obj2.canUndo());",
            "assertFalse(obj1.canRedo());",
            "assertFalse(obj2.canRedo());",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] { UNDO_STATE_CHANGE2 }, events2));",
            "assertEquals(\"TestB1\", propertyList1.getString(\"A1.B1\", \"NULL\"));",
            "assertEquals(\"TestB2\", propertyList2.getString(\"A2.B2\", \"NULL\"));",
            "// Independent transactions",
            "txId1 = obj1.startTransaction(\"Test1\");",
            "try {",
            "assertNull(obj2.getCurrentTransactionInfo());",
            "propertyList1.setString(\"A1.C1\", \"TestC1\");",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { START, UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] {}, events2));",
            "int txId2 = obj2.startTransaction(\"Test2\");",
            "try {",
            "propertyList2.setString(\"A2.C2\", \"TestC2\");",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] {}, events1));",
            "assertTrue(Arrays.equals(new String[] { START, UNDO_STATE_CHANGE2 }, events2));",
            "}",
            "finally {",
            "obj2.endTransaction(txId2, true);",
            "}",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] {}, events1));",
            "assertTrue(Arrays.equals(new String[] { END, UNDO_STATE_CHANGE2 }, events2));",
            "assertEquals(\"TestC1\", propertyList1.getString(\"A1.C1\", \"NULL\"));",
            "assertEquals(\"TestC2\", propertyList2.getString(\"A2.C2\", \"NULL\"));",
            "}",
            "finally {",
            "obj1.endTransaction(txId1, false);",
            "}",
            "assertEquals(\"NULL\", propertyList1.getString(\"A1.C1\", \"NULL\"));",
            "assertEquals(\"TestC2\", propertyList2.getString(\"A2.C2\", \"NULL\"));",
            "assertNull(obj1.getCurrentTransactionInfo());",
            "assertEquals(0, obj1.getUndoStackDepth());",
            "assertEquals(1, obj2.getUndoStackDepth());",
            "assertFalse(obj1.canUndo());",
            "assertTrue(obj2.canUndo());",
            "assertFalse(obj1.canRedo());",
            "assertFalse(obj2.canRedo());",
            "events1 = obj1Listener.getEvents();",
            "events2 = obj2Listener.getEvents();",
            "assertTrue(Arrays.equals(new String[] { END, UNDO_STATE_CHANGE1 }, events1));",
            "assertTrue(Arrays.equals(new String[] {}, events2));",
            "assertEquals(\"\", obj1.getUndoName());",
            "assertEquals(\"obj2: Test2\", obj2.getUndoName());",
            "assertEquals(\"\", obj1.getRedoName());",
            "assertEquals(\"\", obj2.getRedoName());",
            "}"
        ],
        "max_rank": -0.49999999999992356
    },
    {
        "file": "dataset/60_original.java",
        "method": "processType",
        "new_method_name": "handle_String",
        "extracted_line_numbers": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            181,
            182,
            183,
            184,
            185,
            186,
            187,
            188,
            189,
            190,
            191,
            192,
            193,
            194,
            195,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            210,
            211,
            212,
            213,
            214,
            215,
            216,
            217,
            218,
            219,
            220,
            221,
            222,
            223,
            224,
            225,
            226,
            227,
            228,
            229,
            230,
            231,
            232,
            233,
            234,
            235,
            236,
            237,
            238,
            239,
            240,
            241,
            242,
            243,
            244,
            245,
            246,
            247,
            248,
            249,
            250,
            251,
            252,
            253,
            254,
            255,
            256,
            257,
            258,
            259,
            260,
            261,
            262,
            263,
            264,
            265,
            266,
            267,
            268,
            269,
            270,
            271,
            272,
            273,
            274,
            275,
            276,
            277,
            278,
            279,
            280,
            281,
            282,
            283,
            284,
            285,
            286,
            287,
            288,
            289,
            290,
            291,
            292,
            293,
            294,
            295,
            296,
            297,
            298,
            299,
            300,
            301,
            302,
            303,
            304,
            305,
            306,
            307,
            308,
            309,
            310,
            311,
            312,
            313,
            314,
            315,
            316,
            317,
            318,
            319,
            320,
            321,
            322,
            323,
            324,
            325,
            326,
            327,
            328,
            329,
            330,
            331,
            332,
            333,
            334,
            335,
            336,
            337,
            338,
            339,
            340,
            341,
            342,
            343,
            344,
            345,
            346,
            347,
            348,
            349,
            350,
            351,
            352,
            353,
            354,
            355,
            356,
            357,
            358,
            359,
            360,
            361,
            362,
            363,
            364,
            365,
            366,
            367,
            368,
            369,
            370,
            371,
            372,
            373,
            374,
            375,
            376,
            377,
            378,
            379,
            380,
            381,
            382,
            383,
            384,
            385,
            386,
            387,
            388,
            389,
            390,
            391,
            392,
            393,
            394,
            395,
            396,
            397,
            398,
            399,
            400,
            401,
            402,
            403,
            404,
            405,
            406,
            407,
            408,
            409,
            410,
            411,
            412,
            413,
            414,
            415,
            416,
            417,
            418,
            419,
            420,
            421,
            422,
            423,
            424,
            425,
            426,
            427,
            428,
            429,
            430,
            431,
            432,
            433,
            434,
            435,
            436,
            437,
            438,
            439,
            440,
            441,
            442,
            443,
            444,
            445,
            446,
            447,
            448,
            449,
            450,
            451,
            452,
            453,
            454,
            455,
            456,
            457,
            458,
            459,
            460,
            461,
            462,
            463,
            464,
            465,
            466,
            467,
            468,
            469,
            470,
            471,
            472,
            473,
            474,
            475,
            476,
            477,
            478,
            479,
            480,
            481,
            482,
            483,
            484,
            485,
            486,
            487,
            488,
            489,
            490,
            491,
            492,
            493,
            494,
            495,
            496,
            497,
            498,
            499,
            500,
            501,
            502,
            503,
            504,
            505,
            506,
            507,
            508,
            509,
            510,
            511,
            512,
            513,
            514,
            515,
            516,
            517,
            518,
            519,
            520,
            521,
            522,
            523,
            524,
            525,
            526,
            527,
            528,
            529,
            530,
            531,
            532,
            533,
            534,
            535,
            536,
            537,
            538,
            539,
            540,
            541,
            542,
            543,
            544,
            545,
            546,
            547,
            548,
            549,
            550,
            551,
            552,
            553,
            554,
            555,
            556,
            557,
            558,
            559,
            560,
            561,
            562,
            563,
            564,
            565,
            566,
            567,
            568,
            569,
            570,
            571,
            572,
            573,
            574,
            575,
            576,
            577,
            578,
            579,
            580,
            581,
            582,
            583,
            584,
            585,
            586,
            587,
            588,
            589,
            590,
            591,
            592,
            593,
            594,
            595,
            596,
            597,
            598,
            599,
            600,
            601,
            602,
            603,
            604,
            605,
            606,
            607,
            608,
            609,
            610,
            611,
            612,
            613,
            614,
            615,
            616,
            617,
            618,
            619,
            620,
            621,
            622,
            623,
            624,
            625,
            626,
            627,
            628,
            629,
            630,
            631,
            632,
            633,
            634,
            635,
            636,
            637,
            638,
            639,
            640,
            641,
            642,
            643,
            644,
            645,
            646,
            647,
            648,
            649,
            650,
            651,
            652,
            653,
            654,
            655,
            656,
            657,
            658,
            659,
            660,
            661,
            662,
            663,
            664,
            665,
            666,
            667,
            668,
            669,
            670,
            671,
            672,
            673,
            674,
            675,
            676,
            677,
            678,
            679,
            680,
            681,
            682,
            683,
            684,
            685,
            686,
            687,
            688,
            689,
            690,
            691,
            692,
            693,
            694,
            695,
            696,
            697,
            698,
            699,
            700,
            701,
            702,
            703,
            704,
            705,
            706,
            707,
            708,
            709,
            710,
            711,
            712,
            713,
            714,
            715,
            716,
            717,
            718,
            719,
            720,
            721,
            722,
            723,
            724,
            725,
            726,
            727,
            728,
            729,
            730,
            731,
            732,
            733,
            734,
            735,
            736,
            737,
            738,
            739,
            740,
            741,
            742,
            743,
            744,
            745,
            746,
            747,
            748,
            749,
            750,
            751,
            752,
            753,
            754,
            755,
            756,
            757,
            758,
            759,
            760,
            761,
            762,
            763,
            764,
            765,
            766,
            767,
            768,
            769,
            770,
            771,
            772,
            773,
            774,
            775,
            776,
            777,
            778,
            779,
            780,
            781,
            782,
            783,
            784,
            785,
            786,
            787,
            788,
            789,
            790,
            791,
            792,
            793,
            794,
            795,
            796,
            797,
            798,
            799,
            800,
            801,
            802,
            803,
            804,
            805,
            806,
            807,
            808,
            809,
            810,
            811,
            812,
            813,
            814,
            815,
            816,
            817,
            818,
            819,
            820,
            821,
            822,
            823,
            824,
            825,
            826,
            827,
            828,
            829,
            830,
            831,
            832,
            833,
            834,
            835,
            836,
            837,
            838,
            839,
            840,
            841,
            842,
            843,
            844,
            845,
            846,
            847,
            848,
            849,
            850,
            851,
            852,
            853,
            854,
            855,
            856,
            857,
            858,
            859,
            860,
            861,
            862,
            863,
            864,
            865,
            866,
            867,
            868,
            869,
            870,
            871,
            872,
            873,
            874,
            875,
            876,
            877,
            878,
            879,
            880,
            881,
            882,
            883,
            884,
            885,
            886,
            887,
            888,
            889,
            890,
            891,
            892,
            893,
            894,
            895,
            896,
            897,
            898,
            899,
            900,
            901,
            902,
            903,
            904,
            905,
            906,
            907,
            908,
            909,
            910,
            911,
            912,
            913,
            914,
            915,
            916,
            917,
            918,
            919,
            920,
            921,
            922,
            923,
            924,
            925,
            926,
            927,
            928,
            929,
            930,
            931,
            932,
            933,
            934,
            935,
            936,
            937,
            938,
            939,
            940,
            941,
            942,
            943,
            944,
            945,
            946,
            947,
            948,
            949,
            950,
            951,
            952,
            953,
            954,
            955,
            956,
            957,
            958,
            959,
            960,
            961,
            962,
            963,
            964,
            965,
            966,
            967,
            968,
            969,
            970,
            971,
            972,
            973,
            974,
            975,
            976,
            977,
            978,
            979,
            980,
            981,
            982,
            983,
            984,
            985,
            986,
            987,
            988,
            989,
            990,
            991,
            992,
            993,
            994,
            995,
            996,
            997,
            998,
            999,
            1000,
            1001,
            1002,
            1003,
            1004,
            1005,
            1006,
            1007,
            1008,
            1009,
            1010,
            1011,
            1012,
            1013,
            1014,
            1015,
            1016,
            1017,
            1018,
            1019,
            1020,
            1021,
            1022,
            1023,
            1024,
            1025,
            1026,
            1027,
            1028,
            1029,
            1030,
            1031,
            1032,
            1033,
            1034,
            1035,
            1036,
            1037,
            1038,
            1039,
            1040,
            1041,
            1042,
            1043,
            1044,
            1045,
            1046,
            1047,
            1048,
            1049,
            1050,
            1051,
            1052,
            1053,
            1054,
            1055,
            1056,
            1057,
            1058,
            1059,
            1060,
            1061,
            1062,
            1063,
            1064,
            1065,
            1066,
            1067,
            1068,
            1069,
            1070,
            1071,
            1072,
            1073,
            1074,
            1075,
            1076,
            1077,
            1078,
            1079,
            1080,
            1081,
            1082,
            1083,
            1084,
            1085,
            1086,
            1087,
            1088,
            1089,
            1090,
            1091,
            1092,
            1093,
            1094,
            1095,
            1096,
            1097,
            1098,
            1099,
            1100,
            1101,
            1102,
            1103,
            1104,
            1105,
            1106,
            1107,
            1108,
            1109,
            1110,
            1111,
            1112,
            1113,
            1114,
            1115,
            1116,
            1117,
            1118,
            1119,
            1120,
            1121,
            1122,
            1123,
            1124,
            1125,
            1126,
            1127,
            1128,
            1129,
            1130,
            1131,
            1132,
            1133,
            1134,
            1135,
            1136,
            1137,
            1138,
            1139,
            1140,
            1141,
            1142,
            1143,
            1144,
            1145,
            1146,
            1147,
            1148,
            1149,
            1150,
            1151,
            1152,
            1153,
            1154,
            1155,
            1156,
            1157,
            1158,
            1159,
            1160,
            1161,
            1162,
            1163,
            1164,
            1165,
            1166,
            1167,
            1168,
            1169,
            1170,
            1171,
            1172,
            1173,
            1174,
            1175,
            1176,
            1177,
            1178,
            1179,
            1180,
            1181,
            1182,
            1183,
            1184,
            1185,
            1186,
            1187,
            1188,
            1189,
            1190,
            1191,
            1192,
            1193,
            1194,
            1195,
            1196,
            1197,
            1198,
            1199,
            1200,
            1201,
            1202,
            1203,
            1204,
            1205,
            1206,
            1207,
            1208,
            1209,
            1210,
            1211,
            1212,
            1213,
            1214,
            1215,
            1216,
            1217,
            1218,
            1219,
            1220,
            1221,
            1222,
            1223,
            1224,
            1225,
            1226,
            1227,
            1228,
            1229,
            1230,
            1231,
            1232,
            1233,
            1234,
            1235,
            1236,
            1237,
            1238,
            1239,
            1240,
            1241,
            1242,
            1243,
            1244,
            1245,
            1246,
            1247,
            1248,
            1249,
            1250,
            1251,
            1252,
            1253,
            1254,
            1255,
            1256,
            1257,
            1258,
            1259,
            1260,
            1261,
            1262,
            1263,
            1264,
            1265,
            1266,
            1267,
            1268,
            1269,
            1270,
            1271,
            1272,
            1273,
            1274,
            1275,
            1276,
            1277,
            1278,
            1279,
            1280,
            1281,
            1282,
            1283,
            1284,
            1285,
            1286,
            1287,
            1288,
            1289,
            1290,
            1291,
            1292,
            1293,
            1294,
            1295,
            1296,
            1297,
            1298,
            1299,
            1300,
            1301,
            1302,
            1303,
            1304,
            1305,
            1306,
            1307,
            1308,
            1309,
            1310,
            1311,
            1312,
            1313,
            1314,
            1315,
            1316,
            1317,
            1318,
            1319,
            1320,
            1321,
            1322,
            1323,
            1324,
            1325,
            1326,
            1327,
            1328,
            1329,
            1330,
            1331,
            1332,
            1333,
            1334,
            1335,
            1336,
            1337,
            1338,
            1339,
            1340,
            1341,
            1342,
            1343,
            1344,
            1345,
            1346,
            1347,
            1348,
            1349,
            1350,
            1351,
            1352,
            1353,
            1354,
            1355,
            1356,
            1357,
            1358,
            1359,
            1360,
            1361,
            1362,
            1363,
            1364,
            1365,
            1366,
            1367,
            1368,
            1369,
            1370,
            1371,
            1372,
            1373,
            1374,
            1375,
            1376,
            1377,
            1378,
            1379,
            1380,
            1381,
            1382,
            1383,
            1384,
            1385,
            1386,
            1387,
            1388,
            1389,
            1390,
            1391,
            1392,
            1393,
            1394,
            1395,
            1396,
            1397,
            1398,
            1399,
            1400,
            1401,
            1402,
            1403,
            1404,
            1405,
            1406,
            1407,
            1408,
            1409,
            1410,
            1411,
            1412,
            1413,
            1414,
            1415,
            1416,
            1417,
            1418,
            1419,
            1420,
            1421,
            1422,
            1423,
            1424,
            1425,
            1426,
            1427,
            1428,
            1429,
            1430,
            1431,
            1432,
            1433,
            1434,
            1435,
            1436,
            1437,
            1438,
            1439,
            1440,
            1441,
            1442,
            1443,
            1444,
            1445,
            1446,
            1447,
            1448,
            1449,
            1450,
            1451,
            1452,
            1453,
            1454,
            1455,
            1456,
            1457,
            1458,
            1459,
            1460,
            1461,
            1462,
            1463,
            1464,
            1465,
            1466,
            1467,
            1468,
            1469,
            1470,
            1471,
            1472,
            1473,
            1474,
            1475,
            1476,
            1477,
            1478,
            1479,
            1480,
            1481,
            1482,
            1483,
            1484,
            1485,
            1486,
            1487,
            1488,
            1489,
            1490,
            1491,
            1492,
            1493,
            1494,
            1495,
            1496,
            1497,
            1498,
            1499,
            1500,
            1501,
            1502,
            1503,
            1504,
            1505,
            1506,
            1507,
            1508,
            1509,
            1510,
            1511,
            1512,
            1513,
            1514,
            1515,
            1516,
            1517,
            1518,
            1519,
            1520,
            1521,
            1522,
            1523,
            1524,
            1525,
            1526,
            1527,
            1528,
            1529,
            1530,
            1531,
            1532,
            1533,
            1534,
            1535,
            1536,
            1537,
            1538,
            1539,
            1540,
            1541,
            1542,
            1543,
            1544,
            1545,
            1546,
            1547,
            1548,
            1549,
            1550,
            1551,
            1552,
            1553,
            1554,
            1555,
            1556,
            1557,
            1558,
            1559,
            1560,
            1561,
            1562,
            1563,
            1564,
            1565,
            1566,
            1567,
            1568,
            1569,
            1570,
            1571,
            1572,
            1573,
            1574,
            1575,
            1576,
            1577,
            1578,
            1579,
            1580,
            1581,
            1582,
            1583,
            1584,
            1585,
            1586,
            1587,
            1588,
            1589,
            1590,
            1591,
            1592,
            1593,
            1594,
            1595,
            1596,
            1597,
            1598,
            1599,
            1600,
            1601,
            1602,
            1603,
            1604,
            1605,
            1606,
            1607,
            1608,
            1609,
            1610,
            1611,
            1612,
            1613,
            1614,
            1615,
            1616,
            1617,
            1618,
            1619,
            1620,
            1621,
            1622,
            1623,
            1624,
            1625,
            1626,
            1627,
            1628,
            1629,
            1630,
            1631,
            1632,
            1633,
            1634,
            1635,
            1636,
            1637,
            1638,
            1639,
            1640,
            1641,
            1642,
            1643,
            1644,
            1645,
            1646,
            1647,
            1648,
            1649,
            1650,
            1651,
            1652,
            1653,
            1654,
            1655,
            1656,
            1657,
            1658,
            1659,
            1660,
            1661,
            1662,
            1663,
            1664,
            1665,
            1666,
            1667,
            1668,
            1669,
            1670,
            1671,
            1672,
            1673,
            1674,
            1675,
            1676,
            1677,
            1678,
            1679,
            1680,
            1681,
            1682,
            1683,
            1684,
            1685,
            1686,
            1687,
            1688,
            1689,
            1690,
            1691,
            1692,
            1693,
            1694,
            1695,
            1696,
            1697,
            1698,
            1699,
            1700,
            1701,
            1702,
            1703,
            1704,
            1705,
            1706,
            1707,
            1708,
            1709,
            1710,
            1711,
            1712,
            1713,
            1714,
            1715,
            1716,
            1717,
            1718,
            1719,
            1720,
            1721,
            1722,
            1723,
            1724,
            1725,
            1726,
            1727,
            1728,
            1729,
            1730,
            1731,
            1732,
            1733,
            1734,
            1735,
            1736,
            1737,
            1738,
            1739,
            1740,
            1741,
            1742,
            1743,
            1744,
            1745,
            1746,
            1747,
            1748,
            1749,
            1750,
            1751,
            1752,
            1753,
            1754,
            1755,
            1756,
            1757,
            1758,
            1759,
            1760,
            1761,
            1762,
            1763,
            1764,
            1765,
            1766,
            1767,
            1768,
            1769,
            1770,
            1771,
            1772,
            1773,
            1774,
            1775,
            1776,
            1777,
            1778,
            1779,
            1780,
            1781,
            1782,
            1783,
            1784,
            1785,
            1786,
            1787,
            1788,
            1789,
            1790,
            1791,
            1792,
            1793,
            1794,
            1795,
            1796,
            1797,
            1798,
            1799,
            1800,
            1801,
            1802,
            1803,
            1804,
            1805,
            1806,
            1807,
            1808,
            1809,
            1810,
            1811,
            1812,
            1813,
            1814,
            1815,
            1816,
            1817,
            1818,
            1819,
            1820,
            1821,
            1822,
            1823,
            1824,
            1825,
            1826,
            1827,
            1828,
            1829,
            1830,
            1831,
            1832,
            1833,
            1834,
            1835,
            1836,
            1837,
            1838,
            1839,
            1840,
            1841,
            1842,
            1843,
            1844,
            1845,
            1846,
            1847,
            1848,
            1849,
            1850,
            1851,
            1852,
            1853,
            1854,
            1855,
            1856,
            1857,
            1858,
            1859,
            1860,
            1861,
            1862,
            1863,
            1864,
            1865,
            1866,
            1867,
            1868,
            1869,
            1870,
            1871,
            1872,
            1873,
            1874,
            1875,
            1876,
            1877,
            1878
        ],
        "extracted_lines": [
            "switch (recNum) {",
            "//=======================================",
            "// Special types",
            "//=======================================",
            "// No Type (uncharacterized type)",
            "case 0x0000:",
            "typeString = \"T_NOTYPE\";",
            "typeSize = 0;",
            "break;",
            "// Absolute symbol",
            "case 0x0001:",
            "typeString = \"T_ABS\";",
            "typeSize = 0;",
            "break;",
            "// Segment type",
            "case 0x0002:",
            "typeString = \"T_SEGMENT\";",
            "typeSize = 0;",
            "break;",
            "// Void type",
            "case 0x0003:",
            "typeString = \"void\";",
            "typeSize = 0;",
            "break;",
            "// Near pointer to void",
            "case 0x0103:",
            "typeString = \"void near*\";",
            "typeSize = 2;",
            "break;",
            "// Far pointer to void",
            "case 0x0203:",
            "typeString = \"void far*\";",
            "typeSize = 4;",
            "break;",
            "// Huge pointer to void",
            "case 0x0303:",
            "typeString = \"void huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to void",
            "case 0x0403:",
            "typeString = \"void *\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to void",
            "case 0x0503:",
            "typeString = \"T_32PFVOID\";",
            "typeSize = 4;",
            "break;",
            "// 64-bit pointer to void",
            "case 0x0603:",
            "typeString = \"T_64PFVOID\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to void (LLVM doc on 0x0700)",
            "case 0x0703:",
            "typeString = \"T_128PFVOID\";",
            "typeSize = 16;",
            "break;",
            "// BASIC 8 byte currency value",
            "case 0x0004:",
            "typeString = \"T_CURRENCY\";",
            "typeSize = 8;",
            "break;",
            "// Near BASIC string",
            "case 0x0005:",
            "typeString = \"T_NBASICSTR\";",
            "typeSize = 0;",
            "break;",
            "// Far BASIC string",
            "case 0x0006:",
            "typeString = \"T_FBASICSTR\";",
            "typeSize = 0;",
            "break;",
            "// Type not translated by cvpack",
            "case 0x0007:",
            "typeString = \"T_NOTTRANS\";",
            "typeSize = 0;",
            "break;",
            "// OLE/COM HRESULT",
            "case 0x0008:",
            "typeString = \"T_HRESULT\";",
            "typeSize = 4;",
            "break;",
            "// OLE/COM HRESULT __ptr32 *",
            "case 0x0408:",
            "typeString = \"T_32PHRESULT\";",
            "typeSize = 4;",
            "break;",
            "// OLE/COM HRESULT __ptr64 *",
            "case 0x0608:",
            "typeString = \"T_64PHRESULT\";",
            "typeSize = 8;",
            "break;",
            "// OLE/COM HRESULT __ptr128 *  (LLVM doc on 0x0700)",
            "case 0x0708:",
            "typeString = \"T_128PHRESULT\";",
            "typeSize = 16;",
            "break;",
            "// bit",
            "case 0x0060:",
            "typeString = \"T_BIT\";",
            "typeSize = 0;",
            "break;",
            "// Pascal CHAR",
            "case 0x0061:",
            "typeString = \"T_PASCHAR\";",
            "typeSize = 0;",
            "break;",
            "// 32-bit BOOL where true is 0xffffffff",
            "case 0x0062:",
            "typeString = \"T_BOOL32FF\";",
            "typeSize = 0;",
            "break;",
            "//=======================================",
            "// Signed Character types",
            "//=======================================",
            "// 8-bit signed",
            "case 0x0010:",
            "typeString = \"signed char\";",
            "typeSize = 1;",
            "break;",
            "// 16-bit pointer to an 8-bit signed",
            "case 0x0110:",
            "typeString = \"signed char near*\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to an 8-bit signed",
            "case 0x0210:",
            "typeString = \"char far*\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to an 8-bit signed",
            "case 0x0310:",
            "typeString = \"char huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to an 8-bit signed",
            "case 0x0410:",
            "typeString = \"char *\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to an 8-bit signed",
            "case 0x0510:",
            "typeString = \"T_32PFCHAR\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to an 8-bit signed",
            "case 0x0610:",
            "typeString = \"T_64PCHAR\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to an 8-bit signed (LLVM doc on 0x0700)",
            "case 0x0710:",
            "typeString = \"T_128PCHAR\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// Unsigned Character types",
            "//=======================================",
            "// 8-bit unsigned",
            "case 0x0020:",
            "typeString = \"unsigned char\";",
            "typeSize = 1;",
            "break;",
            "// 16-bit pointer to an 8-bit unsigned",
            "case 0x0120:",
            "typeString = \"unsigned char near*\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to an 8-bit unsigned",
            "case 0x0220:",
            "typeString = \"unsigned char far*\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to an 8-bit unsigned",
            "case 0x0320:",
            "typeString = \"unsigned char huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to an 8-bit unsigned",
            "case 0x0420:",
            "typeString = \"unsigned char *\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to an 8-bit unsigned",
            "case 0x0520:",
            "typeString = \"T_32PFUCHAR\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to an 8-bit unsigned",
            "case 0x0620:",
            "typeString = \"T_64PUCHAR\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to an 8-bit unsigned (LLVM doc on 0x0700)",
            "case 0x0720:",
            "typeString = \"T_128PUCHAR\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// Real character types",
            "//=======================================",
            "// a real char",
            "case 0x0070:",
            "typeString = \"char\";",
            "typeSize = 1;",
            "break;",
            "// 16-bit pointer to a real char",
            "case 0x0170:",
            "typeString = \"char near*\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a real char",
            "case 0x0270:",
            "typeString = \"char far*\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a real char",
            "case 0x0370:",
            "typeString = \"char huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a real char",
            "case 0x0470:",
            "typeString = \"char *\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a real char",
            "case 0x0570:",
            "typeString = \"T_32PFRCHAR\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a real char",
            "case 0x0670:",
            "typeString = \"T_64PRCHAR\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a real char (LLVM doc on 0x0700)",
            "case 0x0770:",
            "typeString = \"T_128PRCHAR\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// Really a wide character types",
            "//=======================================",
            "// wide char",
            "case 0x0071:",
            "typeString = \"wchar_t\";",
            "typeSize = 2;",
            "break;",
            "// 16-bit pointer to a wide char",
            "case 0x0171:",
            "typeString = \"wchar_t near*\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a wide char",
            "case 0x0271:",
            "typeString = \"wchar_t far*\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a wide char",
            "case 0x0371:",
            "typeString = \"wchar_t huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a wide char",
            "case 0x0471:",
            "typeString = \"wchar_t *\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a wide char",
            "case 0x0571:",
            "typeString = \"T_32PFWCHAR\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a wide char",
            "case 0x0671:",
            "typeString = \"T_64PWCHAR\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a wide char (LLVM doc on 0x0700)",
            "case 0x0771:",
            "typeString = \"T_128PWCHAR\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 16-bit char types",
            "//=======================================",
            "// 16-bit unicode char",
            "case 0x007a:",
            "typeString = \"T_CHAR16\";",
            "typeSize = 2;",
            "break;",
            "// 16-bit pointer to a 16-bit unicode char",
            "case 0x017a:",
            "typeString = \"T_PCHAR16\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 16-bit unicode char",
            "case 0x027a:",
            "typeString = \"T_PFCHAR16\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 16-bit unicode char",
            "case 0x037a:",
            "typeString = \"T_PHCHAR16\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 16-bit unicode char",
            "case 0x047a:",
            "typeString = \"T_32PCHAR16\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 16-bit unicode char",
            "case 0x057a:",
            "typeString = \"T_32PFCHAR16\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 16-bit unicode char",
            "case 0x067a:",
            "typeString = \"T_64PCHAR16\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 16-bit unicode char (LLVM doc on 0x0700)",
            "case 0x077a:",
            "typeString = \"T_128PCHAR16\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 32-bit unicode char types",
            "//=======================================",
            "// 32-bit unicode char",
            "case 0x007b:",
            "typeString = \"T_CHAR32\";",
            "typeSize = 4;",
            "break;",
            "// 16-bit pointer to a 32-bit unicode char",
            "case 0x017b:",
            "typeString = \"T_PCHAR32\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 32-bit unicode char",
            "case 0x027b:",
            "typeString = \"T_PFCHAR32\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 32-bit unicode char",
            "case 0x037b:",
            "typeString = \"T_PHCHAR32\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 32-bit unicode char",
            "case 0x047b:",
            "typeString = \"T_32PCHAR32\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 32-bit unicode char",
            "case 0x057b:",
            "typeString = \"T_32PFCHAR32\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 32-bit unicode char",
            "case 0x067b:",
            "typeString = \"T_64PCHAR32\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 32-bit unicode char (LLVM doc on 0x0700)",
            "case 0x077b:",
            "typeString = \"T_128PCHAR32\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 8-bit int types",
            "//=======================================",
            "// 8-bit int",
            "case 0x0068:",
            "typeString = \"T_INT1\";",
            "typeSize = 1;",
            "break;",
            "// 16-bit pointer to an 8-bit int",
            "case 0x0168:",
            "typeString = \"T_PINT1\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to an 8-bit int",
            "case 0x0268:",
            "typeString = \"T_PFINT1\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to an 8-bit int",
            "case 0x0368:",
            "typeString = \"T_PHINT1\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to an 8-bit int",
            "case 0x0468:",
            "typeString = \"T_32PINT1\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to an 8-bit int",
            "case 0x0568:",
            "typeString = \"T_32PFINT1\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to an 8-bit int",
            "case 0x0668:",
            "typeString = \"T_64PINT1\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to an 8-bit int (LLVM doc on 0x0700)",
            "case 0x0768:",
            "typeString = \"T_128PINT1\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 8-bit unsigned int types",
            "//=======================================",
            "// 8-bit unsigned int",
            "case 0x0069:",
            "typeString = \"T_UINT1\";",
            "typeSize = 1;",
            "break;",
            "// 16-bit pointer to an 8-bit unsigned int",
            "case 0x0169:",
            "typeString = \"T_PUINT1\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to an 8-bit unsigned int",
            "case 0x0269:",
            "typeString = \"T_PFUINT1\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to an 8-bit unsigned int",
            "case 0x0369:",
            "typeString = \"T_PHUINT1\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to an 8-bit unsigned int",
            "case 0x0469:",
            "typeString = \"T_32PUINT1\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to an 8-bit unsigned int",
            "case 0x0569:",
            "typeString = \"T_32PFUINT1\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to an 8-bit unsigned int",
            "case 0x0669:",
            "typeString = \"T_64PUINT1\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to an 8-bit unsigned int (LLVM doc on 0x0700)",
            "case 0x0769:",
            "typeString = \"T_128PUINT1\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 16-bit short types",
            "//=======================================",
            "// 16-bit signed short",
            "case 0x0011:",
            "typeString = \"short\";",
            "typeSize = 2;",
            "break;",
            "// 16-bit pointer to a 16-bit signed short",
            "case 0x0111:",
            "typeString = \"short near*\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 16-bit signed short",
            "case 0x0211:",
            "typeString = \"short far*\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 16-bit signed short",
            "case 0x0311:",
            "typeString = \"short huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 16-bit signed short",
            "case 0x0411:",
            "typeString = \"T_32PSHORT\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 16-bit signed short",
            "case 0x0511:",
            "typeString = \"T_32PFSHORT\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 16-bit signed short",
            "case 0x0611:",
            "typeString = \"T_64PSHORT\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 16-bit signed short (LLVM doc on 0x0700)",
            "case 0x0711:",
            "typeString = \"T_128PSHORT\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 16-bit unsigned short types",
            "//=======================================",
            "// 16-bit unsigned signed short",
            "case 0x0021:",
            "typeString = \"unsigned short\";",
            "typeSize = 2;",
            "break;",
            "// 16-bit pointer to a 16-bit unsigned signed short",
            "case 0x0121:",
            "typeString = \"unsigned short near*\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 16-bit unsigned signed short",
            "case 0x0221:",
            "typeString = \"unsigned short far*\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 16-bit unsigned signed short",
            "case 0x0321:",
            "typeString = \"unsigned short huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 16-bit unsigned signed short",
            "case 0x0421:",
            "typeString = \"T_32PUSHORT\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 16-bit unsigned signed short",
            "case 0x0521:",
            "typeString = \"T_32PFUSHORT\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 16-bit unsigned signed short",
            "case 0x0621:",
            "typeString = \"T_64PUSHORT\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 16-bit unsigned signed short (LLVM doc on 0x0700)",
            "case 0x0721:",
            "typeString = \"T_128PUSHORT\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 16-bit signed int types",
            "//=======================================",
            "// 16-bit signed int",
            "case 0x0072:",
            "typeString = \"int16\";",
            "typeSize = 2;",
            "break;",
            "// 16-bit pointer to a 16-bit signed int",
            "case 0x0172:",
            "typeString = \"int16 near*\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 16-bit signed int",
            "case 0x0272:",
            "typeString = \"int16 far*\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 16-bit signed int",
            "case 0x0372:",
            "typeString = \"int16 huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 16-bit signed int",
            "case 0x0472:",
            "typeString = \"T_32PINT2\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 16-bit signed int",
            "case 0x0572:",
            "typeString = \"T_32PFINT2\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 16-bit signed int",
            "case 0x0672:",
            "typeString = \"T_64PINT2\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 16-bit signed int (LLVM doc on 0x0700)",
            "case 0x0772:",
            "typeString = \"T_128PINT2\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 16-bit unsigned int types",
            "//=======================================",
            "// 16-bit unsigned int",
            "case 0x0073:",
            "typeString = \"unsigned int16\";",
            "typeSize = 2;",
            "break;",
            "// 16-bit pointer to a 16-bit unsigned int",
            "case 0x0173:",
            "typeString = \"unsigned int16 near*\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 16-bit unsigned int",
            "case 0x0273:",
            "typeString = \"unsigned int16 far*\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 16-bit unsigned int",
            "case 0x0373:",
            "typeString = \"unsigned int16 huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 16-bit unsigned int",
            "case 0x0473:",
            "typeString = \"T_32PUINT2\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 16-bit unsigned int",
            "case 0x0573:",
            "typeString = \"T_32PFUINT2\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 16-bit unsigned int",
            "case 0x0673:",
            "typeString = \"T_64PUINT2\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 16-bit unsigned int (LLVM doc on 0x0700)",
            "case 0x0773:",
            "typeString = \"T_128PUINT2\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 32-bit long types",
            "//=======================================",
            "// 32-bit signed long",
            "case 0x0012:",
            "typeString = \"long\";",
            "typeSize = 4;",
            "break;",
            "// 16-bit pointer to a 32-bit signed long",
            "case 0x0112:",
            "typeString = \"long near*\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 32-bit signed long",
            "case 0x0212:",
            "typeString = \"long far*\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 32-bit signed long",
            "case 0x0312:",
            "typeString = \"long huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 32-bit signed long",
            "case 0x0412:",
            "typeString = \"T_32PLONG\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 32-bit signed long",
            "case 0x0512:",
            "typeString = \"T_32PFLONG\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 32-bit signed long",
            "case 0x0612:",
            "typeString = \"T_64PLONG\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 32-bit signed long (LLVM doc on 0x0700)",
            "case 0x0712:",
            "typeString = \"T_128PLONG\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 32-bit unsigned long types",
            "//=======================================",
            "// 32-bit unsigned signed long",
            "case 0x0022:",
            "typeString = \"unsigned long\";",
            "typeSize = 4;",
            "break;",
            "// 16-bit pointer to a 32-bit unsigned signed long",
            "case 0x0122:",
            "typeString = \"unsigned long near*\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 32-bit unsigned signed long",
            "case 0x0222:",
            "typeString = \"unsigned long far*\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 32-bit unsigned signed long",
            "case 0x0322:",
            "typeString = \"unsigned long huge*\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 32-bit unsigned signed long",
            "case 0x0422:",
            "typeString = \"T_32PULONG\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 32-bit unsigned signed long",
            "case 0x0522:",
            "typeString = \"T_32PFULONG\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 32-bit unsigned signed long",
            "case 0x0622:",
            "typeString = \"T_64PULONG\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 32-bit unsigned signed long (LLVM doc on 0x0700)",
            "case 0x0722:",
            "typeString = \"T_128PULONG\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 32-bit signed int types",
            "//=======================================",
            "// 32-bit signed int",
            "case 0x0074:",
            "typeString = \"int\";",
            "typeSize = 4;",
            "break;",
            "// 16-bit pointer to a 32-bit signed int",
            "case 0x0174:",
            "typeString = \"PINT4\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 32-bit signed int",
            "case 0x0274:",
            "typeString = \"PFINT4\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 32-bit signed int",
            "case 0x0374:",
            "typeString = \"PHINT4\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 32-bit signed int",
            "case 0x0474:",
            "typeString = \"T_32PINT4\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 32-bit signed int",
            "case 0x0574:",
            "typeString = \"T_32PFINT4\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 32-bit signed int",
            "case 0x0674:",
            "typeString = \"T_64PINT4\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 32-bit signed int (LLVM doc on 0x0700)",
            "case 0x0774:",
            "typeString = \"T_128PINT4\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 32-bit unsigned int types",
            "//=======================================",
            "// 32-bit unsigned int",
            "case 0x0075:",
            "typeString = \"unsigned\";",
            "typeSize = 4;",
            "break;",
            "// 16-bit pointer to a 32-bit unsigned int",
            "case 0x0175:",
            "typeString = \"PUINT4\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 32-bit unsigned int",
            "case 0x0275:",
            "typeString = \"PFUINT4\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 32-bit unsigned int",
            "case 0x0375:",
            "typeString = \"PHUINT4\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 32-bit unsigned int",
            "case 0x0475:",
            "typeString = \"T_32PUINT4\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 32-bit unsigned int",
            "case 0x0575:",
            "typeString = \"T_32PFUINT4\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 32-bit unsigned int",
            "case 0x0675:",
            "typeString = \"T_64PUINT4\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 32-bit unsigned int (LLVM doc on 0x0700)",
            "case 0x0775:",
            "typeString = \"T_128PUINT4\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 64-bit quad types",
            "//=======================================",
            "// 64-bit signed long",
            "case 0x0013:",
            "typeString = \"T_QUAD\";",
            "typeSize = 8;",
            "break;",
            "// 16-bit pointer to a 64-bit signed long",
            "case 0x0113:",
            "typeString = \"T_PQUAD\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 64-bit signed long",
            "case 0x0213:",
            "typeString = \"T_PFQUAD\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 64-bit signed long",
            "case 0x0313:",
            "typeString = \"T_PHQUAD\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 64-bit signed long",
            "case 0x0413:",
            "typeString = \"T_32PQUAD\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 64-bit signed long",
            "case 0x0513:",
            "typeString = \"T_32PFQUAD\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 64-bit signed long",
            "case 0x0613:",
            "typeString = \"T_64PQUAD\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 64-bit signed long (LLVM doc on 0x0700)",
            "case 0x0713:",
            "typeString = \"T_128PQUAD\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 64-bit unsigned quad types",
            "//=======================================",
            "// 64-bit unsigned signed long",
            "case 0x0023:",
            "typeString = \"T_UQUAD\";",
            "typeSize = 8;",
            "break;",
            "// 16-bit pointer to a 64-bit unsigned signed long",
            "case 0x0123:",
            "typeString = \"T_PUQUAD\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 64-bit unsigned signed long",
            "case 0x0223:",
            "typeString = \"T_PFUQUAD\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 64-bit unsigned signed long",
            "case 0x0323:",
            "typeString = \"T_PHUQUAD\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 64-bit unsigned signed long",
            "case 0x0423:",
            "typeString = \"T_32PUQUAD\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 64-bit unsigned signed long",
            "case 0x0523:",
            "typeString = \"T_32PFUQUAD\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 64-bit unsigned signed long",
            "case 0x0623:",
            "typeString = \"T_64PUQUAD\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 64-bit unsigned signed long (LLVM doc on 0x0700)",
            "case 0x0723:",
            "typeString = \"T_128PUQUAD\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 64-bit signed int types",
            "//=======================================",
            "// 64-bit signed int",
            "case 0x0076:",
            "typeString = \"T_INT8\";",
            "typeSize = 8;",
            "break;",
            "// 16-bit pointer to a 64-bit signed int",
            "case 0x0176:",
            "typeString = \"T_PINT8\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 64-bit signed int",
            "case 0x0276:",
            "typeString = \"T_PFINT8\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 64-bit signed int",
            "case 0x0376:",
            "typeString = \"T_PHINT8\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 64-bit signed int",
            "case 0x0476:",
            "typeString = \"T_32PINT8\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 64-bit signed int",
            "case 0x0576:",
            "typeString = \"T_32PFINT8\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 64-bit signed int",
            "case 0x0676:",
            "typeString = \"T_64PINT8\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 64-bit signed int (LLVM doc on 0x0700)",
            "case 0x0776:",
            "typeString = \"T_128PINT8\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 64-bit unsigned int types",
            "//=======================================",
            "// 64-bit unsigned int",
            "case 0x0077:",
            "typeString = \"T_UINT8\";",
            "typeSize = 8;",
            "break;",
            "// 16-bit pointer to a 64-bit unsigned int",
            "case 0x0177:",
            "typeString = \"T_PUINT8\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 64-bit unsigned int",
            "case 0x0277:",
            "typeString = \"T_PFUINT8\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 64-bit unsigned int",
            "case 0x0377:",
            "typeString = \"T_PHUINT8\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 64-bit unsigned int",
            "case 0x0477:",
            "typeString = \"T_32PUINT8\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 64-bit unsigned int",
            "case 0x0577:",
            "typeString = \"T_32PFUINT8\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 64-bit unsigned int",
            "case 0x0677:",
            "typeString = \"T_64PUINT8\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 64-bit unsigned int (LLVM doc on 0x0700)",
            "case 0x0777:",
            "typeString = \"T_128PUINT8\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 128-bit octet types",
            "//=======================================",
            "// 128-bit signed long",
            "case 0x0014:",
            "typeString = \"T_OCT\";",
            "typeSize = 16;",
            "break;",
            "// 16-bit pointer to a 128-bit signed long",
            "case 0x0114:",
            "typeString = \"T_POCT\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 128-bit signed long",
            "case 0x0214:",
            "typeString = \"T_PFOCT\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 128-bit signed long",
            "case 0x0314:",
            "typeString = \"T_PHOCT\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 128-bit signed long",
            "case 0x0414:",
            "typeString = \"T_32POCT\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 128-bit signed long",
            "case 0x0514:",
            "typeString = \"T_32PFOCT\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 128-bit signed long",
            "case 0x0614:",
            "typeString = \"T_64POCT\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 128-bit signed long (LLVM doc on 0x0700)",
            "case 0x0714:",
            "typeString = \"T_128POCT\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 128-bit unsigned octet types",
            "//=======================================",
            "// 128-bit unsigned signed long",
            "case 0x0024:",
            "typeString = \"T_UOCT\";",
            "typeSize = 16;",
            "break;",
            "// 16-bit pointer to a 128-bit unsigned signed long",
            "case 0x0124:",
            "typeString = \"T_PUOCT\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 128-bit unsigned signed long",
            "case 0x0224:",
            "typeString = \"T_PFUOCT\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 128-bit unsigned signed long",
            "case 0x0324:",
            "typeString = \"T_PHUOCT\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 128-bit unsigned signed long",
            "case 0x0424:",
            "typeString = \"T_32PUOCT\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 128-bit unsigned signed long",
            "case 0x0524:",
            "typeString = \"T_32PFUOCT\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 128-bit unsigned signed long",
            "case 0x0624:",
            "typeString = \"T_64PUOCT\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 128-bit unsigned signed long (LLVM doc on 0x0700)",
            "case 0x0724:",
            "typeString = \"T_128PUOCT\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 128-bit signed int types",
            "//=======================================",
            "// 128-bit signed int",
            "case 0x0078:",
            "typeString = \"T_INT16\";",
            "typeSize = 16;",
            "break;",
            "// 16-bit pointer to a 128-bit signed int",
            "case 0x0178:",
            "typeString = \"T_PINT16\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 128-bit signed int",
            "case 0x0278:",
            "typeString = \"T_PFINT16\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 128-bit signed int",
            "case 0x0378:",
            "typeString = \"T_PHINT16\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 128-bit signed int",
            "case 0x0478:",
            "typeString = \"T_32PINT16\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 128-bit signed int",
            "case 0x0578:",
            "typeString = \"T_32PFINT16\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 128-bit signed int",
            "case 0x0678:",
            "typeString = \"T_64PINT16\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 128-bit signed int (LLVM doc on 0x0700)",
            "case 0x0778:",
            "typeString = \"T_128PINT16\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 128-bit unsigned int types",
            "//=======================================",
            "// 128-bit unsigned int",
            "case 0x0079:",
            "typeString = \"T_UINT16\";",
            "typeSize = 16;",
            "break;",
            "// 16-bit pointer to a 128-bit unsigned int",
            "case 0x0179:",
            "typeString = \"T_PUINT16\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 128-bit unsigned int",
            "case 0x0279:",
            "typeString = \"T_PFUINT16\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 128-bit unsigned int",
            "case 0x0379:",
            "typeString = \"T_PHUINT16\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 128-bit unsigned int",
            "case 0x0479:",
            "typeString = \"T_32PUINT16\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 128-bit unsigned int",
            "case 0x0579:",
            "typeString = \"T_32PFUINT16\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 128-bit unsigned int",
            "case 0x0679:",
            "typeString = \"T_64PUINT16\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 128-bit unsigned int (LLVM doc on 0x0700)",
            "case 0x0779:",
            "typeString = \"T_128PUINT16\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 16-bit real types",
            "//=======================================",
            "// 16-bit real",
            "case 0x0046:",
            "typeString = \"T_REAL16\";",
            "typeSize = 2;",
            "break;",
            "// 16-bit pointer to a 16-bit real",
            "case 0x0146:",
            "typeString = \"T_PREAL16\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 16-bit real",
            "case 0x0246:",
            "typeString = \"T_PFREAL16\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 16-bit real",
            "case 0x0346:",
            "typeString = \"T_PHREAL16\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 16-bit real",
            "case 0x0446:",
            "typeString = \"T_32PREAL16\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 16-bit real",
            "case 0x0546:",
            "typeString = \"T_32PFREAL16\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 16-bit real",
            "case 0x0646:",
            "typeString = \"T_64PREAL16\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit pointer to a 16-bit real (LLVM doc on 0x0700)",
            "case 0x0746:",
            "typeString = \"T_128PREAL16\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 32-bit real types",
            "//=======================================",
            "// 32-bit real",
            "case 0x0040:",
            "typeString = \"T_REAL32\";",
            "typeSize = 4;",
            "break;",
            "// 16-bit pointer to a 32-bit real",
            "case 0x0140:",
            "typeString = \"T_PREAL32\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 32-bit real",
            "case 0x0240:",
            "typeString = \"T_PFREAL32\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 32-bit real",
            "case 0x0340:",
            "typeString = \"T_PHREAL32\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 32-bit real",
            "case 0x0440:",
            "typeString = \"T_32PREAL32\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 32-bit real",
            "case 0x0540:",
            "typeString = \"T_32PFREAL32\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 32-bit real",
            "case 0x0640:",
            "typeString = \"T_64PREAL32\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 32-bit real (LLVM doc on 0x0700)",
            "case 0x0740:",
            "typeString = \"T_128PREAL32\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 32-bit partial-precision real types",
            "//=======================================",
            "// 32-bit real",
            "case 0x0045:",
            "typeString = \"T_REAL32PP\";",
            "typeSize = 4;",
            "break;",
            "// 16-bit pointer to a 32-bit real",
            "case 0x0145:",
            "typeString = \"T_PREAL32PP\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 32-bit real",
            "case 0x0245:",
            "typeString = \"T_PFREAL32PP\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 32-bit real",
            "case 0x0345:",
            "typeString = \"T_PHREAL32PP\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 32-bit real",
            "case 0x0445:",
            "typeString = \"T_32PREAL32PP\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 32-bit real",
            "case 0x0545:",
            "typeString = \"T_32PFREAL32PP\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 32-bit real",
            "case 0x0645:",
            "typeString = \"T_64PREAL32PP\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 32-bit real (LLVM doc on 0x0700)",
            "case 0x0745:",
            "typeString = \"T_128PREAL32PP\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 48-bit real types",
            "//=======================================",
            "// 48-bit real",
            "case 0x0044:",
            "typeString = \"T_REAL48\";",
            "typeSize = 6;",
            "break;",
            "// 16-bit pointer to a 48-bit real",
            "case 0x0144:",
            "typeString = \"T_PREAL48\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 48-bit real",
            "case 0x0244:",
            "typeString = \"T_PFREAL48\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 48-bit real",
            "case 0x0344:",
            "typeString = \"T_PHREAL48\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 48-bit real",
            "case 0x0444:",
            "typeString = \"T_32PREAL48\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 48-bit real",
            "case 0x0544:",
            "typeString = \"T_32PFREAL48\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 48-bit real",
            "case 0x0644:",
            "typeString = \"T_64PREAL48\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 48-bit real (LLVM doc on 0x0700)",
            "case 0x0744:",
            "typeString = \"T_128PREAL48\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 64-bit real types",
            "//=======================================",
            "// 64-bit real",
            "case 0x0041:",
            "typeString = \"T_REAL64\";",
            "typeSize = 8;",
            "break;",
            "// 16-bit pointer to a 64-bit real",
            "case 0x0141:",
            "typeString = \"T_PREAL64\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 64-bit real",
            "case 0x0241:",
            "typeString = \"T_PFREAL64\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 64-bit real",
            "case 0x0341:",
            "typeString = \"T_PHREAL64\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 64-bit real",
            "case 0x0441:",
            "typeString = \"T_32PREAL64\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 64-bit real",
            "case 0x0541:",
            "typeString = \"T_32PFREAL64\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 64-bit real",
            "case 0x0641:",
            "typeString = \"T_64PREAL64\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 64-bit real (LLVM doc on 0x0700)",
            "case 0x0741:",
            "typeString = \"T_128PREAL64\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 80-bit real types",
            "//=======================================",
            "// 80-bit real",
            "case 0x0042:",
            "typeString = \"T_REAL80\";",
            "typeSize = 10;",
            "break;",
            "// 16-bit pointer to an 80-bit real",
            "case 0x0142:",
            "typeString = \"T_PREAL80\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to an 80-bit real",
            "case 0x0242:",
            "typeString = \"T_PFREAL80\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to an 80-bit real",
            "case 0x0342:",
            "typeString = \"T_PHREAL80\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to an 80-bit real",
            "case 0x0442:",
            "typeString = \"T_32PREAL80\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to an 80-bit real",
            "case 0x0542:",
            "typeString = \"T_32PFREAL80\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to an 80-bit real",
            "case 0x0642:",
            "typeString = \"T_64PREAL80\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to an 80-bit real (LLVM doc on 0x0700)",
            "case 0x0742:",
            "typeString = \"T_128PREAL80\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 128-bit real types",
            "//=======================================",
            "// 128-bit real",
            "case 0x0043:",
            "typeString = \"T_REAL128\";",
            "typeSize = 16;",
            "break;",
            "// 16-bit pointer to a 128-bit real",
            "case 0x0143:",
            "typeString = \"T_PREAL128\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 128-bit real",
            "case 0x0243:",
            "typeString = \"T_PFREAL128\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 128-bit real",
            "case 0x0343:",
            "typeString = \"T_PHREAL128\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 128-bit real",
            "case 0x0443:",
            "typeString = \"T_32PREAL128\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 128-bit real",
            "case 0x0543:",
            "typeString = \"T_32PFREAL128\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 128-bit real",
            "case 0x0643:",
            "typeString = \"T_64PREAL128\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 128-bit real (LLVM doc on 0x0700)",
            "case 0x0743:",
            "typeString = \"T_128PREAL128\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 32-bit complex types",
            "//=======================================",
            "// 32-bit complex",
            "case 0x0050:",
            "typeString = \"T_CPLX32\";",
            "typeSize = 4;",
            "break;",
            "// 16-bit pointer to a 32-bit complex",
            "case 0x0150:",
            "typeString = \"T_PCPLX32\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 32-bit complex",
            "case 0x0250:",
            "typeString = \"T_PFCPLX32\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 32-bit complex",
            "case 0x0350:",
            "typeString = \"T_PHCPLX32\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to an 32-bit complex",
            "case 0x0450:",
            "typeString = \"T_32PCPLX32\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to an 32-bit complex",
            "case 0x0550:",
            "typeString = \"T_32PFCPLX32\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to an 32-bit complex",
            "case 0x0650:",
            "typeString = \"T_64PCPLX32\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to an 32-bit complex (LLVM doc on 0x0700)",
            "case 0x0750:",
            "typeString = \"T_128PCPLX32\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 64-bit complex types",
            "//=======================================",
            "// 64-bit complex",
            "case 0x0051:",
            "typeString = \"T_CPLX64\";",
            "typeSize = 8;",
            "break;",
            "// 16-bit pointer to a 64-bit complex",
            "case 0x0151:",
            "typeString = \"T_PCPLX64\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 64-bit complex",
            "case 0x0251:",
            "typeString = \"T_PFCPLX64\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 64-bit complex",
            "case 0x0351:",
            "typeString = \"T_PHCPLX64\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 64-bit complex",
            "case 0x0451:",
            "typeString = \"T_32PCPLX64\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 64-bit complex",
            "case 0x0551:",
            "typeString = \"T_32PFCPLX64\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 64-bit complex",
            "case 0x0651:",
            "typeString = \"T_64PCPLX64\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 64-bit complex (LLVM doc on 0x0700)",
            "case 0x0751:",
            "typeString = \"T_128PCPLX64\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 80-bit complex types",
            "//=======================================",
            "// 80-bit complex",
            "case 0x0052:",
            "typeString = \"T_CPLX80\";",
            "typeSize = 10;",
            "break;",
            "// 16-bit pointer to an 80-bit complex",
            "case 0x0152:",
            "typeString = \"T_PCPLX80\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to an 80-bit complex",
            "case 0x0252:",
            "typeString = \"T_PFCPLX80\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to an 80-bit complex",
            "case 0x0352:",
            "typeString = \"T_PHCPLX80\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to an 80-bit complex",
            "case 0x0452:",
            "typeString = \"T_32PCPLX80\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to an 80-bit complex",
            "case 0x0552:",
            "typeString = \"T_32PFCPLX80\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to an 80-bit complex",
            "case 0x0652:",
            "typeString = \"T_64PCPLX80\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to an 80-bit complex (LLVM doc on 0x0700)",
            "case 0x0752:",
            "typeString = \"T_128PCPLX80\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 128-bit complex types",
            "//=======================================",
            "// 128-bit complex",
            "case 0x0053:",
            "typeString = \"T_CPLX128\";",
            "typeSize = 16;",
            "break;",
            "// 16-bit pointer to a 128-bit complex",
            "case 0x0153:",
            "typeString = \"T_PCPLX128\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 128-bit complex",
            "case 0x0253:",
            "typeString = \"T_PFCPLX128\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 128-bit complex",
            "case 0x0353:",
            "typeString = \"T_PHCPLX128\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 128-bit complex",
            "case 0x0453:",
            "typeString = \"T_32PCPLX128\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 128-bit complex",
            "case 0x0553:",
            "typeString = \"T_32PFCPLX128\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 128-bit complex",
            "case 0x0653:",
            "typeString = \"T_64PCPLX128\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 128-bit complex (LLVM doc on 0x0700)",
            "case 0x0753:",
            "typeString = \"T_128PCPLX128\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 8-bit boolean types",
            "//=======================================",
            "// 8-bit boolean",
            "case 0x0030:",
            "typeString = \"T_BOOL08\";",
            "typeSize = 1;",
            "break;",
            "// 16-bit pointer to an 8-bit boolean",
            "case 0x0130:",
            "typeString = \"T_PBOOL08\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to an 8-bit boolean",
            "case 0x0230:",
            "typeString = \"T_PFBOOL08\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to an 8-bit boolean",
            "case 0x0330:",
            "typeString = \"T_PHBOOL08\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to an 8-bit boolean",
            "case 0x0430:",
            "typeString = \"T_32PBOOL08\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to an 8-bit boolean",
            "case 0x0530:",
            "typeString = \"T_32PFBOOL08\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to an 8-bit boolean",
            "case 0x0630:",
            "typeString = \"T_64PBOOL08\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to an 8-bit boolean (LLVM doc on 0x0700)",
            "case 0x0730:",
            "typeString = \"T_128PBOOL08\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 16-bit boolean types",
            "//=======================================",
            "// 16-bit boolean",
            "case 0x0031:",
            "typeString = \"T_BOOL16\";",
            "typeSize = 2;",
            "break;",
            "// 16-bit pointer to a 16-bit boolean",
            "case 0x0131:",
            "typeString = \"T_PBOOL16\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 16-bit boolean",
            "case 0x0231:",
            "typeString = \"T_PFBOOL16\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 16-bit boolean",
            "case 0x0331:",
            "typeString = \"T_PHBOOL16\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 16-bit boolean",
            "case 0x0431:",
            "typeString = \"T_32PBOOL16\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 16-bit boolean",
            "case 0x0531:",
            "typeString = \"T_32PFBOOL16\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 16-bit boolean",
            "case 0x0631:",
            "typeString = \"T_64PBOOL16\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 16-bit boolean (LLVM doc on 0x0700)",
            "case 0x0731:",
            "typeString = \"T_128PBOOL16\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 32-bit boolean types",
            "//=======================================",
            "// 32-bit boolean",
            "case 0x0032:",
            "typeString = \"T_BOOL32\";",
            "typeSize = 4;",
            "break;",
            "// 16-bit pointer to a 32-bit boolean",
            "case 0x0132:",
            "typeString = \"T_PBOOL32\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 32-bit boolean",
            "case 0x0232:",
            "typeString = \"T_PFBOOL32\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 32-bit boolean",
            "case 0x0332:",
            "typeString = \"T_PHBOOL32\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 32-bit boolean",
            "case 0x0432:",
            "typeString = \"T_32PBOOL32\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 32-bit boolean",
            "case 0x0532:",
            "typeString = \"T_32PFBOOL32\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 32-bit boolean",
            "case 0x0632:",
            "typeString = \"T_64PBOOL32\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 32-bit boolean (LLVM doc on 0x0700)",
            "case 0x0732:",
            "typeString = \"T_128PBOOL32\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 64-bit boolean types",
            "//=======================================",
            "// 64-bit boolean",
            "case 0x0033:",
            "typeString = \"T_BOOL64\";",
            "typeSize = 8;",
            "break;",
            "// 16-bit pointer to a 64-bit boolean",
            "case 0x0133:",
            "typeString = \"T_PBOOL64\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 64-bit boolean",
            "case 0x0233:",
            "typeString = \"T_PFBOOL64\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 64-bit boolean",
            "case 0x0333:",
            "typeString = \"T_PHBOOL64\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 64-bit boolean",
            "case 0x0433:",
            "typeString = \"T_32PBOOL64\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 64-bit boolean",
            "case 0x0533:",
            "typeString = \"T_32PFBOOL64\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 64-bit boolean",
            "case 0x0633:",
            "typeString = \"T_64PBOOL64\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 64-bit boolean (LLVM doc on 0x0700)",
            "case 0x0733:",
            "typeString = \"T_128PBOOL64\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// 128-bit boolean types",
            "//=======================================",
            "// 128-bit boolean",
            "case 0x0034:",
            "typeString = \"T_BOOL128\";",
            "typeSize = 16;",
            "break;",
            "// 16-bit pointer to a 128-bit boolean",
            "case 0x0134:",
            "typeString = \"T_PBOOL128\";",
            "typeSize = 2;",
            "break;",
            "// 16:16 far pointer to a 128-bit boolean",
            "case 0x0234:",
            "typeString = \"T_PFBOOL128\";",
            "typeSize = 4;",
            "break;",
            "// 16:16 huge pointer to a 128-bit boolean",
            "case 0x0334:",
            "typeString = \"T_PHBOOL128\";",
            "typeSize = 4;",
            "break;",
            "// 32-bit pointer to a 128-bit boolean",
            "case 0x0434:",
            "typeString = \"T_32PBOOL128\";",
            "typeSize = 4;",
            "break;",
            "// 16:32 pointer to a 128-bit boolean",
            "case 0x0534:",
            "typeString = \"T_32PFBOOL128\";",
            "typeSize = 6;",
            "break;",
            "// 64-bit pointer to a 128-bit boolean",
            "case 0x0634:",
            "typeString = \"T_64PBOOL128\";",
            "typeSize = 8;",
            "break;",
            "// 128-bit near pointer to a 128-bit boolean (LLVM doc on 0x0700)",
            "case 0x0734:",
            "typeString = \"T_128PBOOL128\";",
            "typeSize = 16;",
            "break;",
            "//=======================================",
            "// Internal type with pointers",
            "//=======================================",
            "// CV Internal type for created near pointers",
            "case 0x01f0:",
            "typeString = \"T_NCVPTR\";",
            "typeSize = 2;",
            "break;",
            "// CV Internal type for created far pointers",
            "case 0x02f0:",
            "typeString = \"T_FCVPTR\";",
            "typeSize = 4;",
            "break;",
            "// CV Internal type for created huge pointers",
            "case 0x03f0:",
            "typeString = \"T_HCVPTR\";",
            "typeSize = 4;",
            "break;",
            "// CV Internal type for created near 32-bit pointers",
            "case 0x04f0:",
            "typeString = \"T_32NCVPTR\";",
            "typeSize = 4;",
            "break;",
            "// CV Internal type for created far 32-bit pointers",
            "case 0x05f0:",
            "typeString = \"T_32FCVPTR\";",
            "typeSize = 6;",
            "break;",
            "// CV Internal type for created near 64-bit pointers",
            "case 0x06f0:",
            "typeString = \"T_64NCVPTR\";",
            "typeSize = 8;",
            "break;",
            "// CV Internal type for created near 128-bit near pointers (LLVM doc on 0x0700)",
            "case 0x07f0:",
            "typeString = \"T_128NCVPTR\";",
            "typeSize = 16;",
            "break;",
            "default:",
            "pdb.getPdbReaderMetrics().witnessPrimitive(recNum);",
            "typeString = String.format(\"_UnknownPrimitiveType0X%04X_\", recNum);",
            "typeSize = 1; // unknown",
            "break;",
            "}"
        ],
        "max_rank": -0.12446766039486734
    }
]